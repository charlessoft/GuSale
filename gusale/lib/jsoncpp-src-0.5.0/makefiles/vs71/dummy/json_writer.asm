; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	f:\cygwin\home\Charles\GuSale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat


PUBLIC	??_R4Writer@Json@@6B@				; Json::Writer::`RTTI Complete Object Locator'
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R13A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (4,0,4,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4ios_base@std@@6B@				; std::ios_base::`RTTI Complete Object Locator'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ; Json::FastWriter::write
PUBLIC	??_R4FastWriter@Json@@6B@			; Json::FastWriter::`RTTI Complete Object Locator'
PUBLIC	??_R3FastWriter@Json@@8				; Json::FastWriter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FastWriter@Json@@8				; Json::FastWriter::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FastWriter@Json@@8		; Json::FastWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVFastWriter@Json@@@8			; Json::FastWriter `RTTI Type Descriptor'
PUBLIC	?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ; Json::StyledWriter::write
PUBLIC	?setf@ios_base@std@@QAEHHH@Z			; std::ios_base::setf
PUBLIC	?hex@std@@YAAAVios_base@1@AAV21@@Z		; std::hex
PUBLIC	?setf@ios_base@std@@QAEHH@Z			; std::ios_base::setf
PUBLIC	?uppercase@std@@YAAAVios_base@1@AAV21@@Z	; std::uppercase
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
PUBLIC	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
PUBLIC	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?precision@ios_base@std@@QBEHXZ			; std::ios_base::precision
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?decimal_point@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::decimal_point
PUBLIC	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
PUBLIC	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
PUBLIC	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
PUBLIC	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
PUBLIC	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ	; std::_Locinfo::_Getcvt
PUBLIC	?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ	; std::_Locinfo::_Getlconv
PUBLIC	?_Getfalse@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Getfalse
PUBLIC	?_Gettrue@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Gettrue
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z	; std::numpunct<char>::_Init
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	?_Tidy@?$numpunct@D@std@@AAEXXZ			; std::numpunct<char>::_Tidy
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
PUBLIC	??_G?$numpunct@D@std@@MAEPAXI@Z			; std::numpunct<char>::`scalar deleting destructor'
PUBLIC	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z	; std::_Maklocchr<char>
PUBLIC	??0?$numpunct@D@std@@QAE@I@Z			; std::numpunct<char>::numpunct<char>
PUBLIC	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z ; std::numpunct<char>::_Getcat
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	?thousands_sep@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::thousands_sep
PUBLIC	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	??0?$_Iterator_with_base@Uoutput_iterator_tag@std@@XXXXU_Iterator_base@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::output_iterator_tag,void,void,void,void,std::_Iterator_base>::_Iterator_with_base<std::output_iterator_tag,void,void,void,void,std::_Iterator_base>
PUBLIC	??0?$_Outit_with_base@U_Iterator_base@std@@@std@@QAE@XZ ; std::_Outit_with_base<std::_Iterator_base>::_Outit_with_base<std::_Iterator_base>
PUBLIC	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
PUBLIC	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?clear@ios_base@std@@QAEXH@Z			; std::ios_base::clear
PUBLIC	?_Init@ios_base@std@@IAEXXZ			; std::ios_base::_Init
PUBLIC	?widen@?$ctype@D@std@@QBEDD@Z			; std::ctype<char>::widen
PUBLIC	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
PUBLIC	?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
PUBLIC	??0ios_base@std@@IAE@XZ				; std::ios_base::ios_base
PUBLIC	??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
PUBLIC	??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
PUBLIC	??0locale@std@@QAE@XZ				; std::locale::locale
PUBLIC	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
PUBLIC	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
PUBLIC	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
PUBLIC	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??_Gios_base@std@@UAEPAXI@Z			; std::ios_base::`scalar deleting destructor'
PUBLIC	??1ios_base@std@@UAE@XZ				; std::ios_base::~ios_base
PUBLIC	??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
PUBLIC	??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
PUBLIC	??_Glocale@std@@QAEPAXI@Z			; std::locale::`scalar deleting destructor'
PUBLIC	?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::underflow
PUBLIC	?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
PUBLIC	??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
PUBLIC	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?_Xsgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADIH@Z ; std::basic_streambuf<char,std::char_traits<char> >::_Xsgetn_s
PUBLIC	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
PUBLIC	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<char,std::char_traits<char> >::imbue
PUBLIC	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?eq@?$char_traits@D@std@@SA_NABD0@Z		; std::char_traits<char>::eq
PUBLIC	?not_eof@?$char_traits@D@std@@SAHABH@Z		; std::char_traits<char>::not_eof
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
PUBLIC	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
PUBLIC	?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pbase
PUBLIC	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
PUBLIC	?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::gbump
PUBLIC	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
PUBLIC	?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbump
PUBLIC	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp
PUBLIC	??0?$fpos@H@std@@QAE@J@Z			; std::fpos<int>::fpos<int>
PUBLIC	??B?$fpos@H@std@@QBEJXZ				; std::fpos<int>::operator long
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	??0?$_Fillobj@D@std@@QAE@D@Z			; std::_Fillobj<char>::_Fillobj<char>
PUBLIC	??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z	; std::setfill<char>
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEDD@Z ; std::basic_ios<char,std::char_traits<char> >::fill
PUBLIC	??$?6DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z ; std::operator<<<char,std::char_traits<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
PUBLIC	??1FastWriter@Json@@UAE@XZ			; Json::FastWriter::~FastWriter
PUBLIC	??_GFastWriter@Json@@UAEPAXI@Z			; Json::FastWriter::`scalar deleting destructor'
PUBLIC	??_GWriter@Json@@UAEPAXI@Z			; Json::Writer::`scalar deleting destructor'
PUBLIC	??0Writer@Json@@QAE@XZ				; Json::Writer::Writer
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??D?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*
PUBLIC	??D?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++
PUBLIC	?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
PUBLIC	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
PUBLIC	??8?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator!=
PUBLIC	??$_Copy_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Uforward_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::forward_iterator_tag>
PUBLIC	??$_Copy_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$unchecked_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z ; stdext::unchecked_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V32@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase
PUBLIC	?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?width@ios_base@std@@QBEHXZ			; std::ios_base::width
PUBLIC	?width@ios_base@std@@QAEHH@Z			; std::ios_base::width
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1StyledStreamWriter@Json@@QAE@XZ		; Json::StyledStreamWriter::~StyledStreamWriter
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	??_C@_06ECBCCLMB@?$CF?$CD?416g?$AA@		; `string'
PUBLIC	??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@	; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC?$AA@			; `string'
PUBLIC	??_C@_02MCKKLHBJ@?2?$CC?$AA@			; `string'
PUBLIC	??_C@_02HDBGODGB@?2?2?$AA@			; `string'
PUBLIC	??_C@_02DCNDPIBM@?2b?$AA@			; `string'
PUBLIC	??_C@_02FGLPDNBI@?2f?$AA@			; `string'
PUBLIC	??_C@_02JOGGLHBA@?2n?$AA@			; `string'
PUBLIC	??_C@_02HIBBOKEN@?2r?$AA@			; `string'
PUBLIC	??_C@_02COELENML@?2t?$AA@			; `string'
PUBLIC	??_C@_02DHFAHMIK@?2u?$AA@			; `string'
PUBLIC	??_C@_04MLLLIHIP@null?$AA@			; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL?$AA@			; `string'
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN?$AA@			; `string'
PUBLIC	??_C@_01HCONENDN@?$HL?$AA@			; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN?$AA@			; `string'
PUBLIC	??_C@_02MCILKGOH@?$HL?$HN?$AA@			; `string'
PUBLIC	??_C@_03MCPBMLDJ@?5?3?5?$AA@			; `string'
PUBLIC	??_C@_02GPECMEKF@?$FL?$FN?$AA@			; `string'
PUBLIC	??_C@_02PFNDMDBO@?$FL?5?$AA@			; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_02DHOGEDBE@?5?$FN?$AA@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_01GPOEFGEJ@?7?$AA@			; `string'
PUBLIC	??_C@_02EAOCLKAK@ld?$AA@			; `string'
PUBLIC	??_C@_02BDDLJJBK@lu?$AA@			; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld?$AA@			; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu?$AA@			; `string'
PUBLIC	??_C@_02BBAHNLBA@?$CFp?$AA@			; `string'
PUBLIC	??_C@_01DDCIFGEA@E?$AA@				; `string'
PUBLIC	??_C@_01KGKMHCOC@e?$AA@				; `string'
PUBLIC	?_Stz@?$fpos@H@std@@0HB				; std::fpos<int>::_Stz
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	??_7FastWriter@Json@@6B@			; Json::FastWriter::`vftable'
PUBLIC	??_7ios_base@std@@6B@				; std::ios_base::`vftable'
PUBLIC	??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	??_7Writer@Json@@6B@				; Json::Writer::`vftable'
EXTRN	_strpbrk:PROC
EXTRN	_strcspn:PROC
EXTRN	_sprintf_s:PROC
EXTRN	_memchr:PROC
EXTRN	__Getcvt:PROC
EXTRN	_localeconv:PROC
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	?setw@std@@YA?AU?$_Smanip@H@1@H@Z:PROC		; std::setw
EXTRN	?_Addstd@ios_base@std@@SAXPAV12@@Z:PROC		; std::ios_base::_Addstd
EXTRN	??0_Mutex@std@@QAE@XZ:PROC			; std::_Mutex::_Mutex
EXTRN	?_Init@locale@std@@CAPAV_Locimp@12@XZ:PROC	; std::locale::_Init
EXTRN	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z:PROC	; std::ios_base::_Ios_base_dtor
EXTRN	??_Eios_base@std@@UAEPAXI@Z:PROC		; std::ios_base::`vector deleting destructor'
EXTRN	??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ios<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??1_Mutex@std@@QAE@XZ:PROC			; std::_Mutex::~_Mutex
EXTRN	??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	?_BADOFF@std@@3JB:DWORD				; std::_BADOFF
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_EFastWriter@Json@@UAEPAXI@Z:PROC		; Json::FastWriter::`vector deleting destructor'
EXTRN	??_EWriter@Json@@UAEPAXI@Z:PROC			; Json::Writer::`vector deleting destructor'
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
;	COMDAT ??_7Writer@Json@@6B@
CONST	SEGMENT
??_7Writer@Json@@6B@ DD FLAT:??_R4Writer@Json@@6B@	; Json::Writer::`vftable'
	DD	FLAT:??_EWriter@Json@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4Writer@Json@@6B@
rdata$r	SEGMENT
??_R4Writer@Json@@6B@ DD 00H				; Json::Writer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVWriter@Json@@@8
	DD	FLAT:??_R3Writer@Json@@8
rdata$r	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
_DATA	ENDS
;	COMDAT ??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
CONST	SEGMENT
??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@ DD 00H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	04cH
CONST	ENDS
;	COMDAT ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	04cH
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R13A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allo'
	DB	'cator@D@2@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
	DD	FLAT:?_Xsgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADIH@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
	DD	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@JHH@Z
	DD	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
	DD	04H
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R13A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R13A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R13A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (4,0,4,64)'
	DD	00H
	DD	04H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
	DD	FLAT:?_Xsgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADIH@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
	DD	FLAT:?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
	DD	FLAT:?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R13?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT
??_7ios_base@std@@6B@ DD FLAT:??_R4ios_base@std@@6B@	; std::ios_base::`vftable'
	DD	FLAT:??_Eios_base@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4ios_base@std@@6B@
rdata$r	SEGMENT
??_R4ios_base@std@@6B@ DD 00H				; std::ios_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVios_base@std@@@8
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
_DATA	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
_DATA	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7FastWriter@Json@@6B@
CONST	SEGMENT
??_7FastWriter@Json@@6B@ DD FLAT:??_R4FastWriter@Json@@6B@ ; Json::FastWriter::`vftable'
	DD	FLAT:??_EFastWriter@Json@@UAEPAXI@Z
	DD	FLAT:?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
CONST	ENDS
;	COMDAT ??_R4FastWriter@Json@@6B@
rdata$r	SEGMENT
??_R4FastWriter@Json@@6B@ DD 00H			; Json::FastWriter::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFastWriter@Json@@@8
	DD	FLAT:??_R3FastWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3FastWriter@Json@@8
rdata$r	SEGMENT
??_R3FastWriter@Json@@8 DD 00H				; Json::FastWriter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FastWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2FastWriter@Json@@8
rdata$r	SEGMENT
??_R2FastWriter@Json@@8 DD FLAT:??_R1A@?0A@EA@FastWriter@Json@@8 ; Json::FastWriter::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Writer@Json@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@FastWriter@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FastWriter@Json@@8 DD FLAT:??_R0?AVFastWriter@Json@@@8 ; Json::FastWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FastWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFastWriter@Json@@@8
_DATA	SEGMENT
??_R0?AVFastWriter@Json@@@8 DD FLAT:??_7type_info@@6B@	; Json::FastWriter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFastWriter@Json@@', 00H
_DATA	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HB
CONST	SEGMENT
?_Stz@?$fpos@H@std@@0HB DD 00H				; std::fpos<int>::_Stz
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT
??_C@_01KGKMHCOC@e?$AA@ DB 'e', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT
??_C@_01DDCIFGEA@E?$AA@ DB 'E', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp?$AA@ DB '%p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu?$AA@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld?$AA@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu?$AA@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld?$AA@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GPOEFGEJ@?7?$AA@
CONST	SEGMENT
??_C@_01GPOEFGEJ@?7?$AA@ DB 09H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DHOGEDBE@?5?$FN?$AA@
CONST	SEGMENT
??_C@_02DHOGEDBE@?5?$FN?$AA@ DB ' ]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PFNDMDBO@?$FL?5?$AA@
CONST	SEGMENT
??_C@_02PFNDMDBO@?$FL?5?$AA@ DB '[ ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GPECMEKF@?$FL?$FN?$AA@
CONST	SEGMENT
??_C@_02GPECMEKF@?$FL?$FN?$AA@ DB '[]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCPBMLDJ@?5?3?5?$AA@
CONST	SEGMENT
??_C@_03MCPBMLDJ@?5?3?5?$AA@ DB ' : ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCILKGOH@?$HL?$HN?$AA@
CONST	SEGMENT
??_C@_02MCILKGOH@?$HL?$HN?$AA@ DB '{}', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN?$AA@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN?$AA@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL?$AA@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL?$AA@ DB '{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN?$AA@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL?$AA@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL?$AA@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLLLIHIP@null?$AA@
CONST	SEGMENT
??_C@_04MLLLIHIP@null?$AA@ DB 'null', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DHFAHMIK@?2u?$AA@
CONST	SEGMENT
??_C@_02DHFAHMIK@?2u?$AA@ DB '\u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02COELENML@?2t?$AA@
CONST	SEGMENT
??_C@_02COELENML@?2t?$AA@ DB '\t', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIBBOKEN@?2r?$AA@
CONST	SEGMENT
??_C@_02HIBBOKEN@?2r?$AA@ DB '\r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JOGGLHBA@?2n?$AA@
CONST	SEGMENT
??_C@_02JOGGLHBA@?2n?$AA@ DB '\n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGLPDNBI@?2f?$AA@
CONST	SEGMENT
??_C@_02FGLPDNBI@?2f?$AA@ DB '\f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCNDPIBM@?2b?$AA@
CONST	SEGMENT
??_C@_02DCNDPIBM@?2b?$AA@ DB '\b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HDBGODGB@?2?2?$AA@
CONST	SEGMENT
??_C@_02HDBGODGB@?2?2?$AA@ DB '\\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCKKLHBJ@?2?$CC?$AA@
CONST	SEGMENT
??_C@_02MCKKLHBJ@?2?$CC?$AA@ DB '\"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC?$AA@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@
CONST	SEGMENT
??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@ DB '"\', 08H, 0cH, 0aH, 0dH, 09H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06ECBCCLMB@?$CF?$CD?416g?$AA@
CONST	SEGMENT
??_C@_06ECBCCLMB@?$CF?$CD?416g?$AA@ DB '%#.16g', 00H	; `string'
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT
; __Ptr$ = eax

; 604  : 	{	// convert C string to _Elem sequence using _Cvtvec

	push	esi
	push	edi
	mov	edi, eax

; 605  : 	size_t _Count = ::strlen(_Ptr) + 1;

	lea	edx, DWORD PTR [eax+1]
$LL8@Maklocstr:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL8@Maklocstr
	sub	eax, edx
	lea	esi, DWORD PTR [eax+1]

; 606  : 	_Elem *_Ptrdest = _NEW_CRT _Elem[_Count];

	push	esi
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 607  : 
; 608  : #pragma warning(push)
; 609  : #pragma warning(disable: 6011)
; 610  : 	/* prefast noise */
; 611  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

	test	esi, esi
	mov	ecx, eax
	jbe	SHORT $LN1@Maklocstr
$LL3@Maklocstr:

; 612  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	mov	dl, BYTE PTR [edi]
	mov	BYTE PTR [ecx], dl
	sub	esi, 1
	add	ecx, 1
	add	edi, 1
	test	esi, esi
	ja	SHORT $LL3@Maklocstr
$LN1@Maklocstr:
	pop	edi
	pop	esi

; 613  : 	return (_Ptrdest);
; 614  : #pragma warning(pop)
; 615  : 	}

	ret	0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\iomanip
_TEXT	ENDS
;	COMDAT ??0?$_Fillobj@D@std@@QAE@D@Z
_TEXT	SEGMENT
??0?$_Fillobj@D@std@@QAE@D@Z PROC			; std::_Fillobj<char>::_Fillobj<char>, COMDAT
; _this$ = eax

; 21   : 		{	// construct from fill character

	mov	BYTE PTR [eax], 48			; 00000030H

; 22   : 		}

	ret	0
??0?$_Fillobj@D@std@@QAE@D@Z ENDP			; std::_Fillobj<char>::_Fillobj<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z
_TEXT	SEGMENT
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx
; __Count$ = edx

; 169  : 		return (xsputn(_Ptr, _Count));

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+32]
	push	edx
	push	OFFSET ??_C@_02DHFAHMIK@?2u?$AA@
	call	eax

; 170  : 		}

	ret	0
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ios
_TEXT	ENDS
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEDD@Z
_TEXT	SEGMENT
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEDD@Z PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx
; __Newfill$ = edx

; 111  : 		_Elem _Oldfill = _Fillch;

	mov	al, BYTE PTR [ecx+48]

; 112  : 		_Fillch = _Newfill;

	mov	BYTE PTR [ecx+48], dl

; 113  : 		return (_Oldfill);
; 114  : 		}

	ret	0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEDD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC		; std::_Maklocchr<char>, COMDAT
; __Byte$ = eax

; 583  : 	return ((_Elem)(unsigned char)_Byte);
; 584  : 	}

	ret	0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\iomanip
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z
_TEXT	SEGMENT
??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,int>, COMDAT
; __Ostr$ = esi
; __Manip$ = ecx

; 83   : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	test	esi, esi
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 84   : 	return (_Ostr);

	mov	eax, esi

; 85   : 	}

	ret	0
$LN3@operator:

; 83   : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	add	eax, esi
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 84   : 	return (_Ostr);

	mov	eax, esi

; 85   : 	}

	ret	0
??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z
_TEXT	SEGMENT
__Manip$ = 8						; size = 4
??$?6DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z PROC ; std::operator<<<char,std::char_traits<char> >, COMDAT
; __Ostr$ = eax

; 50   : 	_Ostr.fill(_Manip._Fill);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Manip$[esp-4]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [edx+eax+48], cl

; 51   : 	return (_Ostr);
; 52   : 	}

	ret	0
??$?6DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z ENDP ; std::operator<<<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z
_TEXT	SEGMENT
??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z PROC		; std::setfill<char>, COMDAT
; ___$ReturnUdt$ = eax

; 31   : 	return (_Fillobj<_Elem>(_Ch));

	mov	BYTE PTR [eax], 48			; 00000030H

; 32   : 	}

	ret	0
??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z ENDP		; std::setfill<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$numpunct@D@std@@AAEXXZ PROC			; std::numpunct<char>::_Tidy, COMDAT
; _this$ = esi

; 172  : 		_DELETE_CRT_VEC((void *)_Grouping);

	mov	eax, DWORD PTR [esi+8]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]

; 173  : 		_DELETE_CRT_VEC((void *)_Falsename);

	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]

; 174  : 		_DELETE_CRT_VEC((void *)_Truename);

	mov	edx, DWORD PTR [esi+20]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH

; 175  : 		}

	ret	0
?_Tidy@?$numpunct@D@std@@AAEXXZ ENDP			; std::numpunct<char>::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?thousands_sep@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::thousands_sep, COMDAT
; _this$ = ecx

; 65   : 		return (do_thousands_sep());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	jmp	edx
?thousands_sep@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::thousands_sep
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?decimal_point@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::decimal_point, COMDAT
; _this$ = ecx

; 60   : 		return (do_decimal_point());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	jmp	edx
?decimal_point@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::decimal_point
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = eax

; 2200 : 		return (*this);
; 2201 : 		}

	ret	0
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = eax

; 2195 : 		return (*this);
; 2196 : 		}

	ret	0
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 151  : 		return (_Kseparator);

	mov	al, BYTE PTR [ecx+13]

; 152  : 		}

	ret	0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 146  : 		return (_Dp);

	mov	al, BYTE PTR [ecx+12]

; 147  : 		}

	ret	0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt, COMDAT
; __Fmt$ = eax
; __Spec$ = edi
; __Flags$ = edx

; 1237 : 		char *_Ptr = _Fmt;
; 1238 : 		*_Ptr++ = '%';
; 1239 : 
; 1240 : 		if (_Flags & ios_base::showpos)

	test	dl, 32					; 00000020H
	mov	BYTE PTR [eax], 37			; 00000025H
	lea	ecx, DWORD PTR [eax+1]
	je	SHORT $LN4@Ifmt

; 1241 : 			*_Ptr++ = '+';

	mov	BYTE PTR [ecx], 43			; 0000002bH
	add	ecx, 1
$LN4@Ifmt:

; 1242 : 		if (_Flags & ios_base::showbase)

	test	dl, 8
	je	SHORT $LN3@Ifmt

; 1243 : 			*_Ptr++ = '#';

	mov	BYTE PTR [ecx], 35			; 00000023H
	add	ecx, 1
$LN3@Ifmt:
	push	ebx

; 1244 : 		if (_Spec[0] != 'L')

	mov	bl, BYTE PTR [edi]
	cmp	bl, 76					; 0000004cH
	push	esi
	je	SHORT $LN2@Ifmt

; 1245 : 			*_Ptr++ = _Spec[0];	// qualifier

	mov	BYTE PTR [ecx], bl

; 1246 : 		else

	jmp	SHORT $LN11@Ifmt
$LN2@Ifmt:

; 1247 : 			{	/* change L to I64 */
; 1248 : 			*_Ptr++ = 'I';

	mov	BYTE PTR [ecx], 73			; 00000049H
	add	ecx, 1

; 1249 : 			*_Ptr++ = '6';

	mov	BYTE PTR [ecx], 54			; 00000036H
	add	ecx, 1

; 1250 : 			*_Ptr++ = '4';

	mov	BYTE PTR [ecx], 52			; 00000034H
$LN11@Ifmt:

; 1251 : 			}
; 1252 : 
; 1253 : 		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

	mov	esi, edx
	and	esi, 3584				; 00000e00H
	add	ecx, 1

; 1254 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
; 1255 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1256 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';

	cmp	esi, 1024				; 00000400H
	jne	SHORT $LN9@Ifmt
	mov	dl, 111					; 0000006fH
	pop	esi
	mov	BYTE PTR [ecx], dl

; 1257 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0
	pop	ebx

; 1258 : 		return (_Fmt);
; 1259 : 		}

	ret	0
$LN9@Ifmt:

; 1254 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
; 1255 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1256 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';

	cmp	esi, 2048				; 00000800H
	je	SHORT $LN7@Ifmt
	mov	dl, BYTE PTR [edi+1]
	pop	esi
	mov	BYTE PTR [ecx], dl

; 1257 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0
	pop	ebx

; 1258 : 		return (_Fmt);
; 1259 : 		}

	ret	0
$LN7@Ifmt:

; 1254 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
; 1255 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1256 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';

	add	dl, dl
	add	dl, dl
	add	dl, dl
	not	dl
	and	dl, 32					; 00000020H
	or	dl, 88					; 00000058H
	pop	esi
	mov	BYTE PTR [ecx], dl

; 1257 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0
	pop	ebx

; 1258 : 		return (_Fmt);
; 1259 : 		}

	ret	0
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT
; __Fmt$ = esi
; __Spec$ = eax
; __Flags$ = edx

; 1095 : 		char *_Ptr = _Fmt;
; 1096 : 		*_Ptr++ = '%';
; 1097 : 
; 1098 : 		if (_Flags & ios_base::showpos)

	test	dl, 32					; 00000020H
	mov	BYTE PTR [esi], 37			; 00000025H
	lea	ecx, DWORD PTR [esi+1]
	je	SHORT $LN3@Ffmt

; 1099 : 			*_Ptr++ = '+';

	mov	BYTE PTR [ecx], 43			; 0000002bH
	add	ecx, 1
$LN3@Ffmt:

; 1100 : 		if (_Flags & ios_base::showpoint)

	test	dl, 16					; 00000010H
	je	SHORT $LN2@Ffmt

; 1101 : 			*_Ptr++ = '#';

	mov	BYTE PTR [ecx], 35			; 00000023H
	add	ecx, 1
$LN2@Ffmt:

; 1102 : 		*_Ptr++ = '.';

	mov	BYTE PTR [ecx], 46			; 0000002eH
	add	ecx, 1

; 1103 : 		*_Ptr++ = '*';	// for precision argument

	mov	BYTE PTR [ecx], 42			; 0000002aH
	add	ecx, 1

; 1104 : 		if (_Spec != '\0')

	test	al, al
	je	SHORT $LN1@Ffmt

; 1105 : 			*_Ptr++ = _Spec;	// 'L' qualifier for long double only

	mov	BYTE PTR [ecx], al
	add	ecx, 1
$LN1@Ffmt:

; 1106 : 
; 1107 : 		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

	and	edx, 12288				; 00003000H

; 1108 : 		*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1109 : 			: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

	cmp	edx, 8192				; 00002000H
	jne	SHORT $LN6@Ffmt
	mov	dl, 102					; 00000066H
	mov	BYTE PTR [ecx], dl

; 1110 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0

; 1111 : 		return (_Fmt);

	mov	eax, esi

; 1112 : 		}

	ret	0
$LN6@Ffmt:

; 1108 : 		*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1109 : 			: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

	cmp	edx, 4096				; 00001000H
	setne	dl

; 1111 : 		return (_Fmt);

	mov	eax, esi
	lea	edx, DWORD PTR [edx+edx+101]
	mov	BYTE PTR [ecx], dl
	mov	BYTE PTR [ecx+1], 0

; 1112 : 		}

	ret	0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\sstream
_TEXT	ENDS
;	COMDAT ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z
_TEXT	SEGMENT
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate, COMDAT

; 315  : 		_Strstate _State = (_Strstate)0;
; 316  : 		if (!(_Mode & ios_base::in))
; 317  : 			_State |= _Noread;
; 318  : 		if (!(_Mode & ios_base::out))
; 319  : 			_State |= _Constant;
; 320  : 		if (_Mode & ios_base::app)
; 321  : 			_State |= _Append;
; 322  : 		if (_Mode & ios_base::ate)
; 323  : 			_State |= _Atend;
; 324  : 		return (_State);

	mov	eax, 4

; 325  : 		}

	ret	0
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@std@@QBEJXZ
_TEXT	SEGMENT
??B?$fpos@H@std@@QBEJXZ PROC				; std::fpos<int>::operator long, COMDAT
; _this$ = ecx

; 72   : 		return (_Myoff + _FPOSOFF(_Fpos));

	mov	eax, DWORD PTR [ecx+8]
	add	eax, DWORD PTR [ecx]

; 73   : 		}

	ret	0
??B?$fpos@H@std@@QBEJXZ ENDP				; std::fpos<int>::operator long
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT
??0?$fpos@H@std@@QAE@J@Z PROC				; std::fpos<int>::fpos<int>, COMDAT
; _this$ = eax
; __Off$ = ecx

; 47   : 		{	// construct with stream offset

	mov	DWORD PTR [eax], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 48   : 		}

	ret	0
??0?$fpos@H@std@@QAE@J@Z ENDP				; std::fpos<int>::fpos<int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed, COMDAT
; _this$ = eax

; 2210 : 		return (_Failed);

	mov	al, BYTE PTR [eax+4]

; 2211 : 		}

	ret	0
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 12
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi
; __Val$ = eax

; 886  : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+28]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp]
	push	eax
	mov	eax, DWORD PTR __Fill$[esp+4]
	push	eax
	mov	eax, DWORD PTR __Iosbase$[esp+8]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR __Dest$[esp+28]
	mov	DWORD PTR [eax+4], edi
	mov	edi, DWORD PTR __Dest$[esp+32]
	push	esi
	mov	DWORD PTR [eax+8], edi
	call	edx
	mov	eax, esi

; 887  : 		}

	pop	edi
	ret	20					; 00000014H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = eax

; 114  : 			return (_Ok);

	mov	al, BYTE PTR [eax+4]

; 115  : 			}

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++, COMDAT
; _this$ = esi

; 117  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL);

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN2@operator@2
	call	__invalid_parameter_noinfo
$LN2@operator@2:

; 118  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Mycont))->_Mylast);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+8]
	jb	SHORT $LN5@operator@2
	call	__invalid_parameter_noinfo
$LN5@operator@2:

; 119  : 		++_Myptr;

	add	DWORD PTR [esi+4], 28			; 0000001cH

; 120  : 		return (*this);

	mov	eax, esi

; 121  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*, COMDAT
; _this$ = esi

; 93   : 
; 94   :  #if _HAS_ITERATOR_DEBUGGING
; 95   : 		if (this->_Mycont == 0
; 96   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 97   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 98   : 			{
; 99   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  :  #else
; 103  :  		_SCL_SECURE_VALIDATE(this->_Mycont != NULL);

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN2@operator@3
	call	__invalid_parameter_noinfo
$LN2@operator@3:

; 104  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Mycont))->_Mylast);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+8]
	jb	SHORT $LN5@operator@3
	call	__invalid_parameter_noinfo

; 105  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 106  : 
; 107  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 108  : 		}

	ret	0
$LN5@operator@3:

; 105  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 106  : 
; 107  : 		return (*_Myptr);

	mov	eax, ecx

; 108  : 		}

	ret	0
??D?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = eax

; 278  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Pnavail
	mov	edx, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [edx]

; 279  : 		}

	ret	0
$LN3@Pnavail:

; 278  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	xor	eax, eax

; 279  : 		}

	ret	0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 272  : 		--*_IPcount;

	mov	eax, DWORD PTR [ecx+52]
	add	DWORD PTR [eax], -1

; 273  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx

; 274  : 		}

	ret	0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z
_TEXT	SEGMENT
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setp, COMDAT
; _this$ = ecx
; __First$ = edi
; __Next$ = edx
; __Last$ = eax

; 264  : 		{	// set pointers for write buffer, extended version

	push	esi

; 265  : 		*_IPfirst = _First;

	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [esi], edi

; 266  : 		*_IPnext = _Next;

	mov	esi, DWORD PTR [ecx+36]
	mov	DWORD PTR [esi], edx

; 267  : 		*_IPcount = (int)(_Last - _Next);

	mov	ecx, DWORD PTR [ecx+52]
	sub	eax, edx
	mov	DWORD PTR [ecx], eax
	pop	esi

; 268  : 		}

	ret	0
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setp
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z
_TEXT	SEGMENT
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setp, COMDAT
; _this$ = edx
; __First$ = ecx
; __Last$ = eax

; 257  : 		{	// set pointers for write buffer

	push	esi

; 258  : 		*_IPfirst = _First;

	mov	esi, DWORD PTR [edx+20]
	mov	DWORD PTR [esi], ecx

; 259  : 		*_IPnext = _First;

	mov	esi, DWORD PTR [edx+36]
	mov	DWORD PTR [esi], ecx

; 260  : 		*_IPcount = (int)(_Last - _First);

	sub	eax, ecx
	mov	ecx, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx], eax
	pop	esi

; 261  : 		}

	ret	0
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setp
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbump, COMDAT
; _this$ = edx
; __Off$ = ecx

; 252  : 		*_IPcount -= _Off;

	mov	eax, DWORD PTR [edx+52]
	sub	DWORD PTR [eax], ecx

; 253  : 		*_IPnext += _Off;

	mov	eax, DWORD PTR [edx+36]
	add	DWORD PTR [eax], ecx

; 254  : 		}

	ret	0
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbump
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::epptr, COMDAT
; _this$ = eax

; 224  : 		return (*_IPnext + *_IPcount);

	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR [ecx]
	add	eax, DWORD PTR [edx]

; 225  : 		}

	ret	0
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::epptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z
_TEXT	SEGMENT
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setg, COMDAT
; _this$ = ecx
; __First$ = edi
; __Next$ = edx
; __Last$ = eax

; 216  : 		{	// set pointers for read buffer

	push	esi

; 217  : 		*_IGfirst = _First;

	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi], edi

; 218  : 		*_IGnext = _Next;

	mov	esi, DWORD PTR [ecx+32]
	mov	DWORD PTR [esi], edx

; 219  : 		*_IGcount = (int)(_Last - _Next);

	mov	ecx, DWORD PTR [ecx+48]
	sub	eax, edx
	mov	DWORD PTR [ecx], eax
	pop	esi

; 220  : 		}

	ret	0
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setg
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::gbump, COMDAT
; _this$ = edx
; __Off$ = ecx

; 211  : 		*_IGcount -= _Off;

	mov	eax, DWORD PTR [edx+48]
	sub	DWORD PTR [eax], ecx

; 212  : 		*_IGnext += _Off;

	mov	eax, DWORD PTR [edx+32]
	add	DWORD PTR [eax], ecx

; 213  : 		}

	ret	0
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gbump
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::egptr, COMDAT
; _this$ = eax

; 206  : 		return (*_IGnext + *_IGcount);

	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [ecx]
	add	eax, DWORD PTR [edx]

; 207  : 		}

	ret	0
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::egptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pptr, COMDAT
; _this$ = eax

; 201  : 		return (*_IPnext);

	mov	ecx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR [ecx]

; 202  : 		}

	ret	0
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbase, COMDAT
; _this$ = eax

; 196  : 		return (*_IPfirst);

	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [ecx]

; 197  : 		}

	ret	0
?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::eback, COMDAT
; _this$ = eax

; 186  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [ecx]

; 187  : 		}

	ret	0
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::eback
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ios
_TEXT	ENDS
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = eax

; 106  : 		return (_Fillch);

	mov	al, BYTE PTR [eax+48]

; 107  : 		}

	ret	0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 191  : 
; 192  :  #if _HAS_ITERATOR_DEBUGGING
; 193  : 		_Compat(_Right);
; 194  :  #else
; 195  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL && this->_Mycont == _Right._Mycont);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@4
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@4
$LN1@operator@4:
	call	__invalid_parameter_noinfo
$LN2@operator@4:

; 196  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 197  : 
; 198  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 199  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++, COMDAT
; _this$ = esi

; 336  : 		++(*(_Mybase *)this);

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN4@operator@5
	call	__invalid_parameter_noinfo
$LN4@operator@5:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+8]
	jb	SHORT $LN7@operator@5
	call	__invalid_parameter_noinfo
$LN7@operator@5:
	add	DWORD PTR [esi+4], 28			; 0000001cH

; 337  : 		return (*this);

	mov	eax, esi

; 338  : 		}

	ret	0
??E?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ PROC ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*, COMDAT
; _this$ = esi

; 326  : 		return ((reference)**(_Mybase *)this);

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN4@operator@6
	call	__invalid_parameter_noinfo
$LN4@operator@6:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+8]
	jb	SHORT $LN7@operator@6
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 327  : 		}

	ret	0
$LN7@operator@6:

; 326  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 327  : 		}

	ret	0
??D?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ENDP ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 415  : 		}

	ret	4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::imbue
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 410  : 		return (0);

	xor	eax, eax

; 411  : 		}

	ret	0
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sync
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 404  : 		{	// offer buffer to external agent (do nothing)

	mov	eax, ecx

; 405  : 		return (this);
; 406  : 		}

	ret	8
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 400  : 		return (streampos(_BADOFF));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR ?_BADOFF@std@@3JB	; std::_BADOFF
	mov	DWORD PTR [eax], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 401  : 		}

	ret	32					; 00000020H
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 394  : 		return (streampos(_BADOFF));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR ?_BADOFF@std@@3JB	; std::_BADOFF
	mov	DWORD PTR [eax], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 395  : 		}

	ret	16					; 00000010H
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn, COMDAT
; _this$ = ecx

; 327  : 		// assume the destination buffer is large enough
; 328  : 		return _Xsgetn_s(_Ptr, (size_t)-1, _Count);

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+28]
	push	edx
	mov	edx, DWORD PTR __Ptr$[esp]
	push	-1
	push	edx
	call	eax

; 329  : 		}

	ret	8
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc, COMDAT
; _this$ = ecx

; 309  : 		return (0);

	xor	eax, eax

; 310  : 		}

	ret	0
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
_TEXT	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z
_TEXT	SEGMENT
__Pfn$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = esi

; 183  : 		_DEBUG_POINTER(_Pfn);
; 184  : 		(*_Pfn)(*(ios_base *)this);

	test	esi, esi
	jne	SHORT $LN3@operator@7
	xor	eax, eax
	push	eax
	call	DWORD PTR __Pfn$[esp]
	add	esp, 4

; 185  : 		return (*this);

	mov	eax, esi

; 186  : 		}

	ret	4
$LN3@operator@7:

; 183  : 		_DEBUG_POINTER(_Pfn);
; 184  : 		(*_Pfn)(*(ios_base *)this);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	add	eax, esi
	push	eax
	call	DWORD PTR __Pfn$[esp]
	add	esp, 4

; 185  : 		return (*this);

	mov	eax, esi

; 186  : 		}

	ret	4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 61   : 		{	// destroy the object

	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx-4], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@

; 62   : 		}

	ret	0
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??1Writer@Json@@UAE@XZ				; Json::Writer::~Writer
; Function compile flags: /Ogtpy
; File f:\cygwin\home\charles\gusale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ??1Writer@Json@@UAE@XZ
_TEXT	SEGMENT
??1Writer@Json@@UAE@XZ PROC				; Json::Writer::~Writer, COMDAT
; _this$ = ecx

; 177  : {

	mov	DWORD PTR [ecx], OFFSET ??_7Writer@Json@@6B@

; 178  : }

	ret	0
??1Writer@Json@@UAE@XZ ENDP				; Json::Writer::~Writer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?uintToString@Json@@YAXIAAPAD@Z
_TEXT	SEGMENT
?uintToString@Json@@YAXIAAPAD@Z PROC			; Json::uintToString, COMDAT
; _value$ = ecx
; _current$ = edi

; 33   :    *--current = 0;

	add	DWORD PTR [edi], -1
	push	ebx
	push	esi
	mov	esi, DWORD PTR [edi]
	mov	BYTE PTR [esi], 0
	npad	6
$LL3@uintToStri:

; 34   :    do
; 35   :    {
; 36   :       *--current = (value % 10) + '0';

	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 3
	mov	al, dl
	mov	bl, 10					; 0000000aH
	imul	bl
	sub	cl, al
	add	cl, 48					; 00000030H
	sub	esi, 1
	mov	BYTE PTR [esi], cl

; 37   :       value /= 10;

	mov	ecx, edx

; 38   :    }
; 39   :    while ( value != 0 );

	test	ecx, ecx
	jne	SHORT $LL3@uintToStri
	mov	DWORD PTR [edi], esi
	pop	esi
	pop	ebx

; 40   : }

	ret	0
?uintToString@Json@@YAXIAAPAD@Z ENDP			; Json::uintToString
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isControlCharacter@Json@@YA_ND@Z
_TEXT	SEGMENT
?isControlCharacter@Json@@YA_ND@Z PROC			; Json::isControlCharacter, COMDAT
; _ch$ = eax

; 18   :    return ch > 0 && ch <= 0x1F;

	sub	al, 1
	mov	cl, 30					; 0000001eH
	cmp	cl, al
	sbb	eax, eax
	add	eax, 1

; 19   : }

	ret	0
?isControlCharacter@Json@@YA_ND@Z ENDP			; Json::isControlCharacter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ??0ios_base@std@@IAE@XZ
_TEXT	SEGMENT
??0ios_base@std@@IAE@XZ PROC				; std::ios_base::ios_base, COMDAT
; _this$ = eax

; 498  : 	__CLR_OR_THIS_CALL ios_base()

	mov	DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@

; 499  : 		{	// default constructor
; 500  : 		}

	ret	0
??0ios_base@std@@IAE@XZ ENDP				; std::ios_base::ios_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ios_base@std@@UAE@XZ PROC				; std::ios_base::~ios_base, COMDAT
; _this$ = ecx

; 482  :         _Ios_base_dtor(this);

	push	ecx
	mov	DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	pop	ecx

; 483  :         }

	ret	0
??1ios_base@std@@UAE@XZ ENDP				; std::ios_base::~ios_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT
__Newwidth$ = 8						; size = 4
?width@ios_base@std@@QAEHH@Z PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 412  : 		streamsize _Oldwidth = _Wide;
; 413  : 		_Wide = _Newwidth;

	mov	edx, DWORD PTR __Newwidth$[esp-4]
	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+24], edx

; 414  : 		return (_Oldwidth);
; 415  : 		}

	ret	4
?width@ios_base@std@@QAEHH@Z ENDP			; std::ios_base::width
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?width@ios_base@std@@QBEHXZ PROC			; std::ios_base::width, COMDAT
; _this$ = eax

; 407  : 		return (_Wide);

	mov	eax, DWORD PTR [eax+24]

; 408  : 		}

	ret	0
?width@ios_base@std@@QBEHXZ ENDP			; std::ios_base::width
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?precision@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?precision@ios_base@std@@QBEHXZ PROC			; std::ios_base::precision, COMDAT
; _this$ = eax

; 395  : 		return (_Prec);

	mov	eax, DWORD PTR [eax+20]

; 396  : 		}

	ret	0
?precision@ios_base@std@@QBEHXZ ENDP			; std::ios_base::precision
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHHH@Z
_TEXT	SEGMENT
__Newfmtflags$ = 8					; size = 4
__Mask$ = 12						; size = 4
?setf@ios_base@std@@QAEHHH@Z PROC			; std::ios_base::setf, COMDAT
; _this$ = ecx

; 382  : 		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
; 383  : 		_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
; 384  : 			| ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));

	mov	edx, DWORD PTR __Mask$[esp-4]
	mov	eax, DWORD PTR [ecx+16]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newfmtflags$[esp+4]
	mov	esi, edx
	not	esi
	and	edi, edx
	and	esi, eax
	and	edi, 65535				; 0000ffffH
	or	esi, edi
	pop	edi
	mov	DWORD PTR [ecx+16], esi
	pop	esi

; 385  : 		return (_Oldfmtflags);
; 386  : 		}

	ret	8
?setf@ios_base@std@@QAEHHH@Z ENDP			; std::ios_base::setf
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT
?setf@ios_base@std@@QAEHH@Z PROC			; std::ios_base::setf, COMDAT
; _this$ = ecx

; 374  : 		ios_base::fmtflags _Oldfmtflags = _Fmtfl;

	mov	eax, DWORD PTR [ecx+16]

; 375  : 		_Fmtfl = (fmtflags)((int)_Fmtfl
; 376  : 			| (int)_Newfmtflags & (int)_Fmtmask);

	mov	edx, eax
	or	edx, 4
	mov	DWORD PTR [ecx+16], edx

; 377  : 		return (_Oldfmtflags);
; 378  : 		}

	ret	0
?setf@ios_base@std@@QAEHH@Z ENDP			; std::ios_base::setf
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT
?widen@?$ctype@D@std@@QBEDD@Z PROC			; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 1685 : 		return (do_widen(_Byte));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+24]
	push	32					; 00000020H
	call	edx

; 1686 : 		}

	ret	0
?widen@?$ctype@D@std@@QBEDD@Z ENDP			; std::ctype<char>::widen
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 73   : 			{	// construct with specified stamp value

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax], ecx

; 74   : 			}

	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocinfo
_TEXT	ENDS
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Gettrue@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Gettrue, COMDAT

; 168  : 		return ("true");

	mov	eax, OFFSET ??_C@_04LOAJBDKD@true?$AA@

; 169  : 		}

	ret	0
?_Gettrue@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Gettrue
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Getfalse@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Getfalse, COMDAT

; 163  : 		return ("false");

	mov	eax, OFFSET ??_C@_05LAPONLG@false?$AA@

; 164  : 		}

	ret	0
?_Getfalse@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Getfalse
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ PROC		; std::_Locinfo::_Getlconv, COMDAT

; 125  : 		return (localeconv());

	jmp	_localeconv
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ PROC		; std::_Locinfo::_Getcvt, COMDAT
; ___$ReturnUdt$ = esi

; 120  : 		return (::_Getcvt());

	call	__Getcvt
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], edx
	mov	eax, esi

; 121  : 		}

	ret	0
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?eq@?$char_traits@D@std@@SA_NABD0@Z
_TEXT	SEGMENT
?eq@?$char_traits@D@std@@SA_NABD0@Z PROC		; std::char_traits<char>::eq, COMDAT
; __Left$ = eax
; __Right$ = edx

; 423  : 		return (_Left == _Right);

	mov	cl, BYTE PTR [eax]
	xor	eax, eax
	cmp	cl, BYTE PTR [edx]
	sete	al

; 424  : 		}

	ret	0
?eq@?$char_traits@D@std@@SA_NABD0@Z ENDP		; std::char_traits<char>::eq
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z$0
__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z$2
__ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z PROC	; std::numpunct<char>::_Init, COMDAT

; 123  : 		{	// initialize from _Lobj

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR _this$[ebp]

; 124  : 		const lconv *_Ptr = _Lobj._Getlconv();

	call	_localeconv
	mov	esi, eax

; 125  : 
; 126  : 		_Grouping = 0;

	xor	eax, eax
	mov	DWORD PTR __Ptr$[ebp], esi
	mov	DWORD PTR [ebx+8], eax

; 127  : 		_Falsename = 0;

	mov	DWORD PTR [ebx+16], eax

; 128  : 		_Truename = 0;

	mov	DWORD PTR [ebx+20], eax

; 129  : 
; 130  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], eax

; 131  : 		_Grouping = _MAKLOCSTR(char, _Ptr->grouping, _Lobj._Getcvt());

	call	__Getcvt
	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
$LL46@Init:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL46@Init
	sub	eax, edx
	lea	esi, DWORD PTR [eax+1]
	push	esi
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	ecx, eax
	npad	4
$LL14@Init:
	test	esi, esi
	jbe	SHORT $LN12@Init
	mov	dl, BYTE PTR [edi]
	mov	BYTE PTR [ecx], dl
	sub	esi, 1
	add	ecx, 1
	add	edi, 1
	jmp	SHORT $LL14@Init
$LN12@Init:
	mov	DWORD PTR [ebx+8], eax

; 132  : 		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Lobj._Getcvt());

	call	__Getcvt
	mov	edi, OFFSET ??_C@_05LAPONLG@false?$AA@
	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
$LL47@Init:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL47@Init
	sub	eax, edx
	lea	esi, DWORD PTR [eax+1]
	push	esi
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	ecx, eax
	npad	2
$LL23@Init:
	test	esi, esi
	jbe	SHORT $LN21@Init
	mov	dl, BYTE PTR [edi]
	mov	BYTE PTR [ecx], dl
	sub	esi, 1
	add	ecx, 1
	add	edi, 1
	jmp	SHORT $LL23@Init
$LN21@Init:
	mov	DWORD PTR [ebx+16], eax

; 133  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Lobj._Getcvt());

	call	__Getcvt
	mov	edi, OFFSET ??_C@_04LOAJBDKD@true?$AA@
	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
$LL48@Init:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL48@Init
	sub	eax, edx
	lea	esi, DWORD PTR [eax+1]
	push	esi
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	ecx, eax
	npad	2
$LL32@Init:
	test	esi, esi
	jbe	SHORT $LN30@Init
	mov	dl, BYTE PTR [edi]
	mov	BYTE PTR [ecx], dl
	sub	esi, 1
	add	ecx, 1
	add	edi, 1
	jmp	SHORT $LL32@Init
$LN30@Init:
	mov	DWORD PTR [ebx+20], eax

; 137  : 		_CATCH_END
; 138  : 
; 139  : 		_Dp = _MAKLOCCHR(_Elem, _Ptr->decimal_point[0], _Lobj._Getcvt());

	call	__Getcvt
	mov	esi, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [ebx+12], cl

; 140  : 		_Kseparator =
; 141  : 			_MAKLOCCHR(_Elem, _Ptr->thousands_sep[0], _Lobj._Getcvt());

	call	__Getcvt
	mov	edx, DWORD PTR [esi+4]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ebx+13], al

; 142  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z$0:

; 134  : 		_CATCH_ALL
; 135  : 		_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$numpunct@D@std@@AAEXXZ		; std::numpunct<char>::_Tidy

; 136  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN51@Init:
$LN50@Init:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z ENDP	; std::numpunct<char>::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = esi

; 853  : 		{	// initialize from _Locinfo object

	push	ecx

; 854  : 		_Cvt = _Lobj._Getcvt();

	call	__Getcvt
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edx
	pop	ecx

; 855  : 		}

	ret	0
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = eax

; 283  : 		_IGfirst = &_Gfirst, _IPfirst = &_Pfirst;
; 284  : 		_IGnext = &_Gnext, _IPnext = &_Pnext;

	lea	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+32], edx
	lea	edx, DWORD PTR [eax+28]
	mov	DWORD PTR [eax+36], edx
	lea	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+16], ecx

; 285  : 		_IGcount = &_Gcount, _IPcount = &_Pcount;

	lea	edx, DWORD PTR [eax+40]
	mov	DWORD PTR [eax+48], edx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+20], ecx
	lea	edx, DWORD PTR [eax+44]
	mov	DWORD PTR [eax+52], edx

; 286  : 		setp(0, 0), setg(0, 0, 0);

	mov	DWORD PTR [ecx], 0
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx], 0
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR [eax+48]
	mov	DWORD PTR [eax], 0

; 287  : 		}

	ret	0
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$numpunct@D@std@@MAE@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		_Tidy();

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	edx, DWORD PTR [esi+20]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH

; 111  : 		}

	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	pop	esi
	ret	0
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = eax

; 80   : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN8@Sentry_bas

; 81   : 				_Myostr.rdbuf()->_Unlock();

	lea	ecx, DWORD PTR [eax+4]
	jmp	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
$LN8@Sentry_bas:

; 82   : 			}

	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = esi
; __Ostr$ = eax

; 73   : 			{	// lock the stream buffer, if there

	mov	DWORD PTR [esi], eax

; 74   : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN10@Sentry_bas@2

; 75   : 				_Myostr.rdbuf()->_Lock();

	lea	ecx, DWORD PTR [eax+4]
	call	?_Lock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Lock
$LN10@Sentry_bas@2:

; 76   : 			}

	mov	eax, esi
	ret	0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Uoutput_iterator_tag@std@@XXXXU_Iterator_base@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Uoutput_iterator_tag@std@@XXXXU_Iterator_base@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::output_iterator_tag,void,void,void,void,std::_Iterator_base>::_Iterator_with_base<std::output_iterator_tag,void,void,void,void,std::_Iterator_base>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Uoutput_iterator_tag@std@@XXXXU_Iterator_base@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::output_iterator_tag,void,void,void,void,std::_Iterator_base>::_Iterator_with_base<std::output_iterator_tag,void,void,void,void,std::_Iterator_base>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Outit_with_base@U_Iterator_base@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Outit_with_base@U_Iterator_base@std@@@std@@QAE@XZ PROC ; std::_Outit_with_base<std::_Iterator_base>::_Outit_with_base<std::_Iterator_base>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Outit_with_base@U_Iterator_base@std@@@std@@QAE@XZ ENDP ; std::_Outit_with_base<std::_Iterator_base>::_Outit_with_base<std::_Iterator_base>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = eax
; __Sb$ = ecx

; 2176 : 		{	// construct from stream buffer _Sb

	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax+8], ecx

; 2177 : 		}

	ret	0
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 849  : 		}

	mov	DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
	ret	0
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\sstream
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = esi

; 298  : 		if (_Mystate & _Allocated)

	test	BYTE PTR [esi+64], 1
	je	SHORT $LN16@Tidy@2

; 299  : 			_Al.deallocate(_Mysb::eback(),
; 300  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 301  : 					: _Mysb::egptr()) - _Mysb::eback());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN16@Tidy@2:

; 302  : 		_Mysb::setg(0, 0, 0);

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [ecx], 0

; 303  : 		_Mysb::setp(0, 0);

	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx], 0

; 304  : 		_Seekhigh = 0;
; 305  : 		_Mystate &= ~_Allocated;

	and	DWORD PTR [esi+64], -2			; fffffffeH
	mov	DWORD PTR [esi+60], 0

; 306  : 		}

	ret	0
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx
; __Ch$ = edx

; 162  : 		return (0 < _Pnavail()
; 163  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 164  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	eax, DWORD PTR [ecx+36]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@sputc
	mov	eax, DWORD PTR [ecx+52]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN3@sputc
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx]
	push	esi
	lea	esi, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], esi
	mov	BYTE PTR [eax], dl
	movzx	eax, dl
	pop	esi

; 165  : 		}

	ret	0
$LN3@sputc:

; 162  : 		return (0 < _Pnavail()
; 163  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 164  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	movzx	edx, dl
	push	edx
	call	eax

; 165  : 		}

	ret	0
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ios
_TEXT	ENDS
;	COMDAT ??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = eax

; 146  : 	__CLR_OR_THIS_CALL basic_ios()

	mov	DWORD PTR [eax], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@

; 147  : 		{	// default constructor, do nothing
; 148  : 		}

	ret	0
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 203  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@18
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@18
$LN3@operator@18:
	call	__invalid_parameter_noinfo
$LN4@operator@18:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 204  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator!=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\sstream
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Ptr$ = 12						; size = 24
__Mode$ = 36						; size = 4
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos, COMDAT
; _this$ = ecx

; 237  : 		streamoff _Off = (streamoff)_Ptr;

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	edx, DWORD PTR __Ptr$[esp+4]
	push	ebp
	push	edi

; 238  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

	mov	edi, DWORD PTR [ecx+36]
	add	edx, eax
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN12@seekpos
	cmp	DWORD PTR [ecx+60], eax
	jae	SHORT $LN12@seekpos

; 239  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

	mov	DWORD PTR [ecx+60], eax
$LN12@seekpos:

; 240  : 
; 241  : 		if (_Off == _BADOFF)

	mov	ebp, DWORD PTR ?_BADOFF@std@@3JB	; std::_BADOFF
	cmp	edx, ebp
	je	$LN56@seekpos
	push	ebx

; 242  : 			;
; 243  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

	mov	bl, BYTE PTR __Mode$[esp+8]
	test	bl, 1
	push	esi
	je	SHORT $LN55@seekpos
	mov	eax, DWORD PTR [ecx+32]
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN55@seekpos

; 244  : 			{	// position within read buffer
; 245  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	edx, edx
	jl	SHORT $LN4@seekpos
	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR [ecx+60]
	sub	edi, eax
	cmp	edx, edi
	jg	SHORT $LN4@seekpos

; 246  : 				{	// change read position
; 247  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

	sub	eax, esi
	mov	esi, DWORD PTR [ecx+48]
	add	eax, edx
	sub	DWORD PTR [esi], eax
	mov	esi, DWORD PTR [ecx+32]
	add	DWORD PTR [esi], eax

; 248  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

	test	bl, 2
	je	SHORT $LN57@seekpos
	mov	edi, DWORD PTR [ecx+36]
	mov	ebx, DWORD PTR [edi]
	test	ebx, ebx
	je	SHORT $LN57@seekpos

; 249  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 250  : 						_Mysb::epptr());	// change write position to match

	mov	eax, DWORD PTR [ecx+32]
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [eax]
	add	eax, ebx
	mov	DWORD PTR [edi], esi
	mov	ecx, DWORD PTR [ecx+52]
	sub	eax, esi
	mov	DWORD PTR [ecx], eax

; 251  : 				}
; 252  : 			else
; 253  : 				_Off = _BADOFF;

	jmp	SHORT $LN57@seekpos
$LN55@seekpos:

; 254  : 			}
; 255  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)

	test	bl, 2
	je	SHORT $LN4@seekpos
	mov	edi, DWORD PTR [edi]
	test	edi, edi
	je	SHORT $LN4@seekpos

; 256  : 			{	// position within write buffer
; 257  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	edx, edx
	jl	SHORT $LN4@seekpos
	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [ecx+60]
	sub	esi, eax
	cmp	edx, esi
	jg	SHORT $LN4@seekpos

; 258  : 				_Mysb::pbump((int)(_Mysb::eback()
; 259  : 					- _Mysb::pptr() + _Off));	// change write position

	mov	esi, DWORD PTR [ecx+52]
	sub	eax, edi
	add	eax, edx
	sub	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [ecx+36]
	add	DWORD PTR [ecx], eax

; 260  : 			else

	jmp	SHORT $LN57@seekpos
$LN4@seekpos:

; 261  : 				_Off = _BADOFF;
; 262  : 			}
; 263  : 		else
; 264  : 			_Off = _BADOFF;

	mov	edx, ebp
$LN57@seekpos:
	pop	esi
	pop	ebx
$LN56@seekpos:

; 265  : 		return (streampos(_Off));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	xor	ecx, ecx
	pop	edi
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	pop	ebp

; 266  : 		}

	ret	32					; 00000020H
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Way$ = 16						; size = 4
__Which$ = 20						; size = 4
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@JHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff, COMDAT
; _this$ = ecx

; 191  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN20@seekoff
	cmp	DWORD PTR [ecx+60], eax
	jae	SHORT $LN20@seekoff

; 192  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

	mov	DWORD PTR [ecx+60], eax
$LN20@seekoff:
	push	ebx

; 193  : 
; 194  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

	mov	bl, BYTE PTR __Which$[esp]
	test	bl, 1
	push	esi
	push	edi
	je	$LN19@seekoff
	mov	eax, DWORD PTR [ecx+32]
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	$LN19@seekoff

; 195  : 			{	// position within read buffer
; 196  : 			if (_Way == ios_base::end)

	mov	eax, DWORD PTR __Way$[esp+8]
	cmp	eax, 2
	mov	edi, DWORD PTR ?_BADOFF@std@@3JB	; std::_BADOFF
	jne	SHORT $LN18@seekoff

; 197  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [ecx+60]
	sub	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR __Off$[esp+8]
	add	edx, eax

; 198  : 			else if (_Way == ios_base::cur

	jmp	SHORT $LN14@seekoff
$LN18@seekoff:

; 199  : 				&& (_Which & ios_base::out) == 0)

	cmp	eax, 1
	jne	SHORT $LN16@seekoff
	test	bl, 2
	jne	SHORT $LN73@seekoff

; 200  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, esi
	sub	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR __Off$[esp+8]
	add	edx, eax
	jmp	SHORT $LN14@seekoff
$LN16@seekoff:

; 201  : 			else if (_Way != ios_base::beg)

	test	eax, eax
	je	SHORT $LN74@seekoff
$LN73@seekoff:

; 202  : 				_Off = _BADOFF;

	mov	edx, edi
	jmp	SHORT $LN14@seekoff
$LN74@seekoff:
	mov	edx, DWORD PTR __Off$[esp+8]
$LN14@seekoff:

; 203  : 
; 204  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	edx, edx
	jl	$LN3@seekoff
	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	push	ebp
	mov	ebp, DWORD PTR [ecx+60]
	sub	ebp, eax
	cmp	edx, ebp
	pop	ebp
	jg	$LN3@seekoff

; 205  : 				{	// change read position
; 206  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

	sub	eax, esi
	mov	esi, DWORD PTR [ecx+48]
	add	eax, edx
	sub	DWORD PTR [esi], eax
	mov	esi, DWORD PTR [ecx+32]
	add	DWORD PTR [esi], eax

; 207  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

	test	bl, 2
	je	$LN77@seekoff
	mov	edi, DWORD PTR [ecx+36]
	mov	ebx, DWORD PTR [edi]
	test	ebx, ebx
	je	$LN77@seekoff

; 208  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 209  : 						_Mysb::epptr());	// change write position to match

	mov	eax, DWORD PTR [ecx+32]
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [eax]
	add	eax, ebx
	mov	DWORD PTR [edi], esi
	mov	ecx, DWORD PTR [ecx+52]
	sub	eax, esi
	mov	DWORD PTR [ecx], eax

; 210  : 				}
; 211  : 			else

	jmp	SHORT $LN77@seekoff
$LN19@seekoff:

; 212  : 				_Off = _BADOFF;
; 213  : 			}
; 214  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)

	test	bl, 2
	je	SHORT $LN9@seekoff
	mov	esi, DWORD PTR [edx]
	test	esi, esi
	je	SHORT $LN9@seekoff

; 215  : 			{	// position within write buffer
; 216  : 			if (_Way == ios_base::end)

	mov	eax, DWORD PTR __Way$[esp+8]
	cmp	eax, 2
	mov	edi, DWORD PTR ?_BADOFF@std@@3JB	; std::_BADOFF
	jne	SHORT $LN8@seekoff

; 217  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [ecx+60]
	sub	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR __Off$[esp+8]
	add	edx, eax
	jmp	SHORT $LN4@seekoff
$LN8@seekoff:

; 218  : 			else if (_Way == ios_base::cur)

	cmp	eax, 1
	jne	SHORT $LN6@seekoff

; 219  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, esi
	sub	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR __Off$[esp+8]
	add	edx, eax
	jmp	SHORT $LN4@seekoff
$LN6@seekoff:

; 220  : 			else if (_Way != ios_base::beg)

	test	eax, eax

; 221  : 				_Off = _BADOFF;

	mov	edx, edi
	jne	SHORT $LN4@seekoff
	mov	edx, DWORD PTR __Off$[esp+8]
$LN4@seekoff:

; 222  : 
; 223  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	edx, edx
	jl	SHORT $LN3@seekoff
	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	mov	ebx, DWORD PTR [ecx+60]
	sub	ebx, eax
	cmp	edx, ebx
	jg	SHORT $LN3@seekoff

; 224  : 				_Mysb::pbump((int)(_Mysb::eback()
; 225  : 					- _Mysb::pptr() + _Off));	// change write position

	sub	eax, esi
	mov	esi, DWORD PTR [ecx+52]
	add	eax, edx
	sub	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [ecx+36]
	add	DWORD PTR [ecx], eax

; 226  : 			else

	jmp	SHORT $LN77@seekoff
$LN3@seekoff:

; 227  : 				_Off = _BADOFF;

	mov	edx, edi

; 228  : 			}
; 229  : 		else

	jmp	SHORT $LN77@seekoff
$LN9@seekoff:

; 230  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

	mov	edx, DWORD PTR ?_BADOFF@std@@3JB	; std::_BADOFF
$LN77@seekoff:

; 231  : 		return (pos_type(_Off));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	xor	ecx, ecx
	pop	esi
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	pop	ebx

; 232  : 		}

	ret	16					; 00000010H
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@JHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow, COMDAT
; _this$ = ecx

; 171  : 		if (_Mysb::gptr() == 0)

	mov	edx, DWORD PTR [ecx+32]
	push	esi
	mov	esi, DWORD PTR [edx]
	test	esi, esi
	jne	SHORT $LN8@underflow

; 172  : 			return (_Traits::eof());	// no character buffer, fail

	or	eax, -1
	pop	esi

; 184  : 			}
; 185  : 		}

	ret	0
$LN8@underflow:
	push	ebx
	push	edi

; 173  : 		else if (_Mysb::gptr() < _Mysb::egptr())

	mov	edi, DWORD PTR [ecx+48]
	mov	ebx, DWORD PTR [edi]
	mov	eax, esi
	add	ebx, eax
	cmp	eax, ebx
	jae	SHORT $LN6@underflow

; 174  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered

	movzx	eax, BYTE PTR [esi]
	pop	edi
	pop	ebx
	pop	esi

; 184  : 			}
; 185  : 		}

	ret	0
$LN6@underflow:

; 175  : 		else if (_Mystate & _Noread || _Mysb::pptr() == 0
; 176  : 			|| _Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr())

	test	BYTE PTR [ecx+64], 4
	jne	SHORT $LN3@underflow
	mov	eax, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN3@underflow
	cmp	eax, esi
	ja	SHORT $LN4@underflow
	cmp	DWORD PTR [ecx+60], esi
	jbe	SHORT $LN3@underflow
$LN4@underflow:

; 178  : 		else
; 179  : 			{	// extend read buffer into written area, then return buffered
; 180  : 			if (_Seekhigh < _Mysb::pptr())

	cmp	DWORD PTR [ecx+60], eax
	jae	SHORT $LN1@underflow

; 181  : 				_Seekhigh = _Mysb::pptr();

	mov	DWORD PTR [ecx+60], eax
$LN1@underflow:

; 182  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);

	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx+60]
	sub	eax, edx
	mov	DWORD PTR [edi], eax

; 183  : 			return (_Traits::to_int_type(*_Mysb::gptr()));

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	pop	edi
	pop	ebx
	pop	esi

; 184  : 			}
; 185  : 		}

	ret	0
$LN3@underflow:
	pop	edi
	pop	ebx

; 177  : 			return (_Traits::eof());	// can't read, fail

	or	eax, -1
	pop	esi

; 184  : 			}
; 185  : 		}

	ret	0
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 752  : 
; 753  :  #if _HAS_ITERATOR_DEBUGGING
; 754  : 		if (size() <= _Pos)
; 755  : 			{
; 756  : 			_DEBUG_ERROR("vector subscript out of range");
; 757  : 			_SCL_SECURE_OUT_OF_RANGE;
; 758  : 			}
; 759  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 760  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN8@operator@19
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN1@operator@19
$LN8@operator@19:
	call	__invalid_parameter_noinfo
$LN1@operator@19:

; 761  : 
; 762  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	lea	eax, DWORD PTR [ecx+eax*4]

; 763  : 		}

	ret	0
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty, COMDAT
; _this$ = ecx

; 713  : 		return (size() == 0);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN5@empty
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	mov	al, cl

; 714  : 		}

	ret	0

; 713  : 		return (size() == 0);

$LN5@empty:
	mov	ecx, DWORD PTR [ecx+8]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	mov	al, cl

; 714  : 		}

	ret	0
?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 318  : 		{	// get a character from stream, point past it

	push	esi
	mov	esi, ecx

; 319  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())
; 320  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	cmp	eax, -1
	jne	SHORT $LN3@uflow
	or	eax, eax
	pop	esi

; 321  : 		}

	ret	0
$LN3@uflow:

; 319  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())
; 320  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));

	mov	eax, DWORD PTR [esi+48]
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], edx
	movzx	eax, BYTE PTR [ecx]
	pop	esi

; 321  : 		}

	ret	0
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::uflow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 314  : 		return (_Traits::eof());

	or	eax, -1

; 315  : 		}

	ret	0
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::underflow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 304  : 		return (_Traits::eof());

	or	eax, -1

; 305  : 		}

	ret	4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 299  : 		return (_Traits::eof());

	or	eax, -1

; 300  : 		}

	ret	4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::overflow
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ios
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 39   : 		}

	push	ecx
	mov	DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	pop	ecx
	ret	0
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledWriter::hasCommentForValue
; Function compile flags: /Ogtpy
; File f:\cygwin\home\charles\gusale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z PROC ; Json::StyledWriter::hasCommentForValue, COMDAT
; _value$ = eax

; 511  :    return value.hasComment( commentBefore )
; 512  :           ||  value.hasComment( commentAfterOnSameLine )
; 513  :           ||  value.hasComment( commentAfter );

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN15@hasComment@2
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@hasComment@2
	test	eax, eax
	je	SHORT $LN15@hasComment@2
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN3@hasComment@2
	test	eax, eax
	je	SHORT $LN15@hasComment@2
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN3@hasComment@2
$LN15@hasComment@2:
	xor	eax, eax

; 514  : }

	ret	0
$LN3@hasComment@2:

; 511  :    return value.hasComment( commentBefore )
; 512  :           ||  value.hasComment( commentAfterOnSameLine )
; 513  :           ||  value.hasComment( commentAfter );

	mov	eax, 1

; 514  : }

	ret	0
?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledWriter::hasCommentForValue
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GWriter@Json@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GWriter@Json@@UAEPAXI@Z PROC				; Json::Writer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7Writer@Json@@6B@
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GWriter@Json@@UAEPAXI@Z ENDP				; Json::Writer::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?containsControlCharacter@Json@@YA_NPBD@Z
_TEXT	SEGMENT
?containsControlCharacter@Json@@YA_NPBD@Z PROC		; Json::containsControlCharacter, COMDAT
; _str$ = ecx

; 23   :    while ( *str ) 

	movzx	eax, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN2@containsCo
$LL3@containsCo:

; 24   :    {
; 25   :       if ( isControlCharacter( *(str++) ) )

	sub	al, 1
	mov	dl, 30					; 0000001eH
	cmp	dl, al
	sbb	eax, eax
	add	eax, 1
	add	ecx, 1
	test	al, al
	jne	SHORT $LN11@containsCo
	mov	al, BYTE PTR [ecx]
	test	al, al
	jne	SHORT $LL3@containsCo
$LN2@containsCo:

; 27   :    }
; 28   :    return false;

	xor	al, al

; 29   : }

	ret	0
$LN11@containsCo:

; 26   :          return true;

	mov	al, 1

; 29   : }

	ret	0
?containsControlCharacter@Json@@YA_NPBD@Z ENDP		; Json::containsControlCharacter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ios
_TEXT	ENDS
;	COMDAT ?uppercase@std@@YAAAVios_base@1@AAV21@@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
?uppercase@std@@YAAAVios_base@1@AAV21@@Z PROC		; std::uppercase, COMDAT

; 299  : 	_Iosbase.setf(ios_base::uppercase);

	mov	eax, DWORD PTR __Iosbase$[esp-4]
	or	DWORD PTR [eax+16], 4

; 300  : 	return (_Iosbase);
; 301  : 	}

	ret	0
?uppercase@std@@YAAAVios_base@1@AAV21@@Z ENDP		; std::uppercase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?hex@std@@YAAAVios_base@1@AAV21@@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
?hex@std@@YAAAVios_base@1@AAV21@@Z PROC			; std::hex, COMDAT

; 191  : 	_Iosbase.setf(ios_base::hex, ios_base::basefield);

	mov	eax, DWORD PTR __Iosbase$[esp-4]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -1537				; fffff9ffH
	or	ecx, 2048				; 00000800H
	mov	DWORD PTR [eax+16], ecx

; 192  : 	return (_Iosbase);
; 193  : 	}

	ret	0
?hex@std@@YAAAVios_base@1@AAV21@@Z ENDP			; std::hex
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gios_base@std@@UAEPAXI@Z PROC			; std::ios_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	esi
	mov	DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Gios_base@std@@UAEPAXI@Z ENDP			; std::ios_base::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ??0locale@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$31152 = -4					; size = 4
??0locale@std@@QAE@XZ PROC				; std::locale::locale, COMDAT
; _this$ = edi

; 308  : 		{	// construct from current locale

	push	ecx
	push	esi
	call	?_Init@locale@std@@CAPAV_Locimp@12@XZ	; std::locale::_Init
	mov	DWORD PTR [edi], eax

; 309  : 		_Getgloballocale()->_Incref();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	push	0
	lea	ecx, DWORD PTR __Lock$31152[esp+12]
	mov	esi, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN3@locale
	add	eax, 1
	mov	DWORD PTR [esi+4], eax
$LN3@locale:
	lea	ecx, DWORD PTR __Lock$31152[esp+8]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 310  : 		}

	mov	eax, edi
	pop	esi
	pop	ecx
	ret	0
??0locale@std@@QAE@XZ ENDP				; std::locale::locale
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT
?not_eof@?$char_traits@D@std@@SAHABH@Z PROC		; std::char_traits<char>::not_eof, COMDAT

; 515  : 		return (_Meta != eof() ? _Meta : !eof());

	xor	eax, eax

; 516  : 		}

	ret	0
?not_eof@?$char_traits@D@std@@SAHABH@Z ENDP		; std::char_traits<char>::not_eof
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=, COMDAT
; _this$ = esi
; __Right$ = edx

; 2186 : 		if (_Strbuf == 0
; 2187 : 			|| traits_type::eq_int_type(_Traits::eof(),
; 2188 : 				_Strbuf->sputc(_Right)))

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN1@operator@22
	mov	eax, DWORD PTR [ecx+36]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@operator@22
	mov	eax, DWORD PTR [ecx+52]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN7@operator@22
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx]
	push	edi
	lea	edi, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edi
	mov	BYTE PTR [eax], dl
	movzx	eax, dl
	pop	edi
	jmp	SHORT $LN8@operator@22
$LN7@operator@22:
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	movzx	edx, dl
	push	edx
	call	eax
$LN8@operator@22:
	cmp	eax, -1
	jne	SHORT $LN23@operator@22
$LN1@operator@22:

; 2189 : 			_Failed = true;

	mov	BYTE PTR [esi+4], 1
$LN23@operator@22:

; 2190 : 		return (*this);

	mov	eax, esi

; 2191 : 		}

	ret	0
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Ptr$ = 24						; size = 4
?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc, COMDAT
; __Count$ = eax

; 1322 : 		{	// put char sequence [_Ptr, _Ptr + _Count) to _Dest

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Ptr$[esp+4]
	push	esi

; 1323 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	mov	esi, DWORD PTR __Dest$[esp+16]
	push	edi
	mov	edi, eax
	test	edi, edi
	jbe	SHORT $LN1@Putc
$LL3@Putc:

; 1324 : 			*_Dest = _MAKLOCCHR(_Elem, *_Ptr, _Cvt);

	test	esi, esi
	je	SHORT $LN12@Putc
	mov	eax, DWORD PTR [esi+36]
	cmp	DWORD PTR [eax], 0
	mov	dl, BYTE PTR [ebp]
	je	SHORT $LN18@Putc
	mov	ecx, DWORD PTR [esi+52]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN18@Putc
	mov	eax, ecx
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax]
	lea	ebx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	BYTE PTR [ecx], dl
	movzx	eax, dl
	jmp	SHORT $LN19@Putc
$LN18@Putc:
	mov	eax, DWORD PTR [esi]
	movzx	ecx, dl
	mov	edx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	edx
$LN19@Putc:
	cmp	eax, -1
	jne	SHORT $LN2@Putc
$LN12@Putc:
	mov	BYTE PTR __Dest$[esp+16], 1
$LN2@Putc:

; 1323 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	sub	edi, 1
	add	ebp, 1
	test	edi, edi
	ja	SHORT $LL3@Putc
$LN1@Putc:

; 1325 : 		return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+12]
	mov	ecx, DWORD PTR __Dest$[esp+16]
	mov	DWORD PTR [ebx], eax
	pop	edi
	mov	DWORD PTR [ebx+4], ecx
	mov	DWORD PTR [ebx+8], esi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx

; 1326 : 		}

	ret	0
?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	edx, DWORD PTR [esi+20]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH
	test	BYTE PTR ___flags$[esp], 1
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN10@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@6:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT
; __Ch$ = ebx
; __Count$ = eax

; 1349 : 		{	// put _Count * _Ch to _Dest

	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1350 : 		for (; 0 < _Count; --_Count, ++_Dest)

	mov	esi, DWORD PTR __Dest$[esp+12]
	push	edi
	mov	edi, eax
	test	edi, edi
	jbe	SHORT $LN1@Rep
$LL35@Rep:

; 1351 : 			*_Dest = _Ch;

	test	esi, esi
	je	SHORT $LN10@Rep
	mov	eax, DWORD PTR [esi+36]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@Rep
	mov	ecx, DWORD PTR [esi+52]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN16@Rep
	mov	eax, ecx
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], edx
	mov	BYTE PTR [ecx], bl
	movzx	eax, bl
	jmp	SHORT $LN17@Rep
$LN16@Rep:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+4]
	movzx	ecx, bl
	push	ecx
	mov	ecx, esi
	call	edx
$LN17@Rep:
	cmp	eax, -1
	jne	SHORT $LN2@Rep
$LN10@Rep:
	mov	BYTE PTR __Dest$[esp+12], 1
$LN2@Rep:

; 1350 : 		for (; 0 < _Count; --_Count, ++_Dest)

	sub	edi, 1
	jne	SHORT $LL35@Rep
$LN1@Rep:

; 1352 : 		return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+8]
	mov	ecx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebp], eax
	mov	DWORD PTR [ebp+4], ecx
	pop	edi
	mov	DWORD PTR [ebp+8], esi
	pop	esi
	mov	eax, ebp
	pop	ebp

; 1353 : 		}

	ret	0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Ptr$ = 24						; size = 4
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT
; __Count$ = eax

; 1314 : 		{	// put [_Ptr, _Ptr + _Count) to _Dest

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Ptr$[esp+4]
	push	esi

; 1315 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	mov	esi, DWORD PTR __Dest$[esp+16]
	push	edi
	mov	edi, eax
	test	edi, edi
	jbe	SHORT $LN1@Put
$LL3@Put:

; 1316 : 			*_Dest = *_Ptr;

	test	esi, esi
	je	SHORT $LN10@Put
	mov	eax, DWORD PTR [esi+36]
	cmp	DWORD PTR [eax], 0
	mov	dl, BYTE PTR [ebp]
	je	SHORT $LN16@Put
	mov	ecx, DWORD PTR [esi+52]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN16@Put
	mov	eax, ecx
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax]
	lea	ebx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	BYTE PTR [ecx], dl
	movzx	eax, dl
	jmp	SHORT $LN17@Put
$LN16@Put:
	mov	eax, DWORD PTR [esi]
	movzx	ecx, dl
	mov	edx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	edx
$LN17@Put:
	cmp	eax, -1
	jne	SHORT $LN2@Put
$LN10@Put:
	mov	BYTE PTR __Dest$[esp+16], 1
$LN2@Put:

; 1315 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	sub	edi, 1
	add	ebp, 1
	test	edi, edi
	ja	SHORT $LL3@Put
$LN1@Put:

; 1317 : 		return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+12]
	mov	ecx, DWORD PTR __Dest$[esp+16]
	mov	DWORD PTR [ebx], eax
	pop	edi
	mov	DWORD PTR [ebx+4], ecx
	mov	DWORD PTR [ebx+8], esi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx

; 1318 : 		}

	ret	0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\sstream
_TEXT	ENDS
;	COMDAT ?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z
_TEXT	SEGMENT
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init, COMDAT
; _this$ = esi
; __Count$ = ebx

; 271  : 		_Seekhigh = 0;
; 272  : 		_Mystate = _State;
; 273  : 
; 274  : 		if (_Count != 0
; 275  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))

	mov	eax, DWORD PTR [esi+64]
	and	eax, 6
	cmp	al, 6
	je	SHORT $LN9@Init@2
	push	edi

; 276  : 			{	// finite buffer that can be read or written, set it up
; 277  : 			_Elem *_Pnew = _Al.allocate(_Count);

	push	ebx
	lea	ecx, DWORD PTR [esi+68]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 278  : 			_Traits_helper::copy_s<_Traits>(_Pnew, _Count, _Ptr, _Count);

	push	ebx
	push	0
	mov	edi, eax
	push	ebx
	push	edi
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 279  : 			_Seekhigh = _Pnew + _Count;
; 280  : 
; 281  : 			if (!(_Mystate & _Noread))

	test	BYTE PTR [esi+64], 4
	lea	eax, DWORD PTR [edi+ebx]
	mov	DWORD PTR [esi+60], eax
	jne	SHORT $LN21@Init@2

; 282  : 				_Mysb::setg(_Pnew, _Pnew,
; 283  : 					_Pnew + _Count);	// setup read buffer

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx], edi
	mov	edx, DWORD PTR [esi+32]
	mov	DWORD PTR [edx], edi
	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [ecx], ebx
$LN21@Init@2:

; 284  : 			if (!(_Mystate & _Constant))

	mov	ecx, DWORD PTR [esi+64]
	test	cl, 2
	jne	SHORT $LN27@Init@2

; 285  : 				{	// setup write buffer, and maybe read buffer
; 286  : 				_Mysb::setp(_Pnew,
; 287  : 					(_Mystate & _Atend) ? _Pnew + _Count : _Pnew,
; 288  : 					_Pnew + _Count);

	test	cl, 16					; 00000010H
	jne	SHORT $LN8@Init@2
	mov	eax, edi
$LN8@Init@2:
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [edx], edi
	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR [ecx], eax
	mov	edx, edi
	sub	edx, eax
	mov	eax, DWORD PTR [esi+52]
	add	edx, ebx
	mov	DWORD PTR [eax], edx

; 289  : 				if (_Mysb::gptr() == 0)

	mov	ecx, DWORD PTR [esi+32]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN27@Init@2

; 290  : 					_Mysb::setg(_Pnew, 0, _Pnew);

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx], edi
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [ecx], edi
$LN27@Init@2:

; 291  : 				}
; 292  : 			_Mystate |= _Allocated;

	or	DWORD PTR [esi+64], 1
	pop	edi
$LN9@Init@2:

; 293  : 			}
; 294  : 		}

	ret	0
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ$0
__ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
__Lock$32602 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >, COMDAT

; 29   : 		{	// construct with no buffers

	push	-1
	push	__ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+28]
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
	call	??0_Mutex@std@@QAE@XZ			; std::_Mutex::_Mutex
	push	4
	mov	DWORD PTR __$EHRec$[esp+44], 0
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN3@basic_stre
	call	?_Init@locale@std@@CAPAV_Locimp@12@XZ	; std::locale::_Init
	mov	DWORD PTR [edi], eax
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	push	0
	lea	ecx, DWORD PTR __Lock$32602[esp+36]
	mov	ebx, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, -1
	jae	SHORT $LN8@basic_stre
	add	eax, 1
	mov	DWORD PTR [ebx+4], eax
$LN8@basic_stre:
	lea	ecx, DWORD PTR __Lock$32602[esp+32]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	jmp	SHORT $LN4@basic_stre
$LN3@basic_stre:
	xor	edi, edi
$LN4@basic_stre:

; 30   : 		_Init();

	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+16], eax
	lea	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+32], ecx
	lea	edx, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+36], edx
	mov	DWORD PTR [esi+56], edi
	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+20], eax
	lea	ecx, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+48], ecx
	lea	edx, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+52], edx
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [ecx], 0

; 31   : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 4
	jmp	??1_Mutex@std@@QAE@XZ			; std::_Mutex::~_Mutex
__ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN8@scalar@7
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@7:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	add	eax, 4
	mov	DWORD PTR [edx+eax-4], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
	push	eax
	mov	DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	pop	ecx
	ret	0
??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT
__Lock$32677 = -4					; size = 4
___flags$ = 8						; size = 4
??_Glocale@std@@QAEPAXI@Z PROC				; std::locale::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ecx
	push	ebx
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	SHORT $LN7@scalar@8
	push	0
	lea	ecx, DWORD PTR __Lock$32677[esp+16]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN9@scalar@8
	cmp	eax, -1
	jae	SHORT $LN9@scalar@8
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN9@scalar@8:
	push	esi
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$32677[esp+16]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN13@scalar@8
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN13@scalar@8:
	pop	esi
$LN7@scalar@8:
	test	BYTE PTR ___flags$[esp+8], 1
	je	SHORT $LN12@scalar@8
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN12@scalar@8:
	pop	edi
	mov	eax, ebx
	pop	ebx
	pop	ecx
	ret	4
??_Glocale@std@@QAEPAXI@Z ENDP				; std::locale::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	esi
	mov	DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN9@scalar@9
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@scalar@9:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	lea	esi, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+eax-4], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
	push	eax
	mov	DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN13@scalar@10
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@10:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\sstream
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail, COMDAT
; _this$ = ecx

; 154  : 		if (_Mysb::gptr() == 0
; 155  : 			|| _Mysb::gptr() <= _Mysb::eback()
; 156  : 			|| !_Traits::eq_int_type(_Traits::eof(), _Meta)
; 157  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 158  : 			&& _Mystate & _Constant)

	mov	eax, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN3@pbackfail
	mov	edx, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [edx]
	jbe	SHORT $LN3@pbackfail
	mov	edx, DWORD PTR __Meta$[esp-4]
	cmp	edx, -1
	je	SHORT $LN4@pbackfail
	cmp	dl, BYTE PTR [eax-1]
	je	SHORT $LN4@pbackfail
	test	BYTE PTR [ecx+64], 2
	jne	SHORT $LN3@pbackfail
$LN4@pbackfail:

; 160  : 		else
; 161  : 			{	// back up one position and store put-back character
; 162  : 			_Mysb::gbump(-1);

	mov	eax, DWORD PTR [ecx+48]
	add	DWORD PTR [eax], 1
	mov	eax, DWORD PTR [ecx+32]
	add	DWORD PTR [eax], -1

; 163  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

	cmp	edx, -1
	je	SHORT $LN37@pbackfail

; 164  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);

	mov	eax, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx], dl

; 165  : 			return (_Traits::not_eof(_Meta));

	mov	eax, edx

; 166  : 			}
; 167  : 		}

	ret	4

; 165  : 			return (_Traits::not_eof(_Meta));

$LN37@pbackfail:
	xor	eax, eax

; 166  : 			}
; 167  : 		}

	ret	4
$LN3@pbackfail:

; 159  : 			return (_Traits::eof());	// can't put back, fail

	or	eax, -1

; 166  : 			}
; 167  : 		}

	ret	4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow, COMDAT
; _this$ = ecx

; 87   : 		{	// put an element to stream

	push	ebx
	push	esi
	mov	esi, ecx

; 88   : 		if (_Mystate & _Append
; 89   : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

	test	BYTE PTR [esi+64], 8
	push	edi
	je	SHORT $LN113@overflow
	mov	edi, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [edi]
	test	edx, edx
	je	SHORT $LN113@overflow
	mov	ecx, DWORD PTR [esi+60]
	cmp	edx, ecx
	jae	SHORT $LN113@overflow

; 90   : 			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());

	mov	eax, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [eax]
	add	eax, edx
	mov	DWORD PTR [edi], ecx
	sub	eax, ecx
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx], eax
$LN113@overflow:

; 91   : 
; 92   : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	mov	ebx, DWORD PTR __Meta$[esp+8]
	cmp	ebx, -1
	jne	SHORT $LN17@overflow
	pop	edi
	pop	esi

; 93   : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

	xor	eax, eax
	pop	ebx

; 149  : 			}
; 150  : 		}

	ret	4
$LN17@overflow:

; 94   : 		else if (_Mysb::pptr() != 0
; 95   : 			&& _Mysb::pptr() < _Mysb::epptr())

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN15@overflow
	mov	eax, DWORD PTR [esi+52]
	mov	edi, DWORD PTR [eax]
	mov	ecx, edx
	add	edi, ecx
	cmp	ecx, edi
	jae	SHORT $LN15@overflow

; 96   : 			{	// room in buffer, store it
; 97   : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	add	DWORD PTR [eax], -1
	mov	esi, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [esi]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi], edx
	mov	BYTE PTR [eax], bl
	pop	esi

; 98   : 			return (_Meta);

	mov	eax, ebx
	pop	ebx

; 149  : 			}
; 150  : 		}

	ret	4
$LN15@overflow:

; 99   : 			}
; 100  : 		else if (_Mystate & _Constant)

	test	BYTE PTR [esi+64], 2
	je	SHORT $LN13@overflow
	pop	edi
	pop	esi

; 101  : 			return (_Traits::eof());	// array nonmutable, fail

	or	eax, -1
	pop	ebx

; 149  : 			}
; 150  : 		}

	ret	4
$LN13@overflow:

; 102  : 		else
; 103  : 			{	// grow buffer and store element
; 104  : 			size_t _Oldsize = _Mysb::pptr() == 0
; 105  : 				? 0 : _Mysb::epptr() - _Mysb::eback();

	test	edx, edx
	push	ebp
	jne	SHORT $LN21@overflow
	xor	ebp, ebp
	jmp	SHORT $LN22@overflow
$LN21@overflow:
	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [esi+16]
	mov	ebp, DWORD PTR [eax]
	sub	ebp, DWORD PTR [ecx]
	add	ebp, edx
$LN22@overflow:

; 106  : 			size_t _Newsize = _Oldsize;
; 107  : 			size_t _Inc = _Newsize / 2 < _MINSIZE
; 108  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent

	mov	eax, ebp
	shr	eax, 1
	cmp	eax, 32					; 00000020H
	mov	ebx, ebp
	jae	SHORT $LN23@overflow
	mov	eax, 32					; 00000020H
$LN23@overflow:

; 109  : 			_Elem *_Ptr = 0;

	xor	edi, edi

; 110  : 
; 111  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

	test	eax, eax
	jbe	SHORT $LN9@overflow
$LL11@overflow:
	mov	edx, 2147483647				; 7fffffffH
	sub	edx, eax
	cmp	edx, ebp
	jae	SHORT $LN10@overflow

; 112  : 				_Inc /= 2;	// increment causes overflow, halve it

	shr	eax, 1

; 110  : 
; 111  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

	jne	SHORT $LL11@overflow

; 113  : 			if (0 < _Inc)

	jmp	SHORT $LN9@overflow
$LN10@overflow:
	test	eax, eax
	jbe	SHORT $LN9@overflow

; 114  : 				{	// finite increment, allocate new character array
; 115  : 				_Newsize += _Inc;

	lea	ebx, DWORD PTR [eax+ebp]

; 116  : 				_Ptr = _Al.allocate(_Newsize);

	push	ebx
	lea	ecx, DWORD PTR [esi+68]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	edi, eax
$LN9@overflow:

; 117  : 				}
; 118  : 
; 119  : 			if (0 < _Oldsize)

	test	ebp, ebp
	jbe	SHORT $LN73@overflow

; 120  : 				_Traits_helper::copy_s<_Traits>(_Ptr, _Newsize, _Mysb::eback(), _Oldsize);

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	push	ebp
	push	ecx
	push	ebx
	push	edi
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN73@overflow:

; 121  : 			if (_Mystate & _Allocated)

	test	BYTE PTR [esi+64], 1
	je	SHORT $LN77@overflow

; 122  : 				_Al.deallocate(_Mysb::eback(), _Oldsize);

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN77@overflow:

; 123  : 			_Mystate |= _Allocated;

	or	DWORD PTR [esi+64], 1

; 124  : 
; 125  : 			if (_Oldsize == 0)

	test	ebp, ebp
	jne	SHORT $LN6@overflow

; 126  : 				{	// first growth, set up pointers
; 127  : 				_Seekhigh = _Ptr;
; 128  : 				_Mysb::setp(_Ptr, _Ptr + _Newsize);

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [ecx], edi
	mov	edx, DWORD PTR [esi+36]
	mov	DWORD PTR [edx], edi
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax], ebx

; 129  : 				if (_Mystate & _Noread)
; 130  : 					_Mysb::setg(_Ptr, 0, _Ptr);

	mov	ecx, DWORD PTR [esi+16]
	test	BYTE PTR [esi+64], 4
	mov	DWORD PTR [ecx], edi
	mov	edx, DWORD PTR [esi+32]

; 131  : 				else

	jne	SHORT $LN114@overflow

; 132  : 					_Mysb::setg(_Ptr, _Ptr, _Ptr + 1);

	mov	DWORD PTR [edx], edi
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax], 1

; 133  : 				}
; 134  : 			else

	jmp	SHORT $LN105@overflow
$LN6@overflow:

; 135  : 				{	// not first growth, adjust pointers
; 136  : 				_Seekhigh = _Seekhigh - _Mysb::eback() + _Ptr;

	mov	eax, DWORD PTR [esi+16]

; 137  : 				_Mysb::setp(_Mysb::pbase() - _Mysb::eback() + _Ptr,
; 138  : 					_Mysb::pptr() - _Mysb::eback() + _Ptr, _Ptr + _Newsize);

	mov	edx, DWORD PTR [esi+36]
	mov	ecx, edi
	sub	ecx, DWORD PTR [eax]
	mov	ebp, edi
	add	DWORD PTR [esi+60], ecx
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [esi+20]
	sub	eax, ecx
	sub	ebp, ecx
	add	DWORD PTR [edx], ebp
	mov	ecx, DWORD PTR [esi+36]
	add	eax, edi
	mov	edx, edi
	sub	edx, eax
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [esi+52]
	add	edx, ebx
	mov	DWORD PTR [eax], edx

; 139  : 				if (_Mystate & _Noread)

	test	BYTE PTR [esi+64], 4
	je	SHORT $LN2@overflow

; 140  : 					_Mysb::setg(_Ptr, 0, _Ptr);

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx], edi
	mov	edx, DWORD PTR [esi+32]
$LN114@overflow:
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax], edi

; 141  : 				else

	jmp	SHORT $LN105@overflow
$LN2@overflow:

; 142  : 					_Mysb::setg(_Ptr,
; 143  : 						_Mysb::gptr() - _Mysb::eback() + _Ptr,
; 144  : 						_Mysb::pptr() + 1);

	mov	eax, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [ecx]
	add	eax, edi
	mov	DWORD PTR [edx], edi
	mov	edx, DWORD PTR [esi+32]
	sub	ecx, eax
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [esi+48]
	add	ecx, 1
	mov	DWORD PTR [eax], ecx
$LN105@overflow:

; 145  : 				}
; 146  : 
; 147  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	eax, DWORD PTR [esi+52]
	add	DWORD PTR [eax], -1
	mov	esi, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+1]
	pop	ebp
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR __Meta$[esp+8]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax], cl

; 148  : 			return (_Meta);

	mov	eax, ecx
	pop	ebx

; 149  : 			}
; 150  : 		}

	ret	4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
_TEXT	SEGMENT
__Copied$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn, COMDAT
; _this$ = ecx

; 363  : 		{	// put _Count characters to stream

	push	ecx
	push	ebp

; 364  : 		streamsize _Stream_size, _Size, _Copied;
; 365  : 
; 366  : 		for (_Copied = 0; 0 < _Count; )

	mov	ebp, DWORD PTR __Count$[esp+4]
	push	esi
	xor	esi, esi
	test	ebp, ebp
	push	edi
	mov	edi, ecx
	mov	DWORD PTR __Copied$[esp+16], esi
	jle	SHORT $LN31@xsputn
	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp+16]
	npad	7
$LL7@xsputn:

; 367  : 			if (0 < (_Stream_size = _Pnavail()))

	mov	eax, edi
	call	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
	test	eax, eax
	jle	SHORT $LN5@xsputn

; 368  : 				{	// copy to write buffer
; 369  : 				_Size = _Stream_size;
; 370  : 				if (_Count < _Size)

	cmp	ebp, eax
	mov	esi, eax
	jge	SHORT $LN4@xsputn

; 371  : 					_Size = _Count;

	mov	esi, ebp
$LN4@xsputn:

; 372  : 				_Traits_helper::copy_s<_Traits>(pptr(), _Stream_size, _Ptr, _Size);

	push	esi
	push	ebx
	push	eax
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy_s

; 373  : 				_Ptr += _Size;
; 374  : 				_Copied += _Size;
; 375  : 				_Count -= _Size;
; 376  : 				pbump((int)_Size);

	mov	eax, DWORD PTR [edi+52]
	sub	DWORD PTR [eax], esi
	add	DWORD PTR __Copied$[esp+36], esi
	mov	eax, DWORD PTR [edi+36]
	add	ebx, esi
	sub	ebp, esi
	add	esp, 16					; 00000010H
	add	DWORD PTR [eax], esi

; 377  : 				}
; 378  : 			else if (_Traits::eq_int_type(_Traits::eof(),

	mov	esi, DWORD PTR __Copied$[esp+20]
	jmp	SHORT $LN1@xsputn
$LN5@xsputn:

; 379  : 				overflow(_Traits::to_int_type(*_Ptr))))

	movzx	eax, BYTE PTR [ebx]
	mov	edx, DWORD PTR [edi]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, edi
	call	eax
	cmp	eax, -1
	je	SHORT $LN30@xsputn

; 380  : 				break;	// single character put failed, quit
; 381  : 			else
; 382  : 				{	// count character successfully put
; 383  : 				++_Ptr;
; 384  : 				++_Copied;

	add	esi, 1
	add	ebx, 1
	mov	DWORD PTR __Copied$[esp+20], esi

; 385  : 				--_Count;

	sub	ebp, 1
$LN1@xsputn:

; 364  : 		streamsize _Stream_size, _Size, _Copied;
; 365  : 
; 366  : 		for (_Copied = 0; 0 < _Count; )

	test	ebp, ebp
	jg	SHORT $LL7@xsputn
$LN30@xsputn:
	pop	ebx
	pop	edi

; 386  : 				}
; 387  : 
; 388  : 		return (_Copied);

	mov	eax, esi
	pop	esi
	pop	ebp

; 389  : 		}

	pop	ecx
	ret	8
$LN31@xsputn:
	pop	edi

; 386  : 				}
; 387  : 
; 388  : 		return (_Copied);

	mov	eax, esi
	pop	esi
	pop	ebp

; 389  : 		}

	pop	ecx
	ret	8
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Xsgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADIH@Z
_TEXT	SEGMENT
__Copied$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Ptr_size$ = 12					; size = 4
__Count$ = 16						; size = 4
?_Xsgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADIH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Xsgetn_s, COMDAT
; _this$ = ecx

; 333  : 		{	// get _Count characters from stream

	push	ecx
	push	ebp

; 334  : 		int_type _Meta;
; 335  : 		streamsize _Stream_size, _Size, _Copied;
; 336  : 
; 337  : 		for (_Copied = 0; 0 < _Count; )

	mov	ebp, DWORD PTR __Count$[esp+4]
	push	esi
	xor	esi, esi
	test	ebp, ebp
	push	edi
	mov	edi, ecx
	mov	DWORD PTR __Copied$[esp+16], esi
	jle	SHORT $LN31@Xsgetn_s
	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp+16]
	npad	7
$LL7@Xsgetn_s:

; 338  : 			if (0 < (_Stream_size = _Gnavail()))

	mov	eax, edi
	call	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
	test	eax, eax
	jle	SHORT $LN5@Xsgetn_s

; 339  : 				{	// copy from read buffer
; 340  : 				_Size = _Stream_size;
; 341  : 				if (_Count < _Size)

	cmp	ebp, eax
	mov	esi, eax
	jge	SHORT $LN4@Xsgetn_s

; 342  : 					_Size = _Count;

	mov	esi, ebp
$LN4@Xsgetn_s:

; 343  : 				_Traits_helper::copy_s<_Traits>(_Ptr, _Ptr_size, gptr(), _Size);

	mov	eax, DWORD PTR [edi+32]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ptr_size$[esp+16]
	push	esi
	push	ecx
	push	edx
	push	ebx
	call	_memcpy_s

; 344  : 				_Ptr += _Size;
; 345  : 				_Copied += _Size;
; 346  : 				_Count -= _Size;
; 347  : 				gbump((int)_Size);

	mov	eax, DWORD PTR [edi+48]
	sub	DWORD PTR [eax], esi
	add	DWORD PTR __Copied$[esp+36], esi
	mov	eax, DWORD PTR [edi+32]
	add	ebx, esi
	sub	ebp, esi
	add	esp, 16					; 00000010H
	add	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Copied$[esp+20]
	jmp	SHORT $LN1@Xsgetn_s
$LN5@Xsgetn_s:

; 348  : 				}
; 349  : 			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+20]
	mov	ecx, edi
	call	edx
	cmp	eax, -1
	je	SHORT $LN30@Xsgetn_s

; 350  : 				break;	// end of file, quit
; 351  : 			else
; 352  : 				{	// get a single character
; 353  : 				*_Ptr++ = _Traits::to_char_type(_Meta);
; 354  : 				++_Copied;

	add	esi, 1
	mov	BYTE PTR [ebx], al
	add	ebx, 1
	mov	DWORD PTR __Copied$[esp+20], esi

; 355  : 				--_Count;

	sub	ebp, 1
$LN1@Xsgetn_s:

; 334  : 		int_type _Meta;
; 335  : 		streamsize _Stream_size, _Size, _Copied;
; 336  : 
; 337  : 		for (_Copied = 0; 0 < _Count; )

	test	ebp, ebp
	jg	SHORT $LL7@Xsgetn_s
$LN30@Xsgetn_s:
	pop	ebx
	pop	edi

; 356  : 				}
; 357  : 
; 358  : 		return (_Copied);

	mov	eax, esi
	pop	esi
	pop	ebp

; 359  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN31@Xsgetn_s:
	pop	edi

; 356  : 				}
; 357  : 
; 358  : 		return (_Copied);

	mov	eax, esi
	pop	esi
	pop	ebp

; 359  : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Xsgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADIH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Xsgetn_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__Lock$33119 = -4					; size = 4
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 43   : 		{	// destroy the object

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, ecx

; 44   : 		_DELETE_CRT(_Plocale);

	mov	ebx, DWORD PTR [ebp+56]
	test	ebx, ebx
	mov	DWORD PTR [ebp], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
	je	SHORT $LN3@basic_stre@2
	push	edi
	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	SHORT $LN12@basic_stre@2
	push	0
	lea	ecx, DWORD PTR __Lock$33119[esp+20]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN14@basic_stre@2
	cmp	eax, -1
	jae	SHORT $LN14@basic_stre@2
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN14@basic_stre@2:
	push	esi
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$33119[esp+20]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN18@basic_stre@2
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN18@basic_stre@2:
	pop	esi
$LN12@basic_stre@2:
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
$LN3@basic_stre@2:

; 45   : 		}

	lea	ecx, DWORD PTR [ebp+4]
	pop	ebp
	pop	ebx
	add	esp, 4
	jmp	??1_Mutex@std@@QAE@XZ			; std::_Mutex::~_Mutex
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T34681 = -4						; size = 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::grouping, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi

; 69   : 		{	// return grouping string

	push	ecx

; 70   : 		return (do_grouping());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	esi
	mov	DWORD PTR $T34681[esp+8], 0
	call	edx
	mov	eax, esi

; 71   : 		}

	pop	ecx
	ret	0
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z
_TEXT	SEGMENT
$T34688 = -24						; size = 12
$T34689 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Count$ = 24						; size = 4
__Kseparator$ = 28					; size = 1
?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped, COMDAT
; __Ptr$ = eax

; 1330 : 		{	// put char sequence [_Ptr, _Ptr + _Count) to _Dest with commas

	sub	esp, 24					; 00000018H
	push	ebx
	mov	ebx, DWORD PTR __Dest$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Dest$[esp+32]
	push	esi
	push	edi
	mov	edi, eax
$LL5@Putgrouped:

; 1331 : 		for (; ; ++_Ptr, --_Count)
; 1332 : 			{	// put field with thousands separators for NULs
; 1333 : 			const char *_Pend =
; 1334 : 				(const char *)::memchr(_Ptr, '\0', _Count);

	mov	esi, DWORD PTR __Count$[esp+36]
	push	esi
	push	0
	push	edi
	call	_memchr
	add	esp, 12					; 0000000cH

; 1335 : 			size_t _Groupsize = _Pend != 0 ? _Pend - _Ptr : _Count;

	test	eax, eax
	je	SHORT $LN8@Putgrouped
	sub	eax, edi
	mov	esi, eax
$LN8@Putgrouped:

; 1336 : 
; 1337 : 			_Dest = _Putc(_Dest, _Ptr, _Groupsize);

	mov	ecx, DWORD PTR __Dest$[esp+44]
	push	edi
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebp
	lea	edx, DWORD PTR $T34688[esp+56]
	mov	DWORD PTR [eax+8], ecx
	push	edx
	mov	eax, esi
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
	mov	ecx, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
	add	esp, 20					; 00000014H

; 1338 : 			_Ptr += _Groupsize, _Count -= _Groupsize;

	add	edi, esi
	sub	DWORD PTR __Count$[esp+36], esi
	mov	DWORD PTR __Dest$[esp+44], ecx

; 1339 : 			if (_Count == 0)

	je	SHORT $LN12@Putgrouped

; 1340 : 				break;
; 1341 : 			if (_Kseparator != (_Elem)0)

	mov	dl, BYTE PTR __Kseparator$[esp+36]
	test	dl, dl
	je	SHORT $LN4@Putgrouped

; 1342 : 				_Dest = _Rep(_Dest, _Kseparator, 1);

	mov	eax, DWORD PTR [eax+8]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	esi, ebx
	mov	DWORD PTR [ecx], esi
	mov	esi, ebp
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR $T34689[esp+52]
	push	ecx
	mov	eax, 1
	mov	bl, dl
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	edx, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Dest$[esp+44], edx
$LN4@Putgrouped:
	add	edi, 1
	sub	DWORD PTR __Count$[esp+36], 1
	jmp	$LL5@Putgrouped
$LN12@Putgrouped:

; 1343 : 			}
; 1344 : 		return (_Dest);

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+36]
	mov	eax, DWORD PTR [eax+8]
	mov	edx, ebx

; 1345 : 		}

	pop	edi
	mov	DWORD PTR [ecx], edx
	mov	edx, ebp
	pop	esi
	mov	DWORD PTR [ecx+4], edx
	pop	ebp
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T34698 = -4						; size = 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::truename, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi

; 79   : 		{	// return name for true

	push	ecx

; 80   : 		return (do_truename());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+20]
	push	esi
	mov	DWORD PTR $T34698[esp+8], 0
	call	edx
	mov	eax, esi

; 81   : 		}

	pop	ecx
	ret	0
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::truename
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T34704 = -4						; size = 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::falsename, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi

; 74   : 		{	// return name for false

	push	ecx

; 75   : 		return (do_falsename());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	esi
	mov	DWORD PTR $T34704[esp+8], 0
	call	edx
	mov	eax, esi

; 76   : 		}

	pop	ecx
	ret	0
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::falsename
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\sstream
xdata$x	SEGMENT
__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
__ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 29   : 	explicit __CLR_OR_THIS_CALL basic_stringbuf(ios_base::openmode _Mode =

	push	-1
	push	__ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+16]
	push	esi
	call	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 30   : 		ios_base::in | ios_base::out)
; 31   : 		{	// construct empty character buffer from mode
; 32   : 		_Init(0, 0, _Getstate(_Mode));

	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+64], 4

; 33   : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@13
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@13:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 42   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 43   : 		_Tidy();

	test	BYTE PTR [esi+64], 1
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	je	SHORT $LN19@basic_stri@2
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@basic_stri@2:
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx], 0
	and	DWORD PTR [esi+64], -2			; fffffffeH
	mov	DWORD PTR [esi+60], 0

; 44   : 		}

	mov	ecx, esi
	pop	esi
	jmp	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\ostream
xdata$x	SEGMENT
__unwindtable$??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ$0
__ehfuncinfo$??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\sstream
xdata$x	ENDS
;	COMDAT ??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 428  : 		{	// destroy the object

	push	-1
	push	__ehhandler$??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[esp+24], ecx
	mov	eax, DWORD PTR [ecx-76]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx-76], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 429  : 		}

	lea	esi, DWORD PTR [ecx-72]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+esi-4], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	sub	ecx, 72					; 00000048H
	jmp	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
__ehhandler$??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
; _this$ = eax
	push	esi
	mov	esi, eax
	add	esi, 76					; 0000004cH
	mov	ecx, esi
	call	??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
	push	esi
	mov	DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	add	esp, 4
	pop	esi
	ret	0
??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
; Function compile flags: /Ogtpy
; File f:\cygwin\home\charles\gusale\gusale\lib\jsoncpp-src-0.5.0\include\json\writer.h
_TEXT	ENDS
;	COMDAT ??1FastWriter@Json@@UAE@XZ
_TEXT	SEGMENT
??1FastWriter@Json@@UAE@XZ PROC				; Json::FastWriter::~FastWriter, COMDAT
; _this$ = ecx

; 33   :       virtual ~FastWriter(){}

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7FastWriter@Json@@6B@
	cmp	DWORD PTR [esi+28], 16			; 00000010H
	jb	SHORT $LN19@FastWriter
	mov	eax, DWORD PTR [esi+8]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@FastWriter:
	xor	eax, eax
	mov	DWORD PTR [esi+28], 15			; 0000000fH
	mov	DWORD PTR [esi+24], eax
	mov	BYTE PTR [esi+8], al
	mov	DWORD PTR [esi], OFFSET ??_7Writer@Json@@6B@
	pop	esi
	ret	0
??1FastWriter@Json@@UAE@XZ ENDP				; Json::FastWriter::~FastWriter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Uforward_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Copy_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Uforward_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::forward_iterator_tag>, COMDAT
; __First$ = ecx
; __Last$ = ebx
; __Dest$ = eax

; 2225 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	esi
	mov	esi, ecx

; 2226 : 	_DEBUG_RANGE(_First, _Last);
; 2227 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	esi, ebx
	push	edi
	mov	edi, eax
	je	SHORT $LN1@Copy_opt
	npad	6
$LL3@Copy_opt:

; 2228 : 		*_Dest = *_First;

	push	-1
	push	0
	push	esi
	mov	ecx, edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	add	esi, 28					; 0000001cH
	add	edi, 28					; 0000001cH
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt

; 2229 : 	return (_Dest);

	mov	eax, edi
$LN1@Copy_opt:
	pop	edi
	pop	esi

; 2230 : 	}

	ret	0
??$_Copy_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Uforward_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Copy_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; __First$ = ecx
; __Last$ = edi
; __Dest$ = eax

; 2237 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebx
	push	ebp
	mov	ebx, eax
	push	esi
	mov	esi, ecx

; 2238 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2239 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	ecx, edi
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 2240 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2241 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	cmp	esi, edi
	lea	ebp, DWORD PTR [ebx+ecx*4]
	je	SHORT $LN18@Copy_opt@2
	sub	ebx, esi
$LL9@Copy_opt@2:
	push	-1
	push	0
	push	esi
	lea	ecx, DWORD PTR [ebx+esi]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL9@Copy_opt@2
$LN18@Copy_opt@2:
	pop	esi

; 2242 : 	return _Result;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2243 : 	}

	ret	0
??$_Copy_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z PROC ; stdext::unchecked_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; __First$ = ecx
; __Last$ = edi
; __Dest$ = eax

; 2974 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebx
	push	ebp
	mov	ebx, eax
	push	esi
	mov	esi, ecx

; 2975 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 2976 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, edi
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	cmp	esi, edi
	lea	ebp, DWORD PTR [ebx+ecx*4]
	je	SHORT $LN32@unchecked_
	sub	ebx, esi
$LL23@unchecked_:
	push	-1
	push	0
	push	esi
	lea	ecx, DWORD PTR [ebx+esi]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL23@unchecked_
$LN32@unchecked_:
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2977 : 	}

	ret	0
??$unchecked_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z ENDP ; stdext::unchecked_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT
__Num$ = -4						; size = 4
tv178 = 8						; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = esi
; __Off$ = ebx

; 1136 : 		{	// insert _Count * _Ch at _Off

	push	ecx

; 1137 : 		if (_Mysize < _Off)

	cmp	DWORD PTR [esi+20], ebx
	push	ebp
	mov	ebp, DWORD PTR __Count$[esp+4]
	jae	SHORT $LN3@insert

; 1138 : 			_String_base::_Xran();	// _Off off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN3@insert:

; 1139 : 		if (npos - _Mysize <= _Count)

	or	eax, -1
	sub	eax, DWORD PTR [esi+20]
	cmp	eax, ebp
	ja	SHORT $LN2@insert

; 1140 : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN2@insert:

; 1141 : 		size_type _Num;
; 1142 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	ebp, ebp
	jbe	$LN96@insert
	push	edi
	mov	edi, DWORD PTR [esi+20]
	add	edi, ebp
	cmp	edi, -2					; fffffffeH
	mov	DWORD PTR __Num$[esp+12], edi
	jbe	SHORT $LN11@insert
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN11@insert:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN10@insert
	mov	ecx, DWORD PTR [esi+20]
	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN99@insert:
	jbe	$LN97@insert

; 1143 : 			{	// make room and insert new stuff
; 1144 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
; 1145 : 				_Myptr() + _Off, _Mysize - _Off);	// empty out hole

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, 16					; 00000010H
	lea	edi, DWORD PTR [esi+4]
	jb	SHORT $LN58@insert
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR tv178[esp+8], edx
	jmp	SHORT $LN59@insert

; 1141 : 		size_type _Num;
; 1142 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN10@insert:
	test	edi, edi
	jne	SHORT $LN99@insert
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN52@insert
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1148 : 			}
; 1149 : 		return (*this);

	mov	eax, esi
	pop	ebp

; 1150 : 		}

	pop	ecx
	ret	8

; 1141 : 		size_type _Num;
; 1142 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN52@insert:
	lea	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1148 : 			}
; 1149 : 		return (*this);

	mov	eax, esi
	pop	ebp

; 1150 : 		}

	pop	ecx
	ret	8

; 1143 : 			{	// make room and insert new stuff
; 1144 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
; 1145 : 				_Myptr() + _Off, _Mysize - _Off);	// empty out hole

$LN58@insert:
	mov	DWORD PTR tv178[esp+8], edi
$LN59@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN62@insert
	mov	ecx, DWORD PTR [edi]
	jmp	SHORT $LN63@insert
$LN62@insert:
	mov	ecx, edi
$LN63@insert:
	mov	edx, DWORD PTR [esi+20]
	sub	edx, ebx
	push	edx
	mov	edx, DWORD PTR tv178[esp+12]
	add	edx, ebx
	sub	eax, ebx
	push	edx
	sub	eax, ebp
	add	ecx, ebx
	push	eax
	add	ecx, ebp
	push	ecx
	call	_memmove_s
	add	esp, 16					; 00000010H

; 1146 : 			_Chassign(_Off, _Count, _Ch);	// fill hole

	cmp	ebp, 1
	jne	SHORT $LN73@insert
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN78@insert
	mov	eax, DWORD PTR [edi]
	mov	cl, BYTE PTR __Ch$[esp+8]
	mov	BYTE PTR [eax+ebx], cl
	jmp	SHORT $LN86@insert
$LN78@insert:
	mov	cl, BYTE PTR __Ch$[esp+8]
	mov	eax, edi
	mov	BYTE PTR [eax+ebx], cl
	jmp	SHORT $LN86@insert
$LN73@insert:
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN84@insert
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN85@insert
$LN84@insert:
	mov	eax, edi
$LN85@insert:
	movsx	edx, BYTE PTR __Ch$[esp+8]
	push	ebp
	push	edx
	add	eax, ebx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN86@insert:

; 1147 : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	eax, DWORD PTR __Num$[esp+12]
	mov	DWORD PTR [esi+20], eax
	jb	SHORT $LN92@insert
	mov	edi, DWORD PTR [edi]
$LN92@insert:
	mov	BYTE PTR [edi+eax], 0
$LN97@insert:
	pop	edi
$LN96@insert:

; 1148 : 			}
; 1149 : 		return (*this);

	mov	eax, esi
	pop	ebp

; 1150 : 		}

	pop	ecx
	ret	8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V32@0@Z
_TEXT	SEGMENT
__Cat$39136 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V32@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase, COMDAT
; _this$ = ebx

; 1006 : 		{	// erase [_First, _Last)

	push	ebp
	push	esi

; 1007 : 		if (_First != _Last)

	mov	esi, DWORD PTR __First$[esp+4]
	test	esi, esi
	je	SHORT $LN6@erase@2
	cmp	esi, DWORD PTR __Last$[esp+4]
	je	SHORT $LN7@erase@2
$LN6@erase@2:
	call	__invalid_parameter_noinfo
$LN7@erase@2:
	mov	ebp, DWORD PTR __First$[esp+8]
	mov	ecx, DWORD PTR __Last$[esp+8]
	cmp	ebp, ecx
	je	SHORT $LN1@erase@2
	push	edi

; 1008 : 			{	// worth doing, copy down over hole
; 1009 : 
; 1010 :  #if _HAS_ITERATOR_DEBUGGING
; 1011 : 			if (_Last < _First || _First._Mycont != this
; 1012 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1013 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1014 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1015 : 				_VEC_ITER_BASE(_First));
; 1016 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1017 : 
; 1018 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1019 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1020 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ebx+8]
	mov	eax, ebp
	call	??$unchecked_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z ; stdext::unchecked_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1021 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1022 : 
; 1023 : 			_Destroy(_Ptr, _Mylast);

	mov	edi, DWORD PTR [ebx+8]
	mov	esi, eax
	mov	eax, DWORD PTR __Cat$39136[esp+8]
	push	eax
	mov	eax, esi
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 4

; 1024 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ebx+8], esi
	mov	esi, DWORD PTR __First$[esp+8]
	pop	edi
$LN1@erase@2:

; 1025 : 			}
; 1026 : #if _HAS_ITERATOR_DEBUGGING
; 1027 :         return (iterator(_First._Myptr, this));
; 1028 : #else
; 1029 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], esi
	pop	esi
	mov	DWORD PTR [eax+4], ebp
	pop	ebp

; 1030 : #endif
; 1031 : 		}

	ret	20					; 00000014H
?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V32@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = esi
; __Count$ = ebx

; 1037 : 		if (_Count == npos)

	cmp	ebx, -1
	jne	SHORT $LN2@assign@2

; 1038 : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen

; 1039 : 
; 1040 : 		if (_Grow(_Count))

	jmp	SHORT $LN79@assign@2
$LN2@assign@2:
	cmp	ebx, -2					; fffffffeH
	jbe	SHORT $LN10@assign@2
$LN79@assign@2:
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN10@assign@2:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	jae	SHORT $LN9@assign@2
	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	ebx, ebx
$LN81@assign@2:
	jbe	SHORT $LN80@assign@2

; 1041 : 			{	// make room and assign new stuff
; 1042 : 			_Chassign(0, _Count, _Ch);

	cmp	ebx, 1
	push	edi
	lea	edi, DWORD PTR [esi+4]
	jne	SHORT $LN56@assign@2
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN61@assign@2
	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR [eax], 32			; 00000020H
	jmp	SHORT $LN69@assign@2

; 1039 : 
; 1040 : 		if (_Grow(_Count))

$LN9@assign@2:
	test	ebx, ebx
	jne	SHORT $LN81@assign@2
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], ebx
	jb	SHORT $LN51@assign@2
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax], bl

; 1044 : 			}
; 1045 : 		return (*this);

	mov	eax, esi

; 1046 : 		}

	ret	0

; 1039 : 
; 1040 : 		if (_Grow(_Count))

$LN51@assign@2:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax], 0

; 1044 : 			}
; 1045 : 		return (*this);

	mov	eax, esi

; 1046 : 		}

	ret	0

; 1041 : 			{	// make room and assign new stuff
; 1042 : 			_Chassign(0, _Count, _Ch);

$LN61@assign@2:
	mov	eax, edi
	mov	BYTE PTR [eax], 32			; 00000020H
	jmp	SHORT $LN69@assign@2
$LN56@assign@2:
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN67@assign@2
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN68@assign@2
$LN67@assign@2:
	mov	eax, edi
$LN68@assign@2:
	push	ebx
	push	32					; 00000020H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN69@assign@2:

; 1043 : 			_Eos(_Count);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], ebx
	jb	SHORT $LN75@assign@2
	mov	edi, DWORD PTR [edi]
$LN75@assign@2:
	mov	BYTE PTR [edi+ebx], 0
	pop	edi
$LN80@assign@2:

; 1044 : 			}
; 1045 : 		return (*this);

	mov	eax, esi

; 1046 : 		}

	ret	0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@18
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@18:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ecx-76]
	lea	esi, DWORD PTR [edi+76]
	mov	ecx, esi
	call	??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
	push	esi
	mov	DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	add	esp, 4
	test	BYTE PTR ___flags$[esp+4], 1
	je	SHORT $LN11@scalar@19
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@scalar@19:
	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
__Cat$39556 = -4					; size = 1
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear, COMDAT
; _this$ = esi

; 1034 : 		{	// erase all

	push	ecx
	push	ebx

; 1035 : 		erase(begin(), end());

	mov	ebx, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+4], ebx
	push	edi
	jbe	SHORT $LN8@clear
	call	__invalid_parameter_noinfo
$LN8@clear:
	mov	edi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [esi+8]
	jbe	SHORT $LN20@clear
	call	__invalid_parameter_noinfo
$LN20@clear:
	cmp	edi, ebx
	je	SHORT $LN27@clear
	mov	eax, edi
	mov	edi, DWORD PTR [esi+8]
	mov	ecx, ebx
	call	??$unchecked_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z ; stdext::unchecked_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	mov	edi, DWORD PTR [esi+8]
	mov	ebx, eax
	mov	eax, DWORD PTR __Cat$39556[esp+12]
	push	eax
	mov	eax, ebx
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 4
	mov	DWORD PTR [esi+8], ebx
$LN27@clear:
	pop	edi
	pop	ebx

; 1036 : 		}

	pop	ecx
	ret	0
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = eax
; __Count$ = ebx

; 645  : 		{	// construct from _Count * _Ch

	push	esi
	mov	esi, eax

; 646  : 		_Tidy();

	xor	eax, eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], eax
	mov	BYTE PTR [esi+4], al

; 647  : 		assign(_Count, _Ch);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 648  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$0
__ehfuncinfo$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File f:\cygwin\home\charles\gusale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
_TEXT	SEGMENT
$T39662 = -20						; size = 4
___$ReturnUdt$GSCopy$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z PROC ; Json::StyledWriter::normalizeEOL, COMDAT
; ___$ReturnUdt$ = edx
; _text$ = ecx

; 519  : {

	push	-1
	push	__ehhandler$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	esi, edx

; 520  :    std::string normalized;
; 521  :    normalized.reserve( text.length() );

	xor	eax, eax
	mov	DWORD PTR $T39662[esp+40], eax
	lea	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+40], esi
	mov	BYTE PTR [ebp], al

; 536  :    }
; 537  :    return normalized;

	mov	DWORD PTR __$EHRec$[esp+48], eax
	mov	eax, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR [esi+20]
	cmp	edi, eax
	mov	DWORD PTR $T39662[esp+40], 1
	ja	SHORT $LN54@normalizeE

; 520  :    std::string normalized;
; 521  :    normalized.reserve( text.length() );

	cmp	DWORD PTR [esi+24], eax
	je	SHORT $LN54@normalizeE
	push	1
	push	eax
	mov	ecx, esi
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN54@normalizeE
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN52@normalizeE
	mov	ebp, DWORD PTR [ebp]
$LN52@normalizeE:
	mov	BYTE PTR [edi+ebp], 0
$LN54@normalizeE:

; 522  :    const char *begin = text.c_str();

	cmp	DWORD PTR [ebx+24], 16			; 00000010H
	jb	SHORT $LN60@normalizeE
	mov	edi, DWORD PTR [ebx+4]
	jmp	SHORT $LN61@normalizeE
$LN60@normalizeE:
	lea	edi, DWORD PTR [ebx+4]
$LN61@normalizeE:

; 523  :    const char *end = begin + text.length();

	mov	ebx, DWORD PTR [ebx+20]
	lea	ebp, DWORD PTR [ebx+edi]

; 524  :    const char *current = begin;
; 525  :    while ( current != end )

	cmp	edi, ebp
	je	SHORT $LN65@normalizeE
$LL5@normalizeE:

; 526  :    {
; 527  :       char c = *current++;

	mov	bl, BYTE PTR [edi]
	add	edi, 1

; 528  :       if ( c == '\r' ) // mac or dos EOL

	cmp	bl, 13					; 0000000dH
	jne	SHORT $LN3@normalizeE

; 529  :       {
; 530  :          if ( *current == '\n' ) // convert dos EOL

	cmp	BYTE PTR [edi], 10			; 0000000aH
	jne	SHORT $LN2@normalizeE

; 531  :             ++current;

	add	edi, 1
$LN2@normalizeE:

; 532  :          normalized += '\n';

	mov	bl, 10					; 0000000aH
$LN3@normalizeE:

; 533  :       }
; 534  :       else // handle unix EOL & other char
; 535  :          normalized += c;

	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	cmp	edi, ebp
	jne	SHORT $LL5@normalizeE
$LN65@normalizeE:

; 536  :    }
; 537  :    return normalized;

	mov	eax, esi

; 538  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$0:
	mov	eax, DWORD PTR $T39662[ebp]
	and	eax, 1
	je	$LN9@normalizeE
	and	DWORD PTR $T39662[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN9@normalizeE:
	ret	0
__ehhandler$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-24]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ENDP ; Json::StyledWriter::normalizeEOL
; Function compile flags: /Ogtpy
;	COMDAT ??_GFastWriter@Json@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GFastWriter@Json@@UAEPAXI@Z PROC			; Json::FastWriter::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7FastWriter@Json@@6B@
	cmp	DWORD PTR [esi+28], 16			; 00000010H
	jb	SHORT $LN22@scalar@20
	mov	eax, DWORD PTR [esi+8]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN22@scalar@20:
	xor	eax, eax
	test	BYTE PTR ___flags$[esp], 1
	mov	DWORD PTR [esi+28], 15			; 0000000fH
	mov	DWORD PTR [esi+24], eax
	mov	BYTE PTR [esi+8], al
	mov	DWORD PTR [esi], OFFSET ??_7Writer@Json@@6B@
	je	SHORT $LN34@scalar@20
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@scalar@20:
	mov	eax, esi
	pop	esi
	ret	4
??_GFastWriter@Json@@UAEPAXI@Z ENDP			; Json::FastWriter::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = esi
; __Ptr$ = ecx

; 618  : 		_Tidy();

	xor	eax, eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	BYTE PTR [esi+4], al

; 619  : 		assign(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 620  : 		}

	mov	eax, esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$3
__ehfuncinfo$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\sstream
xdata$x	ENDS
;	COMDAT ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T43108 = -76						; size = 4
__Str$20707 = -72					; size = 28
__Str$20704 = -72					; size = 28
__Nul$20709 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; ___$ReturnUdt$ = esi

; 60   : 		{	// return string copy of character array

	push	-1
	push	__ehhandler$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	push	ebx
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+88]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _this$[esp+84]

; 61   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

	mov	ecx, DWORD PTR [eax+64]
	xor	ebx, ebx
	test	cl, 2
	mov	DWORD PTR $T43108[esp+88], ebx
	jne	SHORT $LN4@str
	mov	edx, DWORD PTR [eax+36]
	cmp	DWORD PTR [edx], ebx
	je	SHORT $LN4@str

; 62   : 			{	// writable, make string from write buffer
; 63   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()
; 64   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());

	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+60]
	cmp	ecx, edx
	jae	SHORT $LN7@str
	mov	ecx, edx
$LN7@str:
	mov	eax, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [eax]
	sub	ecx, eax
	push	ecx
	mov	edi, 15					; 0000000fH
	push	eax
	lea	ecx, DWORD PTR __Str$20704[esp+96]
	mov	DWORD PTR __Str$20704[esp+120], edi
	mov	DWORD PTR __Str$20704[esp+116], ebx
	mov	BYTE PTR __Str$20704[esp+100], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 65   : 			return (_Str);

	push	-1
	mov	DWORD PTR __$EHRec$[esp+100], ebx
	push	ebx
	lea	ecx, DWORD PTR __Str$20704[esp+96]
	push	ecx
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+20], ebx
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	DWORD PTR __Str$20704[esp+112], 16	; 00000010H
	jb	$LN292@str
	mov	edx, DWORD PTR __Str$20704[esp+92]
	push	edx
	jmp	$LN303@str
$LN4@str:

; 66   : 			}
; 67   : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

	test	cl, 4
	jne	SHORT $LN2@str
	mov	edx, DWORD PTR [eax+32]
	cmp	DWORD PTR [edx], ebx
	je	SHORT $LN2@str

; 68   : 			{	// readable, make string from read buffer
; 69   : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());

	mov	ecx, DWORD PTR [eax+48]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [edx]
	sub	ecx, eax
	push	ecx
	mov	edi, 15					; 0000000fH
	push	eax
	lea	ecx, DWORD PTR __Str$20707[esp+96]
	mov	DWORD PTR __Str$20707[esp+120], edi
	mov	DWORD PTR __Str$20707[esp+116], ebx
	mov	BYTE PTR __Str$20707[esp+100], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 70   : 			return (_Str);

	push	-1
	mov	DWORD PTR __$EHRec$[esp+100], 1
	push	ebx
	lea	eax, DWORD PTR __Str$20707[esp+96]
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+20], ebx
	push	eax
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	DWORD PTR __Str$20707[esp+112], 16	; 00000010H
	jb	SHORT $LN292@str
	mov	ecx, DWORD PTR __Str$20707[esp+92]
	push	ecx
	jmp	SHORT $LN303@str
$LN2@str:

; 71   : 			}
; 72   : 		else
; 73   : 			{	// inaccessible, return empty string
; 74   : 			_Mystr _Nul;

	mov	edi, 15					; 0000000fH
	mov	DWORD PTR __Nul$20709[esp+112], edi
	mov	DWORD PTR __Nul$20709[esp+108], ebx
	mov	BYTE PTR __Nul$20709[esp+92], bl

; 75   : 			return (_Nul);

	push	-1
	mov	DWORD PTR __$EHRec$[esp+100], 2
	push	ebx
	lea	edx, DWORD PTR __Nul$20709[esp+96]
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+20], ebx
	push	edx
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	DWORD PTR __Nul$20709[esp+112], 16	; 00000010H
	jb	SHORT $LN292@str
	mov	eax, DWORD PTR __Nul$20709[esp+92]
	push	eax
$LN303@str:
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN292@str:
	mov	eax, esi

; 76   : 			}
; 77   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+76]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0:
	lea	ecx, DWORD PTR __Str$20704[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$2:
	lea	ecx, DWORD PTR __Str$20707[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$3:
	lea	ecx, DWORD PTR __Nul$20709[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-72]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 8
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
; Function compile flags: /Ogtpy
;	COMDAT ?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T44277 = -4						; size = 4
?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ecx

; 437  : 		{	// return string copy of character array

	push	ecx
	push	esi

; 438  : 		return (_Stringbuffer.str());

	add	eax, 4
	mov	esi, ecx
	push	eax
	mov	DWORD PTR $T44277[esp+12], 0
	call	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
	mov	eax, esi
	pop	esi

; 439  : 		}

	pop	ecx
	ret	0
?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
PUBLIC	?unindent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::unindent
; Function compile flags: /Ogtpy
; File f:\cygwin\home\charles\gusale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?unindent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
?unindent@StyledWriter@Json@@AAEXXZ PROC		; Json::StyledWriter::unindent, COMDAT
; _this$ = eax

; 477  : {

	push	ebx

; 478  :    assert( int(indentString_.size()) >= indentSize_ );
; 479  :    indentString_.resize( indentString_.size() - indentSize_ );

	mov	ebx, DWORD PTR [eax+68]
	sub	ebx, DWORD PTR [eax+80]
	lea	ecx, DWORD PTR [eax+48]
	mov	eax, DWORD PTR [ecx+20]
	cmp	ebx, eax
	ja	SHORT $LN8@unindent
	push	-1
	push	ebx
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	ebx

; 480  : }

	ret	0

; 478  :    assert( int(indentString_.size()) >= indentSize_ );
; 479  :    indentString_.resize( indentString_.size() - indentSize_ );

$LN8@unindent:
	push	esi
	push	0
	sub	ebx, eax
	mov	esi, ecx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi
	pop	ebx

; 480  : }

	ret	0
?unindent@StyledWriter@Json@@AAEXXZ ENDP		; Json::StyledWriter::unindent
_TEXT	ENDS
PUBLIC	?indent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::indent
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?indent@StyledWriter@Json@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?indent@StyledWriter@Json@@AAEXXZ$0
__ehfuncinfo$?indent@StyledWriter@Json@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?indent@StyledWriter@Json@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File f:\cygwin\home\charles\gusale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ?indent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
$T44303 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?indent@StyledWriter@Json@@AAEXXZ PROC			; Json::StyledWriter::indent, COMDAT
; _this$ = edi

; 470  : {

	push	-1
	push	__ehhandler$?indent@StyledWriter@Json@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, eax

; 471  :    indentString_ += std::string( indentSize_, ' ' );

	mov	ebx, DWORD PTR [edi+80]
	xor	eax, eax
	lea	esi, DWORD PTR $T44303[esp+52]
	mov	DWORD PTR $T44303[esp+76], 15		; 0000000fH
	mov	DWORD PTR $T44303[esp+72], eax
	mov	BYTE PTR $T44303[esp+56], al
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, esi
	push	0
	push	eax
	lea	esi, DWORD PTR [edi+48]
	or	eax, -1
	mov	DWORD PTR __$EHRec$[esp+68], 0
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	cmp	DWORD PTR $T44303[esp+76], 16		; 00000010H
	jb	SHORT $LN56@indent
	mov	ecx, DWORD PTR $T44303[esp+56]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@indent:

; 472  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?indent@StyledWriter@Json@@AAEXXZ$0:
	lea	ecx, DWORD PTR $T44303[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?indent@StyledWriter@Json@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-36]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?indent@StyledWriter@Json@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?indent@StyledWriter@Json@@AAEXXZ ENDP			; Json::StyledWriter::indent
PUBLIC	?writeIndent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::writeIndent
; Function compile flags: /Ogtpy
;	COMDAT ?writeIndent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?writeIndent@StyledWriter@Json@@AAEXXZ PROC		; Json::StyledWriter::writeIndent, COMDAT

; 447  : {

	push	ebp
	mov	ebp, DWORD PTR _this$[esp]

; 448  :    if ( !document_.empty() )

	mov	eax, DWORD PTR [ebp+40]
	test	eax, eax
	push	esi
	je	SHORT $LN1@writeInden
	push	edi

; 449  :    {
; 450  :       char last = document_[document_.length()-1];

	lea	edi, DWORD PTR [eax-1]
	cmp	edi, DWORD PTR [ebp+40]
	lea	esi, DWORD PTR [ebp+20]
	jbe	SHORT $LN10@writeInden
	call	__invalid_parameter_noinfo
$LN10@writeInden:
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN15@writeInden
	mov	eax, DWORD PTR [esi+4]
	jmp	SHORT $LN16@writeInden
$LN15@writeInden:
	lea	eax, DWORD PTR [esi+4]
$LN16@writeInden:
	mov	al, BYTE PTR [eax+edi]

; 451  :       if ( last == ' ' )     // already indented

	cmp	al, 32					; 00000020H
	pop	edi
	je	SHORT $LN17@writeInden

; 452  :          return;
; 453  :       if ( last != '\n' )    // Comments may add new-line

	cmp	al, 10					; 0000000aH
	je	SHORT $LN1@writeInden
	push	ebx

; 454  :          document_ += '\n';

	mov	bl, 10					; 0000000aH
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	pop	ebx
$LN1@writeInden:

; 455  :    }
; 456  :    document_ += indentString_;

	push	0
	lea	eax, DWORD PTR [ebp+48]
	push	eax
	lea	esi, DWORD PTR [ebp+20]
	or	eax, -1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN17@writeInden:
	pop	esi
	pop	ebp

; 457  : }

	ret	4
?writeIndent@StyledWriter@Json@@AAEXXZ ENDP		; Json::StyledWriter::writeIndent
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$??0?$numpunct@D@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@I@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@I@Z$1
__ehfuncinfo$??0?$numpunct@D@std@@QAE@I@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$numpunct@D@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ??0?$numpunct@D@std@@QAE@I@Z
_TEXT	SEGMENT
_this$GSCopy$ = -140					; size = 4
__Lobj$22153 = -136					; size = 116
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$numpunct@D@std@@QAE@I@Z PROC			; std::numpunct<char>::numpunct<char>, COMDAT
; _this$ = esi

; 85   : 		{	// construct from current locale

	push	-1
	push	__ehhandler$??0?$numpunct@D@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+144], eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+148]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$[esp+148], esi
	mov	DWORD PTR [esi+4], 0

; 86   : 		_BEGIN_LOCINFO(_Lobj)

	lea	eax, DWORD PTR __Lobj$22153[esp+148]
	mov	DWORD PTR __$EHRec$[esp+156], 0
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo

; 87   : 			_Init(_Lobj);

	push	esi
	mov	BYTE PTR __$EHRec$[esp+160], 1
	call	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z ; std::numpunct<char>::_Init

; 88   : 			if (_Kseparator == 0)

	cmp	BYTE PTR [esi+13], 0
	jne	SHORT $LN1@numpunct

; 89   : 				_Kseparator =	// NB: differs from "C" locale
; 90   : 					_MAKLOCCHR(_Elem, ',', _Lobj._Getcvt());

	call	__Getcvt
	mov	BYTE PTR [esi+13], 44			; 0000002cH
$LN1@numpunct:

; 91   : 		_END_LOCINFO()

	lea	ecx, DWORD PTR __Lobj$22153[esp+148]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+160], 0
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo

; 92   : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+148]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+144]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 144				; 00000090H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$numpunct@D@std@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	jmp	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
__unwindfunclet$??0?$numpunct@D@std@@QAE@I@Z$1:
	lea	eax, DWORD PTR __Lobj$22153[ebp]
	push	eax
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
	ret	0
__ehhandler$??0?$numpunct@D@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-132]
	mov	ecx, DWORD PTR [edx-136]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 0
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$numpunct@D@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$numpunct@D@std@@QAE@I@Z ENDP			; std::numpunct<char>::numpunct<char>
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xlocinfo
xdata$x	SEGMENT
__unwindtable$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
_this$GSCopy$ = -140					; size = 4
__Lobj$22150 = -136					; size = 116
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = esi

; 862  : 		{	// construct from current locale

	push	-1
	push	__ehhandler$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+144], eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+148]
	mov	DWORD PTR fs:0, eax
	xor	eax, eax
	mov	DWORD PTR _this$GSCopy$[esp+148], esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR __$EHRec$[esp+156], eax

; 863  : 		_BEGIN_LOCINFO(_Lobj)

	lea	eax, DWORD PTR __Lobj$22150[esp+148]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo

; 864  : 			_Init(_Lobj);

	call	__Getcvt

; 865  : 		_END_LOCINFO()

	lea	ecx, DWORD PTR __Lobj$22150[esp+148]
	push	ecx
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edx
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo

; 866  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+148]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+144]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 144				; 00000090H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	jmp	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
__ehhandler$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-132]
	mov	ecx, DWORD PTR [edx-136]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 0
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z$0
__ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT
$T47459 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z PROC ; std::numpunct<char>::_Getcat, COMDAT
; __Ppf$ = edi

; 101  : 		{	// return locale category mask and construct standard facet

	push	-1
	push	__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax

; 102  : 		if (_Ppf != 0 && *_Ppf == 0)

	test	edi, edi
	je	SHORT $LN8@Getcat
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN8@Getcat

; 103  : 			*_Ppf = _NEW_CRT numpunct<_Elem>;

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T47459[esp+28], eax
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	je	SHORT $LN4@Getcat
	mov	esi, eax
	call	??0?$numpunct@D@std@@QAE@I@Z		; std::numpunct<char>::numpunct<char>
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	xor	eax, eax
$LN5@Getcat:
	mov	DWORD PTR [edi], eax
$LN8@Getcat:

; 104  : 		return (_X_NUMERIC);

	mov	eax, 4

; 105  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z$0:
	mov	eax, DWORD PTR $T47459[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z ENDP ; std::numpunct<char>::_Getcat
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z$0
__ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT
$T47475 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT
; __Ppf$ = edi

; 838  : 		{	// return locale category mask and construct standard facet

	push	-1
	push	__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax

; 839  : 		if (_Ppf != 0 && *_Ppf == 0)

	test	edi, edi
	je	SHORT $LN8@Getcat@2
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN8@Getcat@2

; 840  : 			*_Ppf = _NEW_CRT num_put<_Elem, _OutIt>;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T47475[esp+28], eax
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	je	SHORT $LN4@Getcat@2
	mov	esi, eax
	call	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
	jmp	SHORT $LN5@Getcat@2
$LN4@Getcat@2:
	xor	eax, eax
$LN5@Getcat@2:
	mov	DWORD PTR [edi], eax
$LN8@Getcat@2:

; 841  : 		return (_X_NUMERIC);

	mov	eax, 4

; 842  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z$0:
	mov	eax, DWORD PTR $T47475[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$21983 = -36					; size = 4
__Lock$47498 = -32					; size = 4
__Lock$21982 = -28					; size = 4
$T47490 = -24						; size = 12
__$EHRec$ = -12						; size = 12
__Lock$47520 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT

; 466  : 	{	// get facet reference from locale

	push	-1
	push	__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, eax

; 467  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$21982[esp+52]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[esp+56], 0

; 468  : 		const locale::facet *_Psave =
; 469  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 470  : 
; 471  : 		size_t _Id = _Facet::id;

	cmp	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, 0 ; std::numpunct<char>::id
	mov	edi, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
	mov	DWORD PTR __Psave$21983[esp+48], edi
	jne	SHORT $LN11@use_facet
	push	0
	lea	ecx, DWORD PTR __Lock$47498[esp+52]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	cmp	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, 0 ; std::numpunct<char>::id
	jne	SHORT $LN10@use_facet
	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	add	eax, 1
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, eax ; std::numpunct<char>::id
$LN10@use_facet:
	lea	ecx, DWORD PTR __Lock$47498[esp+48]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN11@use_facet:

; 472  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	eax, DWORD PTR __Loc$[esp+44]
	mov	esi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	mov	eax, DWORD PTR [eax]
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN20@use_facet
	mov	ecx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+esi*4]
	test	ecx, ecx
	jne	SHORT $LN16@use_facet
$LN30@use_facet:
	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN16@use_facet
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN31@use_facet
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN15@use_facet
$LN20@use_facet:
	xor	ecx, ecx
	jmp	SHORT $LN30@use_facet
$LN16@use_facet:
	mov	esi, ecx
$LN15@use_facet:

; 473  : 
; 474  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN28@use_facet
$LN31@use_facet:

; 475  : 			;	// got facet from locale
; 476  : 		else if (_Psave != 0)

	test	edi, edi
	je	SHORT $LN4@use_facet

; 477  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, edi
	jmp	SHORT $LN28@use_facet
$LN4@use_facet:

; 478  : 		else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

	lea	edi, DWORD PTR __Psave$21983[esp+48]
	call	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z ; std::numpunct<char>::_Getcat
	cmp	eax, -1
	jne	SHORT $LN2@use_facet

; 479  : 
; 480  :  #if _HAS_EXCEPTIONS
; 481  : 		_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T47490[esp+52]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	eax, DWORD PTR $T47490[esp+52]
	push	eax
	call	__CxxThrowException@8
$LN34@use_facet:
$LN2@use_facet:

; 482  : 
; 483  : 	#else /* _HAS_EXCEPTIONS */
; 484  : 			abort();	// lazy disallowed
; 485  : 	#endif /* _HAS_EXCEPTIONS */
; 486  : 
; 487  : 		else
; 488  : 			{	// queue up lazy facet for destruction
; 489  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$21983[esp+48]

; 490  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 491  : 
; 492  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 493  : 			_Pfmod->_Incref();

	push	0
	lea	ecx, DWORD PTR __Lock$47520[esp+48]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::numpunct<char> >::_Psave
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN24@use_facet
	add	eax, 1
	mov	DWORD PTR [esi+4], eax
$LN24@use_facet:
	lea	ecx, DWORD PTR __Lock$47520[esp+44]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 494  : 			_Pfmod->_Register();

	push	esi
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	add	esp, 4
$LN28@use_facet:

; 495  : 			}
; 496  : 
; 497  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$21982[esp+48]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 498  : 	_END_LOCK()
; 499  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 36					; 00000024H
	ret	0
$LN33@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$21982[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-32]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$21558 = -36					; size = 4
__Lock$47546 = -32					; size = 4
__Lock$21557 = -28					; size = 4
$T47538 = -24						; size = 12
__$EHRec$ = -12						; size = 12
__Lock$47568 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 466  : 	{	// get facet reference from locale

	push	-1
	push	__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, eax

; 467  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$21557[esp+52]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[esp+56], 0

; 468  : 		const locale::facet *_Psave =
; 469  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 470  : 
; 471  : 		size_t _Id = _Facet::id;

	cmp	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, 0 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	mov	edi, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	DWORD PTR __Psave$21558[esp+48], edi
	jne	SHORT $LN11@use_facet@2
	push	0
	lea	ecx, DWORD PTR __Lock$47546[esp+52]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	cmp	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, 0 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	jne	SHORT $LN10@use_facet@2
	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	add	eax, 1
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN10@use_facet@2:
	lea	ecx, DWORD PTR __Lock$47546[esp+48]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN11@use_facet@2:

; 472  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	eax, DWORD PTR __Loc$[esp+44]
	mov	esi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	mov	eax, DWORD PTR [eax]
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN20@use_facet@2
	mov	ecx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+esi*4]
	test	ecx, ecx
	jne	SHORT $LN16@use_facet@2
$LN30@use_facet@2:
	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN16@use_facet@2
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN31@use_facet@2
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN15@use_facet@2
$LN20@use_facet@2:
	xor	ecx, ecx
	jmp	SHORT $LN30@use_facet@2
$LN16@use_facet@2:
	mov	esi, ecx
$LN15@use_facet@2:

; 473  : 
; 474  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN28@use_facet@2
$LN31@use_facet@2:

; 475  : 			;	// got facet from locale
; 476  : 		else if (_Psave != 0)

	test	edi, edi
	je	SHORT $LN4@use_facet@2

; 477  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, edi
	jmp	SHORT $LN28@use_facet@2
$LN4@use_facet@2:

; 478  : 		else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

	lea	edi, DWORD PTR __Psave$21558[esp+48]
	call	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
	cmp	eax, -1
	jne	SHORT $LN2@use_facet@2

; 479  : 
; 480  :  #if _HAS_EXCEPTIONS
; 481  : 		_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T47538[esp+52]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	eax, DWORD PTR $T47538[esp+52]
	push	eax
	call	__CxxThrowException@8
$LN34@use_facet@2:
$LN2@use_facet@2:

; 482  : 
; 483  : 	#else /* _HAS_EXCEPTIONS */
; 484  : 			abort();	// lazy disallowed
; 485  : 	#endif /* _HAS_EXCEPTIONS */
; 486  : 
; 487  : 		else
; 488  : 			{	// queue up lazy facet for destruction
; 489  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$21558[esp+48]

; 490  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 491  : 
; 492  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 493  : 			_Pfmod->_Incref();

	push	0
	lea	ecx, DWORD PTR __Lock$47568[esp+48]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN24@use_facet@2
	add	eax, 1
	mov	DWORD PTR [esi+4], eax
$LN24@use_facet@2:
	lea	ecx, DWORD PTR __Lock$47568[esp+44]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 494  : 			_Pfmod->_Register();

	push	esi
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	add	esp, 4
$LN28@use_facet@2:

; 495  : 			}
; 496  : 
; 497  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$21557[esp+48]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 498  : 	_END_LOCK()
; 499  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 36					; 00000024H
	ret	0
$LN33@use_facet@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$21557[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-32]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T47587 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 165  : 		{	// return name for true

	push	ecx

; 166  : 		return (string_type(_Truename));

	mov	ecx, DWORD PTR [ecx+20]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	eax, ecx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR $T47587[esp+12], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	7
$LL41@do_truenam:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL41@do_truenam
	sub	eax, edi
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	mov	eax, esi
	pop	esi

; 167  : 		}

	pop	ecx
	ret	4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T47738 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 160  : 		{	// return name for false

	push	ecx

; 161  : 		return (string_type(_Falsename));

	mov	ecx, DWORD PTR [ecx+16]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	eax, ecx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR $T47738[esp+12], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	7
$LL41@do_falsena:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL41@do_falsena
	sub	eax, edi
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	mov	eax, esi
	pop	esi

; 162  : 		}

	pop	ecx
	ret	4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T47889 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 155  : 		{	// return grouping string

	push	ecx

; 156  : 		return (string(_Grouping));

	mov	ecx, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	eax, ecx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR $T47889[esp+12], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	7
$LL41@do_groupin:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL41@do_groupin
	sub	eax, edi
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	mov	eax, esi
	pop	esi

; 157  : 		}

	pop	ecx
	ret	4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
_TEXT	ENDS
PUBLIC	__Iosbase$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1
__ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT
__Lock$48076 = -76					; size = 4
__Prefix$ = -76						; size = 4
__Pg$21204 = -72					; size = 4
$T48141 = -68						; size = 1
__Punct_fac$ = -68					; size = 4
__Iosbase$GSCopy$ = -64					; size = 4
$T48040 = -60						; size = 4
$T48051 = -56						; size = 12
$T48050 = -56						; size = 12
$T48049 = -56						; size = 12
$T48048 = -56						; size = 12
__Grouping$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT

; 1263 : 		{	// put formatted integer to _Dest

	push	-1
	push	__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+80], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Iosbase$[esp+96]
	mov	ebp, DWORD PTR __Buf$[esp+96]

; 1264 : 		_DEBUG_POINTER(_Dest);
; 1265 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	edi, DWORD PTR $T48040[esp+100]

; 1304 : 			}
; 1305 : 
; 1306 : 		_Dest = _Putgrouped(_Dest, _Buf, _Count,
; 1307 : 			_Punct_fac.thousands_sep());	// put field

	mov	DWORD PTR __Iosbase$GSCopy$[esp+100], eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[esp+112], 0
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	ebx, eax
	mov	DWORD PTR __$EHRec$[esp+112], -1
	mov	eax, DWORD PTR $T48040[esp+104]
	add	esp, 4
	test	eax, eax
	mov	DWORD PTR __Punct_fac$[esp+100], ebx
	je	SHORT $LN22@Iput
	push	0
	lea	ecx, DWORD PTR __Lock$48076[esp+104]
	mov	edi, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN24@Iput

; 1264 : 		_DEBUG_POINTER(_Dest);
; 1265 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	cmp	eax, -1
	jae	SHORT $LN24@Iput
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN24@Iput:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$48076[esp+100]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN22@Iput
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN22@Iput:

; 1266 : 		const string _Grouping = _Punct_fac.grouping();

	lea	esi, DWORD PTR __Grouping$[esp+100]
	mov	ecx, ebx
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	ecx, 1
	mov	DWORD PTR __$EHRec$[esp+108], ecx

; 1267 : 		const size_t _Prefix = *_Buf == '+' || *_Buf == '-' ? 1
; 1268 : 			: *_Buf == '0' && (_Buf[1] == 'x' || _Buf[1] == 'X') ? 2
; 1269 : 			: 0;

	mov	al, BYTE PTR [ebp]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN10@Iput
	cmp	al, 45					; 0000002dH
	je	SHORT $LN10@Iput
	cmp	al, 48					; 00000030H
	jne	SHORT $LN12@Iput
	mov	al, BYTE PTR [ebp+1]
	cmp	al, 120					; 00000078H
	je	SHORT $LN11@Iput
	cmp	al, 88					; 00000058H
	jne	SHORT $LN12@Iput
$LN11@Iput:
	mov	DWORD PTR __Prefix$[esp+100], 2
	jmp	SHORT $LN14@Iput
$LN12@Iput:
	mov	DWORD PTR __Prefix$[esp+100], 0
	jmp	SHORT $LN14@Iput
$LN10@Iput:
	mov	DWORD PTR __Prefix$[esp+100], ecx
$LN14@Iput:

; 1270 : 
; 1271 : 		if (*_Grouping.c_str() != CHAR_MAX && '\0' < *_Grouping.c_str())

	mov	ecx, DWORD PTR __Grouping$[esp+124]
	cmp	ecx, 16					; 00000010H
	mov	edx, DWORD PTR __Grouping$[esp+104]
	mov	eax, edx
	jae	SHORT $LN33@Iput
	lea	eax, DWORD PTR __Grouping$[esp+104]
$LN33@Iput:
	cmp	BYTE PTR [eax], 127			; 0000007fH
	je	$LN88@Iput
	cmp	ecx, 16					; 00000010H
	mov	eax, edx
	jae	SHORT $LN39@Iput
	lea	eax, DWORD PTR __Grouping$[esp+104]
$LN39@Iput:
	cmp	BYTE PTR [eax], 0
	jle	SHORT $LN88@Iput

; 1272 : 			{	// grouping specified, add thousands separators
; 1273 : 			const char *_Pg = _Grouping.c_str();

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN44@Iput
	mov	DWORD PTR __Pg$21204[esp+100], edx
	jmp	SHORT $LN45@Iput
$LN44@Iput:
	lea	eax, DWORD PTR __Grouping$[esp+104]
	mov	DWORD PTR __Pg$21204[esp+100], eax
$LN45@Iput:

; 1274 : 			size_t _Off = _Count;
; 1275 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1276 : 				&& (size_t)*_Pg < _Off - _Prefix)

	mov	ecx, DWORD PTR __Pg$21204[esp+100]
	mov	al, BYTE PTR [ecx]
	cmp	al, 127					; 0000007fH
	mov	edi, DWORD PTR __Count$[esp+96]
	mov	esi, edi
	je	SHORT $LN5@Iput
$LN6@Iput:
	test	al, al
	jle	SHORT $LN5@Iput
	mov	edx, esi
	sub	edx, DWORD PTR __Prefix$[esp+100]
	movsx	eax, al
	cmp	eax, edx
	jae	SHORT $LN5@Iput

; 1277 : 				{	// add a NUL to mark thousands separator
; 1278 : 				_Off -= *_Pg;

	sub	esi, eax

; 1279 : 				_CRT_SECURE_MEMMOVE(&_Buf[_Off + 1], _Count + 1 - _Off,

	mov	eax, edi
	sub	eax, esi
	add	eax, 1
	push	eax
	lea	ebx, DWORD PTR [esi+ebp]
	push	ebx
	push	eax
	lea	ecx, DWORD PTR [esi+ebp+1]
	push	ecx
	call	_memmove_s

; 1280 : 					&_Buf[_Off],	 _Count + 1 - _Off);
; 1281 : 				_Buf[_Off] = '\0', ++_Count;
; 1282 : 				if ('\0' < _Pg[1])

	mov	eax, DWORD PTR __Pg$21204[esp+116]
	add	esp, 16					; 00000010H
	mov	BYTE PTR [ebx], 0
	add	edi, 1
	cmp	BYTE PTR [eax+1], 0
	jle	SHORT $LN4@Iput
	add	eax, 1
	mov	DWORD PTR __Pg$21204[esp+100], eax
$LN4@Iput:
	mov	al, BYTE PTR [eax]
	cmp	al, 127					; 0000007fH
	jne	SHORT $LN6@Iput

; 1274 : 			size_t _Off = _Count;
; 1275 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1276 : 				&& (size_t)*_Pg < _Off - _Prefix)

	jmp	SHORT $LN5@Iput
$LN88@Iput:
	mov	edi, DWORD PTR __Count$[esp+96]
$LN5@Iput:

; 1283 : 					++_Pg;	// not last group, advance
; 1284 : 				}
; 1285 : 			}
; 1286 : 
; 1287 : 		size_t _Fillcount = _Iosbase.width() <= 0
; 1288 : 			|| (size_t)_Iosbase.width() <= _Count
; 1289 : 				? 0 : (size_t)_Iosbase.width() - _Count;

	mov	eax, DWORD PTR __Iosbase$GSCopy$[esp+100]
	mov	esi, DWORD PTR [eax+24]
	test	esi, esi
	jle	SHORT $LN15@Iput
	cmp	esi, edi
	jbe	SHORT $LN15@Iput
	sub	esi, edi
	jmp	SHORT $LN16@Iput
$LN15@Iput:
	xor	esi, esi
$LN16@Iput:

; 1290 : 
; 1291 : 		ios_base::fmtflags _Adjustfield =
; 1292 : 			_Iosbase.flags() & ios_base::adjustfield;

	mov	eax, DWORD PTR [eax+16]
	and	eax, 448				; 000001c0H

; 1293 : 		if (_Adjustfield != ios_base::left
; 1294 : 			&& _Adjustfield != ios_base::internal)

	cmp	eax, 64					; 00000040H
	je	$LN87@Iput
	cmp	eax, 256				; 00000100H
	je	SHORT $LN85@Iput

; 1295 : 			{	// put leading fill
; 1296 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	edx, DWORD PTR __Dest$[esp+96]
	mov	ecx, DWORD PTR __Dest$[esp+100]
	mov	bl, BYTE PTR __Fill$[esp+96]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Dest$[esp+116]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
	lea	eax, DWORD PTR $T48048[esp+112]
	push	eax
	mov	eax, esi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR [eax+8]
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Dest$[esp+96], ecx
	mov	DWORD PTR __Dest$[esp+100], edx

; 1297 : 			_Fillcount = 0;

	xor	esi, esi
	jmp	SHORT $LN1@Iput
$LN85@Iput:

; 1298 : 			}
; 1299 : 		else if (_Adjustfield == ios_base::internal)
; 1300 : 			{	// put internal fill
; 1301 : 			_Dest = _Putc(_Dest, _Buf, _Prefix);	// put prefix

	mov	ecx, DWORD PTR __Dest$[esp+96]
	mov	edx, DWORD PTR __Dest$[esp+100]
	mov	ebx, DWORD PTR __Prefix$[esp+100]
	push	ebp
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+120]
	mov	DWORD PTR [eax+4], edx
	lea	edx, DWORD PTR $T48049[esp+116]
	mov	DWORD PTR [eax+8], ecx
	push	edx
	mov	eax, ebx
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc

; 1302 : 			_Buf += _Prefix, _Count -= _Prefix;
; 1303 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount), _Fillcount = 0;

	mov	edx, DWORD PTR [eax]
	add	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR $T48050[esp+112]
	add	ebp, ebx
	sub	edi, ebx
	mov	bl, BYTE PTR __Fill$[esp+108]
	push	ecx
	mov	eax, esi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR [eax+8]
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Dest$[esp+96], edx
	mov	DWORD PTR __Dest$[esp+100], ecx
	xor	esi, esi
	jmp	SHORT $LN1@Iput
$LN87@Iput:
	mov	ebx, DWORD PTR __Dest$[esp+104]
$LN1@Iput:

; 1304 : 			}
; 1305 : 
; 1306 : 		_Dest = _Putgrouped(_Dest, _Buf, _Count,
; 1307 : 			_Punct_fac.thousands_sep());	// put field

	mov	ecx, DWORD PTR __Punct_fac$[esp+100]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	edx, DWORD PTR __Dest$[esp+96]
	mov	BYTE PTR $T48141[esp+100], al
	mov	ecx, DWORD PTR $T48141[esp+100]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+104]
	push	edi
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	lea	edx, DWORD PTR $T48051[esp+120]
	mov	DWORD PTR [eax+8], ebx
	push	edx
	mov	eax, ebp
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
	mov	edi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]

; 1308 : 		_Iosbase.width(0);

	mov	ecx, DWORD PTR __Iosbase$GSCopy$[esp+124]

; 1309 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	bl, BYTE PTR __Fill$[esp+120]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+24], 0
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	DWORD PTR [ecx+8], eax
	push	edi
	mov	eax, esi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 16					; 00000010H
	cmp	DWORD PTR __Grouping$[esp+124], 16	; 00000010H
	jb	SHORT $LN86@Iput
	mov	edx, DWORD PTR __Grouping$[esp+104]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN86@Iput:
	mov	eax, edi

; 1310 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+80]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 80					; 00000050H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0:
	lea	ecx, DWORD PTR $T48040[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-84]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	__Iosbase$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$2
__ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
_TEXT	SEGMENT
__Fillcount$ = -112					; size = 4
__Eptr$ = -112						; size = 4
__Enders$ = -108					; size = 3
__Fracoffset$21170 = -104				; size = 4
__Prefix$ = -104					; size = 4
__Kseparator$ = -100					; size = 1
__Lock$48321 = -100					; size = 4
__Iosbase$GSCopy$ = -96					; size = 4
$T48295 = -92						; size = 12
$T48294 = -92						; size = 12
$T48293 = -92						; size = 12
$T48290 = -92						; size = 12
$T48289 = -92						; size = 12
$T48288 = -92						; size = 12
$T48287 = -92						; size = 12
$T48286 = -92						; size = 12
$T48285 = -92						; size = 12
$T48284 = -92						; size = 12
$T48283 = -92						; size = 12
$T48282 = -92						; size = 12
__Expoffset$21177 = -80					; size = 4
__Punct_fac$ = -80					; size = 4
$T48277 = -76						; size = 4
__Groupstring$ = -72					; size = 28
__Grouping$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Beforepoint$ = 36					; size = 4
__Afterpoint$ = 40					; size = 4
__Trailing$ = 44					; size = 4
__Count$ = 48						; size = 4
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput, COMDAT

; 1118 : 		{	// put formatted floating-point to _Dest

	push	-1
	push	__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+116], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+136]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Iosbase$[esp+132]
	mov	ebp, DWORD PTR __Buf$[esp+132]

; 1119 : 		_DEBUG_POINTER(_Dest);
; 1120 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	edi, DWORD PTR $T48277[esp+136]

; 1225 : 			}
; 1226 : 
; 1227 : 		_Dest = _Putgrouped(_Dest, _Buf, _Count,
; 1228 : 			_Kseparator);	// put leftover field

	mov	DWORD PTR __Iosbase$GSCopy$[esp+136], eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[esp+148], 0
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	edi, eax
	mov	DWORD PTR __$EHRec$[esp+148], -1
	mov	eax, DWORD PTR $T48277[esp+140]
	add	esp, 4
	test	eax, eax
	mov	DWORD PTR __Punct_fac$[esp+136], edi
	je	SHORT $LN31@Fput
	push	0
	lea	ecx, DWORD PTR __Lock$48321[esp+140]
	mov	ebx, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jbe	SHORT $LN33@Fput

; 1119 : 		_DEBUG_POINTER(_Dest);
; 1120 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	cmp	eax, -1
	jae	SHORT $LN33@Fput
	add	eax, -1
	mov	DWORD PTR [ebx+4], eax
$LN33@Fput:
	mov	esi, DWORD PTR [ebx+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$48321[esp+136]
	and	esi, ebx
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN31@Fput
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN31@Fput:

; 1121 : 		const string _Grouping = _Punct_fac.grouping();

	lea	esi, DWORD PTR __Grouping$[esp+136]
	mov	ecx, edi
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	esi, 1
	mov	DWORD PTR __$EHRec$[esp+144], esi

; 1122 : 		const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+8]
	mov	ecx, edi
	call	edx

; 1123 : 		string _Groupstring;

	xor	ecx, ecx
	mov	BYTE PTR __Kseparator$[esp+136], al
	mov	DWORD PTR __Groupstring$[esp+160], 15	; 0000000fH
	mov	DWORD PTR __Groupstring$[esp+156], ecx
	mov	BYTE PTR __Groupstring$[esp+140], cl
	mov	BYTE PTR __$EHRec$[esp+144], 2

; 1124 : 		const _Elem _E0 = _MAKLOCCHR(_Elem, '0', _Cvt);
; 1125 : 		size_t _Prefix = _Buf[0] == '+' || _Buf[0] == '-' ? 1 : 0;

	mov	al, BYTE PTR [ebp]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN19@Fput
	cmp	al, 45					; 0000002dH
	mov	DWORD PTR __Prefix$[esp+136], ecx
	jne	SHORT $LN20@Fput
$LN19@Fput:
	mov	DWORD PTR __Prefix$[esp+136], esi
$LN20@Fput:

; 1126 : 
; 1127 : 		char _Enders[3];
; 1128 : 		_Enders[0] = ::localeconv()->decimal_point[0];

	call	_localeconv
	mov	eax, DWORD PTR [eax]

; 1129 : 		_Enders[1] = 'e';
; 1130 : 		_Enders[2] = '\0';
; 1131 : 
; 1132 : 		const char *_Eptr = (const char *)::memchr(_Buf,
; 1133 : 			'e', _Count);	// find exponent

	mov	ebx, DWORD PTR __Count$[esp+132]
	mov	cl, BYTE PTR [eax]
	push	ebx
	push	101					; 00000065H
	push	ebp
	mov	BYTE PTR __Enders$[esp+148], cl
	mov	BYTE PTR __Enders$[esp+149], 101	; 00000065H
	mov	BYTE PTR __Enders$[esp+150], 0
	call	_memchr

; 1134 : 		const char *_Pointptr = (const char *)::memchr(_Buf,
; 1135 : 			_Enders[0], _Count);	// find decimal point

	movsx	edx, BYTE PTR __Enders$[esp+148]
	add	esp, 12					; 0000000cH
	push	ebx
	push	edx
	mov	esi, eax
	push	ebp
	mov	DWORD PTR __Eptr$[esp+148], esi
	call	_memchr
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1136 : 		if (_Pointptr == 0)

	test	edi, edi
	jne	SHORT $LN16@Fput

; 1137 : 			_Trailing = 0;

	mov	DWORD PTR __Trailing$[esp+132], eax
$LN16@Fput:

; 1138 : 
; 1139 : 		if (*_Grouping.c_str() != CHAR_MAX && '\0' < *_Grouping.c_str())

	mov	ecx, DWORD PTR __Grouping$[esp+160]
	cmp	ecx, 16					; 00000010H
	mov	edx, DWORD PTR __Grouping$[esp+140]
	mov	eax, edx
	jae	SHORT $LN78@Fput
	lea	eax, DWORD PTR __Grouping$[esp+140]
$LN78@Fput:
	cmp	BYTE PTR [eax], 127			; 0000007fH
	je	$LN105@Fput
	cmp	ecx, 16					; 00000010H
	mov	eax, edx
	jae	SHORT $LN84@Fput
	lea	eax, DWORD PTR __Grouping$[esp+140]
$LN84@Fput:
	cmp	BYTE PTR [eax], 0
	jle	$LN105@Fput

; 1140 : 			{	// grouping specified, add thousands separators
; 1141 : 			_Groupstring.append(_Buf, _Count);	// assemble field into string

	push	ebx
	push	ebp
	lea	eax, DWORD PTR __Groupstring$[esp+144]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1142 : 			if (_Eptr == 0)

	test	esi, esi
	jne	SHORT $LN14@Fput

; 1143 : 				_Groupstring.append(_Trailing, '0');

	mov	ebx, DWORD PTR __Trailing$[esp+132]
	push	48					; 00000030H
	lea	esi, DWORD PTR __Groupstring$[esp+140]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1144 : 			else

	jmp	SHORT $LN13@Fput
$LN14@Fput:

; 1145 : 				{	/* dispose of any zeros before exponent */
; 1146 : 				if (_Pointptr == 0)

	test	edi, edi
	jne	SHORT $LN12@Fput

; 1147 : 					{	/* no point but exponent, put scaling zeros */
; 1148 : 					_Groupstring.append(_Beforepoint, '0');

	mov	ebx, DWORD PTR __Beforepoint$[esp+132]
	push	48					; 00000030H
	lea	esi, DWORD PTR __Groupstring$[esp+140]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1149 : 					_Beforepoint = 0;

	mov	esi, DWORD PTR __Eptr$[esp+136]
	mov	DWORD PTR __Beforepoint$[esp+132], edi
$LN12@Fput:

; 1150 : 					}
; 1151 : 				_Groupstring.insert(_Eptr - _Buf, _Trailing, '0');

	mov	eax, DWORD PTR __Trailing$[esp+132]
	push	48					; 00000030H
	mov	ebx, esi
	push	eax
	sub	ebx, ebp
	lea	esi, DWORD PTR __Groupstring$[esp+144]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
$LN13@Fput:

; 1152 : 				}
; 1153 : 			_Trailing = 0;
; 1154 : 
; 1155 : 			if (_Pointptr == 0)

	test	edi, edi

; 1156 : 				_Groupstring.append(_Beforepoint, '0');

	push	48					; 00000030H
	lea	esi, DWORD PTR __Groupstring$[esp+140]
	jne	SHORT $LN11@Fput
	mov	ebx, DWORD PTR __Beforepoint$[esp+136]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1157 : 			else

	jmp	SHORT $LN10@Fput
$LN11@Fput:

; 1158 : 				{	// fill in zeros around decimal point
; 1159 : 				_Groupstring.insert(_Pointptr - _Buf + 1, _Afterpoint, '0');

	mov	ecx, DWORD PTR __Afterpoint$[esp+136]
	sub	edi, ebp
	push	ecx
	lea	ebx, DWORD PTR [edi+1]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1160 : 				_Groupstring.insert(_Pointptr - _Buf, _Beforepoint, '0');

	mov	edx, DWORD PTR __Beforepoint$[esp+132]
	push	48					; 00000030H
	push	edx
	mov	ebx, edi
	lea	esi, DWORD PTR __Groupstring$[esp+144]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1161 : 				_Afterpoint = 0;

	mov	DWORD PTR __Afterpoint$[esp+132], 0
$LN10@Fput:

; 1162 : 				}
; 1163 : 			_Beforepoint = 0;
; 1164 : 
; 1165 : 			const char *_Pg = _Grouping.c_str();

	mov	ebp, DWORD PTR __Grouping$[esp+140]
	mov	edi, 16					; 00000010H
	cmp	DWORD PTR __Grouping$[esp+160], edi
	mov	DWORD PTR __Beforepoint$[esp+132], 0
	jae	SHORT $LN90@Fput
	lea	ebp, DWORD PTR __Grouping$[esp+140]
$LN90@Fput:

; 1166 : 			size_t _Off = ::strcspn(&_Groupstring[0], &_Enders[0]);

	cmp	DWORD PTR __Groupstring$[esp+160], edi
	mov	eax, DWORD PTR __Groupstring$[esp+140]
	jae	SHORT $LN97@Fput
	lea	eax, DWORD PTR __Groupstring$[esp+140]
$LN97@Fput:
	lea	ecx, DWORD PTR __Enders$[esp+136]
	push	ecx
	push	eax
	call	_strcspn
	mov	ebx, eax

; 1167 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1168 : 				&& (size_t)*_Pg < _Off - _Prefix)

	mov	al, BYTE PTR [ebp]
	add	esp, 8
	cmp	al, 127					; 0000007fH
	je	SHORT $LN8@Fput
$LN9@Fput:
	test	al, al
	jle	SHORT $LN8@Fput
	mov	edx, ebx
	sub	edx, DWORD PTR __Prefix$[esp+136]
	movsx	eax, al
	cmp	eax, edx
	jae	SHORT $LN8@Fput

; 1169 : 				{	// add a NUL to mark thousands separator
; 1170 : 				_Groupstring.insert(_Off -= *_Pg, (size_t)1, '\0');

	push	0
	sub	ebx, eax
	push	1
	lea	esi, DWORD PTR __Groupstring$[esp+144]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1171 : 				if ('\0' < _Pg[1])

	cmp	BYTE PTR [ebp+1], 0
	jle	SHORT $LN7@Fput

; 1167 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1168 : 				&& (size_t)*_Pg < _Off - _Prefix)

	add	ebp, 1
$LN7@Fput:
	mov	al, BYTE PTR [ebp]
	cmp	al, 127					; 0000007fH
	jne	SHORT $LN9@Fput
$LN8@Fput:

; 1172 : 					++_Pg;	// not last group, advance
; 1173 : 				}
; 1174 : 
; 1175 : 			_Buf = &_Groupstring[0];

	cmp	DWORD PTR __Groupstring$[esp+160], edi
	mov	ebp, DWORD PTR __Groupstring$[esp+140]
	jae	SHORT $LN104@Fput
	lea	ebp, DWORD PTR __Groupstring$[esp+140]
$LN104@Fput:

; 1176 : 			_Trailing = 0;
; 1177 : 			_Count = _Groupstring.size();

	mov	eax, DWORD PTR __Groupstring$[esp+156]
	mov	DWORD PTR __Trailing$[esp+132], 0
	mov	DWORD PTR __Count$[esp+132], eax
	mov	ebx, eax
$LN105@Fput:

; 1178 : 			}
; 1179 : 
; 1180 : 		size_t _Fillcount = _Beforepoint + _Afterpoint + _Trailing + _Count;

	mov	ecx, DWORD PTR __Beforepoint$[esp+132]
	mov	edx, DWORD PTR __Afterpoint$[esp+132]
	lea	eax, DWORD PTR [ecx+edx]
	add	eax, DWORD PTR __Trailing$[esp+132]

; 1181 : 		_Fillcount = _Iosbase.width() <= 0
; 1182 : 			|| (size_t)_Iosbase.width() <= _Fillcount
; 1183 : 				? 0 : (size_t)_Iosbase.width() - _Fillcount;

	mov	edx, DWORD PTR __Iosbase$GSCopy$[esp+136]
	mov	ecx, DWORD PTR [edx+24]
	add	eax, ebx
	test	ecx, ecx
	jle	SHORT $LN21@Fput
	cmp	ecx, eax
	jbe	SHORT $LN21@Fput
	sub	ecx, eax
	mov	DWORD PTR __Fillcount$[esp+136], ecx
	jmp	SHORT $LN22@Fput
$LN21@Fput:
	mov	DWORD PTR __Fillcount$[esp+136], 0
$LN22@Fput:

; 1184 : 		ios_base::fmtflags _Adjustfield =
; 1185 : 			_Iosbase.flags() & ios_base::adjustfield;

	mov	eax, DWORD PTR [edx+16]
	and	eax, 448				; 000001c0H

; 1186 : 		if (_Adjustfield != ios_base::left
; 1187 : 			&& _Adjustfield != ios_base::internal)

	cmp	eax, 64					; 00000040H
	je	$LN177@Fput
	cmp	eax, 256				; 00000100H

; 1188 : 			{	// put leading fill
; 1189 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	edx, DWORD PTR __Dest$[esp+136]
	je	SHORT $LN174@Fput
	mov	ecx, DWORD PTR __Dest$[esp+132]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+152]
	mov	DWORD PTR [eax+4], edx
	lea	edx, DWORD PTR $T48282[esp+148]
	mov	DWORD PTR [eax+8], ecx
	push	edx
$LN186@Fput:
	mov	eax, DWORD PTR __Fillcount$[esp+152]
	mov	bl, BYTE PTR __Fill$[esp+148]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	esi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+8]
	add	esp, 16					; 00000010H

; 1190 : 			_Fillcount = 0;

	mov	DWORD PTR __Fillcount$[esp+136], 0
	jmp	$LN4@Fput
$LN174@Fput:

; 1191 : 			}
; 1192 : 		else if (_Adjustfield == ios_base::internal)
; 1193 : 			{	// put internal fill
; 1194 : 			if (0 < _Prefix)

	cmp	DWORD PTR __Prefix$[esp+136], 0
	jbe	SHORT $LN176@Fput

; 1195 : 				{	// but first put sign
; 1196 : 				_Dest = _Putc(_Dest, _Buf, 1);

	mov	ecx, DWORD PTR __Dest$[esp+132]
	push	ebp
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+156]
	mov	DWORD PTR [eax+4], edx
	lea	edx, DWORD PTR $T48283[esp+152]
	mov	DWORD PTR [eax+8], ecx
	push	edx
	mov	eax, 1
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	add	esp, 20					; 00000014H

; 1197 : 				++_Buf, --_Count;

	add	ebp, 1
	sub	ebx, 1
	mov	DWORD PTR __Count$[esp+132], ebx
	jmp	SHORT $LN3@Fput
$LN176@Fput:
	mov	ecx, DWORD PTR __Dest$[esp+140]
	mov	esi, DWORD PTR __Dest$[esp+132]
$LN3@Fput:

; 1198 : 				}
; 1199 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	lea	eax, DWORD PTR $T48284[esp+148]
	push	eax

; 1200 : 			_Fillcount = 0;

	jmp	$LN186@Fput
$LN177@Fput:
	mov	edi, DWORD PTR __Dest$[esp+140]
	mov	ebx, DWORD PTR __Dest$[esp+136]
	mov	esi, DWORD PTR __Dest$[esp+132]
$LN4@Fput:

; 1201 : 			}
; 1202 : 
; 1203 : 		_Pointptr = (const char *)::memchr(_Buf,
; 1204 : 			_Enders[0], _Count);	// find decimal point again

	mov	ecx, DWORD PTR __Count$[esp+132]
	movsx	edx, BYTE PTR __Enders$[esp+136]
	push	ecx
	push	edx
	push	ebp
	call	_memchr
	add	esp, 12					; 0000000cH

; 1205 : 		if (_Pointptr != 0)

	test	eax, eax
	je	$LN2@Fput

; 1206 : 			{	// has decimal point, put pieces and zero fills
; 1207 : 			size_t _Fracoffset = _Pointptr - _Buf + 1;
; 1208 : 			_Dest = _Putgrouped(_Dest, _Buf, _Fracoffset - 1, _Kseparator);

	mov	ecx, DWORD PTR __Kseparator$[esp+136]
	sub	eax, ebp
	add	eax, 1
	mov	DWORD PTR __Fracoffset$21170[esp+136], eax
	push	ecx
	add	eax, -1
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ebx
	lea	edx, DWORD PTR $T48285[esp+156]
	mov	DWORD PTR [eax+8], edi
	push	edx
	mov	eax, ebp
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped

; 1209 : 			_Dest = _Rep(_Dest, _E0, _Beforepoint);

	mov	edx, DWORD PTR [eax]
	add	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Beforepoint$[esp+144]
	lea	ecx, DWORD PTR $T48286[esp+148]
	push	ecx
	mov	bl, 48					; 00000030H
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep

; 1210 : 			_Dest = _Rep(_Dest, _Punct_fac.decimal_point(), 1);

	mov	ecx, DWORD PTR __Punct_fac$[esp+152]
	mov	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edx+4]
	add	esp, 16					; 00000010H
	call	eax
	mov	cl, al
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], ebx
	lea	edx, DWORD PTR $T48287[esp+148]
	push	edx
	mov	eax, 1
	mov	bl, cl
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep

; 1211 : 			_Dest = _Rep(_Dest, _E0, _Afterpoint);

	mov	edx, DWORD PTR [eax]
	add	esp, 4
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Afterpoint$[esp+144]
	lea	ecx, DWORD PTR $T48288[esp+148]
	push	ecx
	mov	bl, 48					; 00000030H
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	esi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+8]

; 1212 : 			_Buf += _Fracoffset, _Count -= _Fracoffset;

	mov	eax, DWORD PTR __Fracoffset$21170[esp+152]
	add	esp, 16					; 00000010H
	add	ebp, eax
	sub	DWORD PTR __Count$[esp+132], eax
$LN2@Fput:

; 1213 : 			}
; 1214 : 
; 1215 : 		_Eptr = (const char *)::memchr(_Buf,
; 1216 : 			'e', _Count);	// find exponent again

	mov	edx, DWORD PTR __Count$[esp+132]
	push	edx
	push	101					; 00000065H
	push	ebp
	call	_memchr
	add	esp, 12					; 0000000cH

; 1217 : 		if (_Eptr != 0)

	test	eax, eax
	je	$LN1@Fput

; 1218 : 			{	// has exponent field, put it out
; 1219 : 			size_t _Expoffset = _Eptr - _Buf + 1;
; 1220 : 			_Dest = _Putgrouped(_Dest, _Buf, _Expoffset - 1, _Kseparator);

	mov	ecx, DWORD PTR __Kseparator$[esp+136]
	sub	eax, ebp
	add	eax, 1
	mov	DWORD PTR __Expoffset$21177[esp+136], eax
	push	ecx
	add	eax, -1
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ebx
	lea	edx, DWORD PTR $T48289[esp+156]
	mov	DWORD PTR [eax+8], edi
	push	edx
	mov	eax, ebp
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped

; 1221 : 			_Dest = _Rep(_Dest, _E0, _Trailing), _Trailing = 0;

	mov	edx, DWORD PTR [eax]
	add	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Trailing$[esp+144]
	lea	ecx, DWORD PTR $T48290[esp+148]
	push	ecx
	mov	bl, 48					; 00000030H
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep

; 1222 : 			_Dest = _Putc(_Dest, _Iosbase.flags() & ios_base::uppercase
; 1223 : 				? "E" : "e", 1);

	mov	edx, DWORD PTR __Iosbase$GSCopy$[esp+152]
	add	esp, 16					; 00000010H
	test	BYTE PTR [edx+16], 4
	mov	DWORD PTR __Trailing$[esp+132], 0
	mov	ecx, OFFSET ??_C@_01DDCIFGEA@E?$AA@
	jne	SHORT $LN24@Fput
	mov	ecx, OFFSET ??_C@_01KGKMHCOC@e?$AA@
$LN24@Fput:
	mov	edx, DWORD PTR [eax]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR $T48293[esp+152]
	push	ecx
	mov	eax, 1
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
	mov	esi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+8]

; 1224 : 			_Buf += _Expoffset, _Count -= _Expoffset;

	mov	eax, DWORD PTR __Expoffset$21177[esp+156]
	add	esp, 20					; 00000014H
	add	ebp, eax
	sub	DWORD PTR __Count$[esp+132], eax
$LN1@Fput:

; 1225 : 			}
; 1226 : 
; 1227 : 		_Dest = _Putgrouped(_Dest, _Buf, _Count,
; 1228 : 			_Kseparator);	// put leftover field

	mov	edx, DWORD PTR __Kseparator$[esp+136]
	mov	eax, DWORD PTR __Count$[esp+132]
	push	edx
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ebx
	lea	ecx, DWORD PTR $T48294[esp+156]
	mov	DWORD PTR [eax+8], edi
	push	ecx
	mov	eax, ebp
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped

; 1229 : 		_Dest = _Rep(_Dest, _E0, _Trailing);	// put trailing zeros

	mov	edx, DWORD PTR [eax]
	add	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Trailing$[esp+144]
	lea	ecx, DWORD PTR $T48295[esp+148]
	push	ecx
	mov	bl, 48					; 00000030H
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	esi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]

; 1230 : 		_Iosbase.width(0);

	mov	ecx, DWORD PTR __Iosbase$GSCopy$[esp+152]

; 1231 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	bl, BYTE PTR __Fill$[esp+148]
	add	esp, 4
	mov	DWORD PTR [ecx+24], 0
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+144]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Fillcount$[esp+148]
	push	esi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	edi, 16					; 00000010H
	add	esp, 16					; 00000010H
	cmp	DWORD PTR __Groupstring$[esp+160], edi
	jb	SHORT $LN137@Fput
	mov	edx, DWORD PTR __Groupstring$[esp+140]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN137@Fput:
	xor	eax, eax
	cmp	DWORD PTR __Grouping$[esp+160], edi
	mov	DWORD PTR __Groupstring$[esp+160], 15	; 0000000fH
	mov	DWORD PTR __Groupstring$[esp+156], eax
	mov	BYTE PTR __Groupstring$[esp+140], al
	jb	SHORT $LN175@Fput
	mov	eax, DWORD PTR __Grouping$[esp+140]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN175@Fput:
	mov	eax, esi

; 1232 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+136]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+116]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 116				; 00000074H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$0:
	lea	ecx, DWORD PTR $T48277[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$1:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$2:
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-120]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1084 : 		{	// put formatted void pointer to _Dest

	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+68], eax
	mov	eax, DWORD PTR __Val$[esp+64]
	push	esi

; 1085 : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 1086 : 		char _Buf[_Buf_size];
; 1087 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 1088 : 			::sprintf_s(_Buf, _Buf_size, "%p", _Val)));

	push	eax
	push	OFFSET ??_C@_02BBAHNLBA@?$CFp?$AA@
	lea	eax, DWORD PTR __Buf$[esp+80]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	mov	edx, DWORD PTR __Fill$[esp+84]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+84]
	add	esp, 16					; 00000010H
	push	eax
	mov	eax, DWORD PTR __Iosbase$[esp+72]
	lea	ecx, DWORD PTR __Buf$[esp+76]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+76]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+84]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+104]
	mov	DWORD PTR [eax+4], edx
	push	esi
	mov	DWORD PTR [eax+8], ecx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1089 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+104]
	add	esp, 32					; 00000020H
	mov	eax, esi
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 68					; 00000044H
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__real@38aa95a5b7f87a0f
PUBLIC	__real@4202a05f20000000
PUBLIC	__real@4733426172c74d82
PUBLIC	__Iosbase$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT __real@38aa95a5b7f87a0f
CONST	SEGMENT
__real@38aa95a5b7f87a0f DQ 038aa95a5b7f87a0fr	; 1e-035
CONST	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+010
CONST	ENDS
;	COMDAT __real@4733426172c74d82
CONST	SEGMENT
__real@4733426172c74d82 DQ 04733426172c74d82r	; 1e+035
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT
__Signed$20897 = -133					; size = 1
__Iosbase$GSCopy$ = -132				; size = 4
__Fmt$ = -128						; size = 8
__Buf$ = -120						; size = 108
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1043 : 		{	// put formatted long double to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+180], eax
	mov	eax, DWORD PTR __Iosbase$[ebp]

; 1044 : 		const size_t _Buf_size = _MAX_EXP_DIG + _MAX_SIG_DIG + 64;
; 1045 : 		char _Buf[_Buf_size], _Fmt[8];
; 1046 : 		streamsize _Precision = _Iosbase.precision() <= 0
; 1047 : 			&& !(_Iosbase.flags() & ios_base::fixed)
; 1048 : 				? 6 : _Iosbase.precision();	// desired precision

	mov	ecx, DWORD PTR [eax+20]
	test	ecx, ecx
	push	ebx
	push	esi
	push	edi

; 1074 : 			}
; 1075 : 
; 1076 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1077 : 			_Beforepoint, _Afterpoint, _Precision,
; 1078 : 				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 'L', _Iosbase.flags()),
; 1079 : 					_Significance, _Val)));	// convert and put

	mov	DWORD PTR __Iosbase$GSCopy$[esp+192], eax
	jg	SHORT $LN13@do_put

; 1044 : 		const size_t _Buf_size = _MAX_EXP_DIG + _MAX_SIG_DIG + 64;
; 1045 : 		char _Buf[_Buf_size], _Fmt[8];
; 1046 : 		streamsize _Precision = _Iosbase.precision() <= 0
; 1047 : 			&& !(_Iosbase.flags() & ios_base::fixed)
; 1048 : 				? 6 : _Iosbase.precision();	// desired precision

	test	DWORD PTR [eax+16], 8192		; 00002000H
	jne	SHORT $LN13@do_put
	mov	ecx, 6
$LN13@do_put:
	mov	esi, ecx

; 1049 : 		int _Significance = _MAX_SIG_DIG < _Precision
; 1050 : 			? _MAX_SIG_DIG : (int)_Precision;	// actual sprintf precision

	cmp	esi, 36					; 00000024H
	mov	edx, 36					; 00000024H
	jg	SHORT $LN16@do_put
	mov	edx, esi
$LN16@do_put:

; 1051 : 		_Precision -= _Significance;
; 1052 : 		size_t _Beforepoint = 0;	// zeros to add before decimal point
; 1053 : 		size_t _Afterpoint = 0;	// zeros to add after decimal point
; 1054 : 
; 1055 : 		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)

	mov	ecx, DWORD PTR [eax+16]
	mov	eax, ecx
	and	eax, 12288				; 00003000H
	sub	esi, edx
	xor	ebx, ebx
	xor	edi, edi
	cmp	eax, 8192				; 00002000H
	jne	$LN41@do_put

; 1056 : 			{	// scale silly fixed-point value
; 1057 : 			bool _Signed = _Val < 0;

	fldz
	fld	QWORD PTR __Val$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN17@do_put
	mov	BYTE PTR __Signed$20897[esp+192], 1

; 1059 : 				_Val = -_Val;

	fchs
$LN9@do_put:

; 1060 : 
; 1061 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	fld	QWORD PTR __real@4733426172c74d82
	fcom	ST(1)
	fnstsw	ax
	fld	QWORD PTR __real@4202a05f20000000
	test	ah, 65					; 00000041H
	jnp	SHORT $LN8@do_put
$LN47@do_put:
	fstp	ST(1)
	jmp	SHORT $LN6@do_put
$LN17@do_put:

; 1056 : 			{	// scale silly fixed-point value
; 1057 : 			bool _Signed = _Val < 0;

	mov	BYTE PTR __Signed$20897[esp+192], bl

; 1058 : 			if (_Signed)

	jmp	SHORT $LN9@do_put
$LN53@do_put:

; 1060 : 
; 1061 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	fxch	ST(1)
$LN8@do_put:
	cmp	ebx, 5000				; 00001388H
	jae	SHORT $LN47@do_put

; 1062 : 				_Val /= 1e10;	// drop 10 zeros before decimal point

	fdiv	ST(2), ST(0)
	add	ebx, 10					; 0000000aH
	fxch	ST(1)
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN53@do_put

; 1060 : 
; 1061 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	fstp	ST(0)
$LN6@do_put:

; 1063 : 
; 1064 : 			if (0 < _Val)

	fxch	ST(2)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN55@do_put

; 1065 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1066 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	cmp	esi, 10					; 0000000aH
	jl	SHORT $LN55@do_put
	fld	QWORD PTR __real@38aa95a5b7f87a0f
	jmp	SHORT $LN4@do_put
$LN68@do_put:
	fxch	ST(1)
$LN4@do_put:
	fcom	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN62@do_put
	cmp	edi, 5000				; 00001388H
	jae	SHORT $LN62@do_put

; 1067 : 					{	// drop 10 zeros after decimal point
; 1068 : 					_Val *= 1e10;
; 1069 : 					_Precision -= 10;

	sub	esi, 10					; 0000000aH
	fxch	ST(1)
	add	edi, 10					; 0000000aH
	fmul	ST(0), ST(2)
	cmp	esi, 10					; 0000000aH
	jge	SHORT $LN68@do_put

; 1065 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1066 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	fstp	ST(1)
$LN55@do_put:

; 1070 : 					}
; 1071 : 
; 1072 : 			if (_Signed)

	cmp	BYTE PTR __Signed$20897[esp+192], 0
	fstp	ST(1)
	je	SHORT $LN1@do_put

; 1073 : 				_Val = -_Val;

	fchs
	jmp	SHORT $LN1@do_put
$LN62@do_put:

; 1065 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1066 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	fstp	ST(0)
	jmp	SHORT $LN55@do_put
$LN41@do_put:

; 1073 : 				_Val = -_Val;

	fld	QWORD PTR __Val$[ebp]
$LN1@do_put:

; 1074 : 			}
; 1075 : 
; 1076 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1077 : 			_Beforepoint, _Afterpoint, _Precision,
; 1078 : 				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 'L', _Iosbase.flags()),
; 1079 : 					_Significance, _Val)));	// convert and put

	test	cl, 32					; 00000020H
	mov	BYTE PTR __Fmt$[esp+192], 37		; 00000025H
	lea	eax, DWORD PTR __Fmt$[esp+193]
	je	SHORT $LN31@do_put
	mov	BYTE PTR __Fmt$[esp+193], 43		; 0000002bH
	lea	eax, DWORD PTR __Fmt$[esp+194]
$LN31@do_put:
	test	cl, 16					; 00000010H
	je	SHORT $LN30@do_put
	mov	BYTE PTR [eax], 35			; 00000023H
	add	eax, 1
$LN30@do_put:
	mov	BYTE PTR [eax], 46			; 0000002eH
	add	eax, 1
	mov	BYTE PTR [eax], 42			; 0000002aH
	add	eax, 1
	mov	BYTE PTR [eax], 76			; 0000004cH
	and	ecx, 12288				; 00003000H
	add	eax, 1
	cmp	ecx, 8192				; 00002000H
	jne	SHORT $LN34@do_put
	mov	cl, 102					; 00000066H
	jmp	SHORT $LN35@do_put
$LN34@do_put:
	cmp	ecx, 4096				; 00001000H
	setne	cl
	lea	ecx, DWORD PTR [ecx+ecx+101]
$LN35@do_put:
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	mov	BYTE PTR [eax], cl
	lea	ecx, DWORD PTR __Fmt$[esp+204]
	push	ecx
	lea	edx, DWORD PTR __Buf$[esp+208]
	push	108					; 0000006cH
	push	edx
	mov	BYTE PTR [eax+1], 0
	call	_sprintf_s
	mov	ecx, DWORD PTR __Fill$[ebp]
	mov	edx, DWORD PTR __Iosbase$GSCopy$[esp+216]
	add	esp, 24					; 00000018H
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi
	push	ebx
	lea	eax, DWORD PTR __Buf$[esp+208]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[ebp+8]
	mov	DWORD PTR [eax+4], edx
	push	esi
	mov	DWORD PTR [eax+8], ecx
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput

; 1080 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+236]
	add	esp, 44					; 0000002cH
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__Iosbase$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
__Signed$20869 = -133					; size = 1
__Iosbase$GSCopy$ = -132				; size = 4
__Fmt$ = -128						; size = 8
__Buf$ = -120						; size = 108
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1002 : 		{	// put formatted double to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+180], eax
	mov	eax, DWORD PTR __Iosbase$[ebp]

; 1003 : 		const size_t _Buf_size = _MAX_EXP_DIG + _MAX_SIG_DIG + 64;
; 1004 : 		char _Buf[_Buf_size], _Fmt[8];
; 1005 : 		streamsize _Precision = _Iosbase.precision() <= 0
; 1006 : 			&& !(_Iosbase.flags() & ios_base::fixed)
; 1007 : 				? 6 : _Iosbase.precision();	// desired precision

	mov	ecx, DWORD PTR [eax+20]
	test	ecx, ecx
	push	ebx
	push	esi
	push	edi

; 1033 : 			}
; 1034 : 
; 1035 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1036 : 			_Beforepoint, _Afterpoint, _Precision,
; 1037 : 				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 0, _Iosbase.flags()),
; 1038 : 					_Significance, _Val)));	// convert and put

	mov	DWORD PTR __Iosbase$GSCopy$[esp+192], eax
	jg	SHORT $LN13@do_put@2

; 1003 : 		const size_t _Buf_size = _MAX_EXP_DIG + _MAX_SIG_DIG + 64;
; 1004 : 		char _Buf[_Buf_size], _Fmt[8];
; 1005 : 		streamsize _Precision = _Iosbase.precision() <= 0
; 1006 : 			&& !(_Iosbase.flags() & ios_base::fixed)
; 1007 : 				? 6 : _Iosbase.precision();	// desired precision

	test	DWORD PTR [eax+16], 8192		; 00002000H
	jne	SHORT $LN13@do_put@2
	mov	ecx, 6
$LN13@do_put@2:
	mov	esi, ecx

; 1008 : 		int _Significance = _MAX_SIG_DIG < _Precision
; 1009 : 			? _MAX_SIG_DIG : (int)_Precision;	// actual sprintf precision

	cmp	esi, 36					; 00000024H
	mov	edx, 36					; 00000024H
	jg	SHORT $LN16@do_put@2
	mov	edx, esi
$LN16@do_put@2:

; 1010 : 		_Precision -= _Significance;
; 1011 : 		size_t _Beforepoint = 0;	// zeros to add before decimal point
; 1012 : 		size_t _Afterpoint = 0;	// zeros to add after decimal point
; 1013 : 
; 1014 : 		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)

	mov	ecx, DWORD PTR [eax+16]
	mov	eax, ecx
	and	eax, 12288				; 00003000H
	sub	esi, edx
	xor	ebx, ebx
	xor	edi, edi
	cmp	eax, 8192				; 00002000H
	jne	$LN41@do_put@2

; 1015 : 			{	// scale silly fixed-point value
; 1016 : 			bool _Signed = _Val < 0;

	fldz
	fld	QWORD PTR __Val$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN17@do_put@2
	mov	BYTE PTR __Signed$20869[esp+192], 1

; 1018 : 				_Val = -_Val;

	fchs
$LN9@do_put@2:

; 1019 : 
; 1020 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	fld	QWORD PTR __real@4733426172c74d82
	fcom	ST(1)
	fnstsw	ax
	fld	QWORD PTR __real@4202a05f20000000
	test	ah, 65					; 00000041H
	jnp	SHORT $LN8@do_put@2
$LN47@do_put@2:
	fstp	ST(1)
	jmp	SHORT $LN6@do_put@2
$LN17@do_put@2:

; 1015 : 			{	// scale silly fixed-point value
; 1016 : 			bool _Signed = _Val < 0;

	mov	BYTE PTR __Signed$20869[esp+192], bl

; 1017 : 			if (_Signed)

	jmp	SHORT $LN9@do_put@2
$LN53@do_put@2:

; 1019 : 
; 1020 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	fxch	ST(1)
$LN8@do_put@2:
	cmp	ebx, 5000				; 00001388H
	jae	SHORT $LN47@do_put@2

; 1021 : 				_Val /= 1e10;	// drop 10 zeros before decimal point

	fdiv	ST(2), ST(0)
	add	ebx, 10					; 0000000aH
	fxch	ST(1)
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN53@do_put@2

; 1019 : 
; 1020 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	fstp	ST(0)
$LN6@do_put@2:

; 1022 : 
; 1023 : 			if (0 < _Val)

	fxch	ST(2)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN55@do_put@2

; 1024 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1025 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	cmp	esi, 10					; 0000000aH
	jl	SHORT $LN55@do_put@2
	fld	QWORD PTR __real@38aa95a5b7f87a0f
	jmp	SHORT $LN4@do_put@2
$LN68@do_put@2:
	fxch	ST(1)
$LN4@do_put@2:
	fcom	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN62@do_put@2
	cmp	edi, 5000				; 00001388H
	jae	SHORT $LN62@do_put@2

; 1026 : 					{	// drop 10 zeros after decimal point
; 1027 : 					_Val *= 1e10;
; 1028 : 					_Precision -= 10;

	sub	esi, 10					; 0000000aH
	fxch	ST(1)
	add	edi, 10					; 0000000aH
	fmul	ST(0), ST(2)
	cmp	esi, 10					; 0000000aH
	jge	SHORT $LN68@do_put@2

; 1024 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1025 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	fstp	ST(1)
$LN55@do_put@2:

; 1029 : 					}
; 1030 : 
; 1031 : 			if (_Signed)

	cmp	BYTE PTR __Signed$20869[esp+192], 0
	fstp	ST(1)
	je	SHORT $LN1@do_put@2

; 1032 : 				_Val = -_Val;

	fchs
	jmp	SHORT $LN1@do_put@2
$LN62@do_put@2:

; 1024 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1025 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	fstp	ST(0)
	jmp	SHORT $LN55@do_put@2
$LN41@do_put@2:

; 1032 : 				_Val = -_Val;

	fld	QWORD PTR __Val$[ebp]
$LN1@do_put@2:

; 1033 : 			}
; 1034 : 
; 1035 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1036 : 			_Beforepoint, _Afterpoint, _Precision,
; 1037 : 				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 0, _Iosbase.flags()),
; 1038 : 					_Significance, _Val)));	// convert and put

	test	cl, 32					; 00000020H
	mov	BYTE PTR __Fmt$[esp+192], 37		; 00000025H
	lea	eax, DWORD PTR __Fmt$[esp+193]
	je	SHORT $LN31@do_put@2
	mov	BYTE PTR __Fmt$[esp+193], 43		; 0000002bH
	lea	eax, DWORD PTR __Fmt$[esp+194]
$LN31@do_put@2:
	test	cl, 16					; 00000010H
	je	SHORT $LN30@do_put@2
	mov	BYTE PTR [eax], 35			; 00000023H
	add	eax, 1
$LN30@do_put@2:
	mov	BYTE PTR [eax], 46			; 0000002eH
	add	eax, 1
	mov	BYTE PTR [eax], 42			; 0000002aH
	and	ecx, 12288				; 00003000H
	add	eax, 1
	cmp	ecx, 8192				; 00002000H
	jne	SHORT $LN34@do_put@2
	mov	cl, 102					; 00000066H
	jmp	SHORT $LN35@do_put@2
$LN34@do_put@2:
	cmp	ecx, 4096				; 00001000H
	setne	cl
	lea	ecx, DWORD PTR [ecx+ecx+101]
$LN35@do_put@2:
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	mov	BYTE PTR [eax], cl
	lea	ecx, DWORD PTR __Fmt$[esp+204]
	push	ecx
	lea	edx, DWORD PTR __Buf$[esp+208]
	push	108					; 0000006cH
	push	edx
	mov	BYTE PTR [eax+1], 0
	call	_sprintf_s
	mov	ecx, DWORD PTR __Fill$[ebp]
	mov	edx, DWORD PTR __Iosbase$GSCopy$[esp+216]
	add	esp, 24					; 00000018H
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi
	push	ebx
	lea	eax, DWORD PTR __Buf$[esp+208]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[ebp+8]
	mov	DWORD PTR [eax+4], edx
	push	esi
	mov	DWORD PTR [eax+8], ecx
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput

; 1039 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+236]
	add	esp, 44					; 0000002cH
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
__Fmt$ = -80						; size = 8
__Buf$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 991  : 		{	// put formatted unsigned long long to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+80], eax

; 992  : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 993  : 		char _Buf[_Buf_size], _Fmt[8];
; 994  : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 995  : 			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "Lu",
; 996  : 				_Iosbase.flags()), _Val)));

	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	ecx, DWORD PTR __Val$[ebp]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[ebp]
	mov	edx, DWORD PTR [esi+16]
	push	edi
	push	eax
	push	ecx
	mov	edi, OFFSET ??_C@_02CLHGNPPK@Lu?$AA@
	lea	eax, DWORD PTR __Fmt$[esp+96]
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	push	eax
	lea	edx, DWORD PTR __Buf$[esp+100]
	push	64					; 00000040H
	push	edx
	call	_sprintf_s
	mov	ecx, DWORD PTR __Fill$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	add	esp, 20					; 00000014H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+92]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Dest$[ebp+8]
	mov	DWORD PTR [eax+4], ecx
	push	esi
	mov	DWORD PTR [eax+8], edx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 997  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+120]
	add	esp, 32					; 00000020H
	pop	edi
	mov	eax, esi
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
__Fmt$ = -80						; size = 8
__Buf$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 981  : 		{	// put formatted long long to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+80], eax

; 982  : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 983  : 		char _Buf[_Buf_size], _Fmt[8];
; 984  : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 985  : 			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "Ld",
; 986  : 				_Iosbase.flags()), _Val)));

	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	ecx, DWORD PTR __Val$[ebp]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[ebp]
	mov	edx, DWORD PTR [esi+16]
	push	edi
	push	eax
	push	ecx
	mov	edi, OFFSET ??_C@_02HIKPPMOK@Ld?$AA@
	lea	eax, DWORD PTR __Fmt$[esp+96]
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	push	eax
	lea	edx, DWORD PTR __Buf$[esp+100]
	push	64					; 00000040H
	push	edx
	call	_sprintf_s
	mov	ecx, DWORD PTR __Fill$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	add	esp, 20					; 00000014H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+92]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Dest$[ebp+8]
	mov	DWORD PTR [eax+4], ecx
	push	esi
	mov	DWORD PTR [eax+8], edx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 987  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+120]
	add	esp, 32					; 00000020H
	pop	edi
	mov	eax, esi
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
__Fmt$ = -76						; size = 6
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 970  : 		{	// put formatted unsigned long to _Dest

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax

; 971  : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 972  : 		char _Buf[_Buf_size], _Fmt[6];
; 973  : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 974  : 			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "lu",
; 975  : 				_Iosbase.flags()), _Val)));

	mov	eax, DWORD PTR __Val$[esp+72]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[esp+76]
	mov	edx, DWORD PTR [esi+16]
	push	edi
	push	eax
	mov	edi, OFFSET ??_C@_02BDDLJJBK@lu?$AA@
	lea	eax, DWORD PTR __Fmt$[esp+88]
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	push	eax
	lea	ecx, DWORD PTR __Buf$[esp+92]
	push	64					; 00000040H
	push	ecx
	call	_sprintf_s
	mov	ecx, DWORD PTR __Dest$[esp+96]
	add	esp, 16					; 00000010H
	push	eax
	mov	eax, DWORD PTR __Fill$[esp+84]
	lea	edx, DWORD PTR __Buf$[esp+88]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+92]
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+96]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+116]
	mov	DWORD PTR [eax+4], edx
	push	esi
	mov	DWORD PTR [eax+8], ecx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 976  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+116]
	add	esp, 32					; 00000020H
	pop	edi
	mov	eax, esi
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
__Fmt$ = -76						; size = 6
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 960  : 		{	// put formatted long to _Dest

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax

; 961  : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 962  : 		char _Buf[_Buf_size], _Fmt[6];
; 963  : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 964  : 			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "ld",
; 965  : 				_Iosbase.flags()), _Val)));

	mov	eax, DWORD PTR __Val$[esp+72]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[esp+76]
	mov	edx, DWORD PTR [esi+16]
	push	edi
	push	eax
	mov	edi, OFFSET ??_C@_02EAOCLKAK@ld?$AA@
	lea	eax, DWORD PTR __Fmt$[esp+88]
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	push	eax
	lea	ecx, DWORD PTR __Buf$[esp+92]
	push	64					; 00000040H
	push	ecx
	call	_sprintf_s
	mov	ecx, DWORD PTR __Dest$[esp+96]
	add	esp, 16					; 00000010H
	push	eax
	mov	eax, DWORD PTR __Fill$[esp+84]
	lea	edx, DWORD PTR __Buf$[esp+88]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+92]
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+96]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+116]
	mov	DWORD PTR [eax+4], edx
	push	esi
	mov	DWORD PTR [eax+8], ecx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 966  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+116]
	add	esp, 32					; 00000020H
	pop	edi
	mov	eax, esi
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$3
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -96				; size = 4
__Lock$49076 = -92					; size = 4
$T49039 = -88						; size = 4
$T49041 = -84						; size = 28
$T49040 = -84						; size = 28
$T49045 = -56						; size = 12
$T49044 = -56						; size = 12
__Str$20757 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 1
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 930  : 		{	// put formatted bool to _Dest

	push	-1
	push	__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+96], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+116]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR __Iosbase$[esp+112]

; 931  : 		_DEBUG_POINTER(_Dest);
; 932  : 		if (!(_Iosbase.flags() & ios_base::boolalpha))

	test	DWORD PTR [ebp+16], 16384		; 00004000H
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+112]

; 951  : 				}
; 952  : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+116], esi
	jne	SHORT $LN5@do_put@3
	movzx	eax, BYTE PTR __Val$[esp+112]
	mov	edi, DWORD PTR __Dest$[esp+112]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+28]
	push	eax
	mov	eax, DWORD PTR __Fill$[esp+116]
	push	eax
	push	ebp
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR __Dest$[esp+140]
	mov	DWORD PTR [eax+4], edi
	mov	edi, DWORD PTR __Dest$[esp+144]
	push	esi
	mov	DWORD PTR [eax+8], edi
	call	edx
	mov	eax, esi
	jmp	$LN4@do_put@3
$LN5@do_put@3:

; 933  : 			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
; 934  : 		else
; 935  : 			{	// put "false" or "true"
; 936  : 			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	edi, DWORD PTR $T49039[esp+116]
	mov	eax, ebp
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[esp+128], 0
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	DWORD PTR __$EHRec$[esp+128], -1
	mov	edi, DWORD PTR $T49039[esp+120]
	add	esp, 4
	test	edi, edi
	mov	ebx, eax
	je	SHORT $LN19@do_put@3
	push	0
	lea	ecx, DWORD PTR __Lock$49076[esp+120]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN21@do_put@3
	cmp	eax, -1
	jae	SHORT $LN21@do_put@3
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN21@do_put@3:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$49076[esp+116]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN19@do_put@3
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN19@do_put@3:

; 937  : 			_Mystr _Str;

	mov	DWORD PTR __Str$20757[esp+140], 15	; 0000000fH
	mov	DWORD PTR __Str$20757[esp+136], 0
	mov	BYTE PTR __Str$20757[esp+120], 0

; 938  : 			if (_Val)

	cmp	BYTE PTR __Val$[esp+112], 0
	mov	DWORD PTR __$EHRec$[esp+124], 1

; 939  : 				_Str.assign(_Punct_fac.truename());

	lea	esi, DWORD PTR $T49040[esp+116]
	mov	ecx, ebx
	je	SHORT $LN3@do_put@3
	call	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR __Str$20757[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 2
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	BYTE PTR __$EHRec$[esp+124], 1
	cmp	DWORD PTR $T49040[esp+140], 16		; 00000010H
	jb	SHORT $LN103@do_put@3
	mov	eax, DWORD PTR $T49040[esp+120]
	push	eax

; 940  : 			else

	jmp	SHORT $LN166@do_put@3
$LN3@do_put@3:

; 941  : 				_Str.assign(_Punct_fac.falsename());

	call	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR __Str$20757[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 3
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	BYTE PTR __$EHRec$[esp+124], 1
	cmp	DWORD PTR $T49041[esp+140], 16		; 00000010H
	jb	SHORT $LN103@do_put@3
	mov	ecx, DWORD PTR $T49041[esp+120]
	push	ecx
$LN166@do_put@3:
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN103@do_put@3:

; 942  : 
; 943  : 			size_t _Fillcount = _Iosbase.width() <= 0
; 944  : 				|| (size_t)_Iosbase.width() <= _Str.size()
; 945  : 					? 0 : (size_t)_Iosbase.width() - _Str.size();

	mov	esi, DWORD PTR [ebp+24]
	test	esi, esi
	mov	ebx, DWORD PTR __Str$20757[esp+136]
	jle	SHORT $LN8@do_put@3
	cmp	esi, ebx
	jbe	SHORT $LN8@do_put@3
	sub	esi, ebx
	jmp	SHORT $LN9@do_put@3
$LN8@do_put@3:
	xor	esi, esi
$LN9@do_put@3:

; 946  : 
; 947  : 			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)

	mov	edx, DWORD PTR [ebp+16]
	and	edx, 448				; 000001c0H
	cmp	edx, 64					; 00000040H

; 948  : 				{	// put leading fill
; 949  : 				_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	edx, DWORD PTR __Dest$[esp+116]
	je	SHORT $LN161@do_put@3
	mov	ecx, DWORD PTR __Dest$[esp+112]
	mov	bl, BYTE PTR __Fill$[esp+112]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+132]
	mov	DWORD PTR [eax+4], edx
	lea	edx, DWORD PTR $T49044[esp+128]
	mov	DWORD PTR [eax+8], ecx
	push	edx
	mov	eax, esi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	edi, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]

; 950  : 				_Fillcount = 0;

	mov	ebx, DWORD PTR __Str$20757[esp+152]
	add	esp, 16					; 00000010H
	xor	esi, esi
	jmp	SHORT $LN1@do_put@3
$LN161@do_put@3:
	mov	eax, DWORD PTR __Dest$[esp+120]
	mov	edi, DWORD PTR __Dest$[esp+112]
$LN1@do_put@3:

; 951  : 				}
; 952  : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

	cmp	DWORD PTR __Str$20757[esp+140], 16	; 00000010H
	mov	ecx, DWORD PTR __Str$20757[esp+120]
	jae	SHORT $LN132@do_put@3
	lea	ecx, DWORD PTR __Str$20757[esp+120]
$LN132@do_put@3:
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T49045[esp+132]
	push	eax
	mov	eax, ebx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]

; 953  : 			_Iosbase.width(0);
; 954  : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	bl, BYTE PTR __Fill$[esp+132]
	add	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$GSCopy$[esp+128]
	push	ecx
	mov	eax, esi
	mov	DWORD PTR [ebp+24], 0
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 16					; 00000010H
	cmp	DWORD PTR __Str$20757[esp+140], 16	; 00000010H
	jb	SHORT $LN151@do_put@3
	mov	edx, DWORD PTR __Str$20757[esp+120]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN151@do_put@3:
	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$[esp+116]
$LN4@do_put@3:

; 955  : 			}
; 956  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+116]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+96]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 96					; 00000060H
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0:
	lea	ecx, DWORD PTR $T49039[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1:
	lea	ecx, DWORD PTR __Str$20757[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$2:
	lea	ecx, DWORD PTR $T49040[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$3:
	lea	ecx, DWORD PTR $T49041[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-100]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
; Function compile flags: /Ogtpy
; File f:\cygwin\home\charles\gusale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledWriter::writeWithIndent, COMDAT
; _this$ = eax

; 462  : {

	push	ebx
	push	esi
	push	edi
	mov	edi, eax

; 463  :    writeIndent();

	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN3@writeWithI
	lea	ebx, DWORD PTR [eax-1]
	cmp	ebx, DWORD PTR [edi+40]
	lea	esi, DWORD PTR [edi+20]
	jbe	SHORT $LN12@writeWithI
	call	__invalid_parameter_noinfo
$LN12@writeWithI:
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN17@writeWithI
	mov	eax, DWORD PTR [esi+4]
	jmp	SHORT $LN18@writeWithI
$LN17@writeWithI:
	lea	eax, DWORD PTR [esi+4]
$LN18@writeWithI:
	mov	bl, BYTE PTR [eax+ebx]
	cmp	bl, 32					; 00000020H
	je	SHORT $LN19@writeWithI
	cmp	bl, 10					; 0000000aH
	je	SHORT $LN3@writeWithI
	mov	bl, 10					; 0000000aH
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN3@writeWithI:
	lea	esi, DWORD PTR [edi+20]
	push	0
	add	edi, 48					; 00000030H
	push	edi
	or	eax, -1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN19@writeWithI:

; 464  :    document_ += value;

	mov	eax, DWORD PTR _value$[esp+8]
	push	0
	push	eax
	or	eax, -1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	edi
	pop	esi
	pop	ebx

; 465  : }

	ret	4
?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledWriter::writeWithIndent
_TEXT	ENDS
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
; Function compile flags: /Ogtpy
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
_TEXT	SEGMENT
$T49680 = -4						; size = 4
_value$ = 8						; size = 1
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; Json::valueToString, COMDAT
; ___$ReturnUdt$ = esi

; 107  : {

	push	ecx

; 108  :    return value ? "true" : "false";

	cmp	BYTE PTR _value$[esp], 0
	mov	DWORD PTR $T49680[esp+4], 0
	mov	edx, OFFSET ??_C@_04LOAJBDKD@true?$AA@
	jne	SHORT $LN4@valueToStr
	mov	edx, OFFSET ??_C@_05LAPONLG@false?$AA@
$LN4@valueToStr:
	mov	eax, edx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
$LL43@valueToStr:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL43@valueToStr
	sub	eax, edi
	push	eax
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, esi
	pop	edi

; 109  : }

	pop	ecx
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; Json::valueToString
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
; Function compile flags: /Ogtpy
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z
_TEXT	SEGMENT
$T49832 = -44						; size = 4
_buffer$ = -40						; size = 32
__$ArrayPad$ = -8					; size = 4
_value$ = 8						; size = 8
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z PROC ; Json::valueToString, COMDAT
; ___$ReturnUdt$ = esi

; 67   : {

	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+48], eax

; 68   :    char buffer[32];
; 69   : #if defined(_MSC_VER) && defined(__STDC_SECURE_LIB__) // Use secure version with visual studio 2005 to avoid warning. 
; 70   :    sprintf_s(buffer, sizeof(buffer), "%#.16g", value); 

	fld	QWORD PTR _value$[esp+44]
	push	ebx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_06ECBCCLMB@?$CF?$CD?416g?$AA@
	lea	eax, DWORD PTR _buffer$[esp+64]
	push	32					; 00000020H

; 76   :    while(ch > buffer && *ch == '0'){

	xor	ebx, ebx
	push	eax
	mov	DWORD PTR $T49832[esp+72], ebx
	call	_sprintf_s
	lea	eax, DWORD PTR _buffer$[esp+72]
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL164@valueToStr@2:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	cmp	cl, bl
	jne	SHORT $LL164@valueToStr@2
	sub	eax, edx
	cmp	BYTE PTR _buffer$[esp+eax+51], 48	; 00000030H
	lea	eax, DWORD PTR _buffer$[esp+eax+51]
	je	SHORT $LN159@valueToStr@2
	lea	eax, DWORD PTR _buffer$[esp+52]
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	mov	BYTE PTR [esi+4], bl
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL165@valueToStr@2:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	cmp	cl, bl
	jne	SHORT $LL165@valueToStr@2

; 71   : #else	
; 72   :    sprintf(buffer, "%#.16g", value); 
; 73   : #endif
; 74   :    char* ch = buffer + strlen(buffer) - 1;
; 75   :    if (*ch != '0') return buffer; // nothing to truncate, so save time

	jmp	SHORT $LN169@valueToStr@2
$LN159@valueToStr@2:

; 76   :    while(ch > buffer && *ch == '0'){

	lea	edx, DWORD PTR _buffer$[esp+52]
	cmp	eax, edx
	jbe	SHORT $LN8@valueToStr@2
$LL9@valueToStr@2:
	cmp	BYTE PTR [eax], 48			; 00000030H
	jne	SHORT $LN8@valueToStr@2

; 77   :      --ch;

	sub	eax, 1
	lea	ecx, DWORD PTR _buffer$[esp+52]
	cmp	eax, ecx
	ja	SHORT $LL9@valueToStr@2
$LN8@valueToStr@2:

; 78   :    }
; 79   :    char* last_nonzero = ch;
; 80   :    while(ch >= buffer){

	lea	ecx, DWORD PTR _buffer$[esp+52]
	cmp	eax, ecx
	mov	edx, eax
	jb	SHORT $LN6@valueToStr@2
	npad	3
$LL7@valueToStr@2:

; 81   :      switch(*ch){

	mov	cl, BYTE PTR [eax]
	cmp	cl, 46					; 0000002eH
	je	SHORT $LN2@valueToStr@2
	sub	cl, 48					; 00000030H
	cmp	cl, 9
	ja	SHORT $LN161@valueToStr@2

; 82   :      case '0':
; 83   :      case '1':
; 84   :      case '2':
; 85   :      case '3':
; 86   :      case '4':
; 87   :      case '5':
; 88   :      case '6':
; 89   :      case '7':
; 90   :      case '8':
; 91   :      case '9':
; 92   :        --ch;

	sub	eax, 1
	lea	ecx, DWORD PTR _buffer$[esp+52]
	cmp	eax, ecx
	jae	SHORT $LL7@valueToStr@2
$LN6@valueToStr@2:

; 100  :      }
; 101  :    }
; 102  :    return buffer;

	lea	eax, DWORD PTR _buffer$[esp+52]
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	mov	BYTE PTR [esi+4], bl
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL168@valueToStr@2:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	cmp	cl, bl
	jne	SHORT $LL168@valueToStr@2
$LN169@valueToStr@2:
	sub	eax, edx
	push	eax
	lea	ecx, DWORD PTR _buffer$[esp+56]
	push	ecx
$LN170@valueToStr@2:
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 103  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+52]
	pop	ebx
	xor	ecx, esp
	mov	eax, esi
	call	@__security_check_cookie@4
	add	esp, 48					; 00000030H
	ret	0
$LN161@valueToStr@2:

; 98   :      default:
; 99   :        return buffer;

	lea	eax, DWORD PTR _buffer$[esp+52]
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	mov	BYTE PTR [esi+4], bl
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL166@valueToStr@2:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	cmp	cl, bl
	jne	SHORT $LL166@valueToStr@2
	sub	eax, edx
	push	eax
	lea	edx, DWORD PTR _buffer$[esp+56]
	push	edx
	jmp	SHORT $LN170@valueToStr@2
$LN2@valueToStr@2:

; 93   :        continue;
; 94   :      case '.':
; 95   :        // Truncate zeroes to save bytes in output, but keep one.
; 96   :        *(last_nonzero+2) = '\0';

	mov	BYTE PTR [edx+2], bl

; 97   :        return buffer;

	lea	eax, DWORD PTR _buffer$[esp+52]
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	mov	BYTE PTR [esi+4], bl
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL167@valueToStr@2:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	cmp	cl, bl
	jne	SHORT $LL167@valueToStr@2
	sub	eax, edx
	push	eax
	lea	eax, DWORD PTR _buffer$[esp+56]
	push	eax
	jmp	SHORT $LN170@valueToStr@2
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ENDP ; Json::valueToString
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::valueToString
; Function compile flags: /Ogtpy
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
_TEXT	SEGMENT
$T50424 = -40						; size = 4
_buffer$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z PROC ; Json::valueToString, COMDAT
; ___$ReturnUdt$ = edi
; _value$ = ecx

; 58   : {

	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+40], eax
	push	esi

; 59   :    char buffer[32];
; 60   :    char *current = buffer + sizeof(buffer);
; 61   :    uintToString( value, current );

	xor	eax, eax
	mov	DWORD PTR $T50424[esp+44], eax
	lea	esi, DWORD PTR _buffer$[esp+75]
	mov	BYTE PTR _buffer$[esp+75], al
	push	ebx
	npad	2
$LL7@valueToStr@3:
	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 3
	mov	al, dl
	mov	bl, 10					; 0000000aH
	imul	bl
	sub	cl, al
	add	cl, 48					; 00000030H
	sub	esi, 1
	mov	BYTE PTR [esi], cl
	mov	ecx, edx
	test	ecx, ecx
	jne	SHORT $LL7@valueToStr@3

; 62   :    assert( current >= buffer );
; 63   :    return current;

	mov	DWORD PTR [edi+20], edx
	mov	DWORD PTR [edi+24], 15			; 0000000fH
	mov	eax, esi
	mov	BYTE PTR [edi+4], dl
	lea	edx, DWORD PTR [eax+1]
	pop	ebx
$LL47@valueToStr@3:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL47@valueToStr@3
	sub	eax, edx
	push	eax
	push	esi
	mov	ecx, edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 64   : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+44]
	pop	esi
	xor	ecx, esp
	mov	eax, edi
	call	@__security_check_cookie@4
	add	esp, 40					; 00000028H
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ENDP ; Json::valueToString
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::valueToString
; Function compile flags: /Ogtpy
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
_TEXT	SEGMENT
_isNegative$ = -41					; size = 1
$T50585 = -40						; size = 4
_buffer$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC ; Json::valueToString, COMDAT
; ___$ReturnUdt$ = edi
; _value$ = ecx

; 43   : {

	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+44], eax

; 49   :    uintToString( UInt(value), current );

	xor	edx, edx
	cmp	ecx, edx
	setl	al
	cmp	al, dl
	mov	DWORD PTR $T50585[esp+44], edx
	mov	BYTE PTR _isNegative$[esp+44], al
	je	SHORT $LN2@valueToStr@4

; 44   :    char buffer[32];
; 45   :    char *current = buffer + sizeof(buffer);
; 46   :    bool isNegative = value < 0;
; 47   :    if ( isNegative )
; 48   :       value = -value;

	neg	ecx
$LN2@valueToStr@4:
	push	esi

; 49   :    uintToString( UInt(value), current );

	lea	esi, DWORD PTR _buffer$[esp+79]
	mov	BYTE PTR _buffer$[esp+79], dl
	push	ebx
	npad	3
$LL9@valueToStr@4:
	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 3
	mov	al, dl
	mov	bl, 10					; 0000000aH
	imul	bl
	sub	cl, al
	add	cl, 48					; 00000030H
	sub	esi, 1
	mov	BYTE PTR [esi], cl
	mov	ecx, edx
	test	ecx, ecx
	jne	SHORT $LL9@valueToStr@4

; 50   :    if ( isNegative )

	cmp	BYTE PTR _isNegative$[esp+52], dl
	pop	ebx
	je	SHORT $LN1@valueToStr@4

; 51   :       *--current = '-';

	sub	esi, 1
	mov	BYTE PTR [esi], 45			; 0000002dH
$LN1@valueToStr@4:

; 52   :    assert( current >= buffer );
; 53   :    return current;

	mov	eax, esi
	mov	DWORD PTR [edi+24], 15			; 0000000fH
	mov	DWORD PTR [edi+20], 0
	mov	BYTE PTR [edi+4], 0
	lea	edx, DWORD PTR [eax+1]
$LL49@valueToStr@4:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL49@valueToStr@4
	sub	eax, edx
	push	eax
	push	esi
	mov	ecx, edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 54   : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+48]
	pop	esi
	xor	ecx, esp
	mov	eax, edi
	call	@__security_check_cookie@4
	add	esp, 44					; 0000002cH
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; Json::valueToString
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ?clear@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT
?clear@ios_base@std@@QAEXH@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 288  : 		{	// set state to argument

	push	ecx

; 289  : 		clear(_State, false);

	xor	al, al
	mov	DWORD PTR [ecx+8], 0
	je	SHORT $LN9@clear@3
	push	0
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN9@clear@3:
	pop	ecx

; 290  : 		}

	ret	0
?clear@ios_base@std@@QAEXH@Z ENDP			; std::ios_base::clear
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
xdata$x	ENDS
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 137  : 		{	// perform any wrapup

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 138  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 139  : 		if (ios_base::flags() & ios_base::unitbuf)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	test	BYTE PTR [ecx+esi+16], 2
	je	SHORT $LN8@Osfx

; 140  : 			flush();	// flush stream as needed

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN8@Osfx:

; 142  : 		_CATCH_END
; 143  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:

; 141  : 		_CATCH_ALL

	mov	eax, $LN8@Osfx
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 100  : 			{	// destroy the object

	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	mov	DWORD PTR __$EHRec$[esp+32], 0

; 101  : 
; 102  :  #if _HAS_EXCEPTIONS
; 103  : 			if (!_XSTD uncaught_exception())

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN1@sentry

; 104  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN1@sentry:

; 105  : 			}

	mov	DWORD PTR __$EHRec$[esp+32], -1
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN12@sentry
	lea	ecx, DWORD PTR [eax+4]
	call	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
$LN12@sentry:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; __Ostr$ = edi

; 93   : 			{	// construct locking and testing stream

	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR _this$[esp+20]
	mov	DWORD PTR [ebx], edi
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+edi+40]
	test	eax, eax
	je	SHORT $LN12@sentry@2
	lea	ecx, DWORD PTR [eax+4]
	call	?_Lock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Lock
$LN12@sentry@2:
	mov	DWORD PTR __$EHRec$[esp+32], 0

; 94   : 			if (_Ostr.good() && _Ostr.tie() != 0)

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, edi
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN1@sentry@2
	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN1@sentry@2

; 95   : 				_Ostr.tie()->flush();

	mov	esi, eax
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN1@sentry@2:

; 96   : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+edi+8], 0
	sete	al
	mov	BYTE PTR [ebx+4], al

; 97   : 			}

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$11
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
$T53912 = -52						; size = 12
$T53911 = -52						; size = 12
__Ok$ = -40						; size = 8
$T53957 = -32						; size = 1
__Lock$53946 = -32					; size = 4
$T53906 = -28						; size = 4
__State$ = -24						; size = 4
__Nput_fac$19633 = -20					; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Val$ = 12						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT

; 262  : 		{	// insert an int

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR _this$[ebp]

; 263  : 		ios_base::iostate _State = ios_base::goodbit;
; 264  : 		const sentry _Ok(*this);

	lea	eax, DWORD PTR __Ok$[ebp]
	xor	ebx, ebx
	push	eax
	mov	edi, esi
	mov	DWORD PTR __State$[ebp], ebx
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], ebx

; 265  : 
; 266  : 		if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], bl
	je	$LN15@operator@31

; 267  : 			{	// state okay, use facet to insert
; 268  : 			const _Nput& _Nput_fac = _USE(ios_base::getloc(), _Nput);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, esi
	lea	edi, DWORD PTR $T53906[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	ebx, DWORD PTR $T53906[ebp]
	add	esp, 4
	test	ebx, ebx
	mov	DWORD PTR __Nput_fac$19633[ebp], eax
	je	SHORT $LN21@operator@31
	push	0
	lea	ecx, DWORD PTR __Lock$53946[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jbe	SHORT $LN23@operator@31
	cmp	eax, -1
	jae	SHORT $LN23@operator@31
	add	eax, -1
	mov	DWORD PTR [ebx+4], eax
$LN23@operator@31:
	mov	edi, DWORD PTR [ebx+4]
	neg	edi
	sbb	edi, edi
	not	edi
	lea	ecx, DWORD PTR __Lock$53946[ebp]
	and	edi, ebx
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	edi, edi
	je	SHORT $LN21@operator@31
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, edi
	call	eax
$LN21@operator@31:

; 269  : 			ios_base::fmtflags _Bfl =
; 270  : 				ios_base::flags() & ios_base::basefield;

	mov	ecx, DWORD PTR [esi]

; 271  : 			long _Tmp = (_Bfl == ios_base::oct
; 272  : 				|| _Bfl == ios_base::hex)
; 273  : 				? (long)(unsigned int)_Val : (long)_Val;
; 274  : 
; 275  : 			_TRY_IO_BEGIN
; 276  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 277  : 				_Myios::fill(), _Tmp).failed())

	mov	ebx, DWORD PTR __Val$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR [ecx+esi+48]
	mov	edi, DWORD PTR __Nput_fac$19633[ebp]
	mov	edi, DWORD PTR [edi]
	add	ecx, esi
	mov	ecx, DWORD PTR [ecx+40]
	push	ebx
	mov	BYTE PTR $T53957[ebp], dl
	mov	ebx, DWORD PTR $T53957[ebp]
	add	eax, esi
	push	ebx
	push	eax
	xor	edx, edx
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	BYTE PTR $T53911[ebp+4], dl
	mov	edx, DWORD PTR $T53911[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [edi+28]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Nput_fac$19633[ebp]
	lea	eax, DWORD PTR $T53912[ebp]
	push	eax
	call	edx
	cmp	BYTE PTR $T53912[ebp+4], 0

; 278  : 				_State |= ios_base::badbit;

	mov	ebx, 4
	jne	SHORT $LN1@operator@31
	mov	ebx, DWORD PTR __State$[ebp]
$LN1@operator@31:

; 279  : 			_CATCH_IO_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN15@operator@31
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$0:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	or	eax, 4
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN52@operator@31
	or	eax, 4
$LN52@operator@31:
	and	eax, 23					; 00000017H
	test	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+8], eax
	je	SHORT $LN60@operator@31
	push	1
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN60@operator@31:
	mov	eax, $LN98@operator@31
	ret	0
$LN98@operator@31:
	mov	esi, DWORD PTR _this$[ebp]
	mov	ebx, DWORD PTR __State$[ebp]
$LN15@operator@31:

; 280  : 			}
; 281  : 
; 282  : 		_Myios::setstate(_State);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN85@operator@31
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN77@operator@31
	or	eax, 4
$LN77@operator@31:
	and	eax, 23					; 00000017H
	test	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+8], eax
	je	SHORT $LN85@operator@31
	push	0
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN85@operator@31:

; 283  : 		return (*this);

	lea	eax, DWORD PTR __Ok$[ebp]
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, esi

; 284  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$2:
	lea	eax, DWORD PTR __Ok$[ebp]
	push	eax
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	ret	0
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$3:
	lea	ecx, DWORD PTR $T53906[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$4
__ehfuncinfo$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File f:\cygwin\home\charles\gusale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T54185 = -152						; size = 28
$T54183 = -124						; size = 28
$T54184 = -96						; size = 28
$T54182 = -68						; size = 28
$T54181 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_root$ = 12						; size = 4
?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledWriter::writeCommentAfterValueOnSameLine, COMDAT

; 495  : {

	push	-1
	push	__ehhandler$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+172]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _root$[esp+168]

; 496  :    if ( root.hasComment( commentAfterOnSameLine ) )

	mov	eax, DWORD PTR [ebp+12]
	xor	ebx, ebx
	cmp	eax, ebx
	je	$LN86@writeComme
	cmp	DWORD PTR [eax+4], ebx
	je	$LN86@writeComme

; 497  :       document_ += " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	mov	ecx, 1
	lea	esi, DWORD PTR $T54181[esp+172]
	mov	eax, ebp
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	mov	ecx, eax
	lea	edx, DWORD PTR $T54182[esp+172]
	mov	DWORD PTR __$EHRec$[esp+180], ebx
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	push	eax
	lea	edi, DWORD PTR $T54183[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 1
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 4
	mov	esi, DWORD PTR _this$[esp+168]
	push	ebx
	push	eax
	add	esi, 20					; 00000014H
	or	eax, -1
	mov	BYTE PTR __$EHRec$[esp+188], 2
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	esi, 16					; 00000010H
	cmp	DWORD PTR $T54183[esp+196], esi
	jb	SHORT $LN34@writeComme
	mov	eax, DWORD PTR $T54183[esp+176]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@writeComme:
	cmp	DWORD PTR $T54182[esp+196], esi
	mov	edi, 15					; 0000000fH
	mov	DWORD PTR $T54183[esp+196], edi
	mov	DWORD PTR $T54183[esp+192], ebx
	mov	BYTE PTR $T54183[esp+176], bl
	jb	SHORT $LN60@writeComme
	mov	ecx, DWORD PTR $T54182[esp+176]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN60@writeComme:
	mov	DWORD PTR __$EHRec$[esp+180], -1
	cmp	DWORD PTR $T54181[esp+196], esi
	mov	DWORD PTR $T54182[esp+196], edi
	mov	DWORD PTR $T54182[esp+192], ebx
	mov	BYTE PTR $T54182[esp+176], bl
	jb	SHORT $LN86@writeComme
	mov	edx, DWORD PTR $T54181[esp+176]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN86@writeComme:

; 498  : 
; 499  :    if ( root.hasComment( commentAfter ) )

	mov	eax, DWORD PTR [ebp+12]
	cmp	eax, ebx
	je	$LN162@writeComme
	cmp	DWORD PTR [eax+8], ebx
	je	$LN162@writeComme

; 500  :    {
; 501  :       document_ += "\n";

	mov	edi, DWORD PTR _this$[esp+168]
	push	1
	add	edi, 20					; 00000014H
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	eax, edi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 502  :       document_ += normalizeEOL( root.getComment( commentAfter ) );

	mov	ecx, 2
	lea	esi, DWORD PTR $T54184[esp+172]
	mov	eax, ebp
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	mov	ecx, eax
	lea	edx, DWORD PTR $T54185[esp+172]
	mov	DWORD PTR __$EHRec$[esp+180], 3
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	push	ebx
	push	eax
	or	eax, -1
	mov	esi, edi
	mov	BYTE PTR __$EHRec$[esp+188], 4
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	esi, 16					; 00000010H
	cmp	DWORD PTR $T54185[esp+196], esi
	jb	SHORT $LN126@writeComme
	mov	eax, DWORD PTR $T54185[esp+176]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN126@writeComme:
	mov	ebp, 15					; 0000000fH
	mov	DWORD PTR __$EHRec$[esp+180], -1
	cmp	DWORD PTR $T54184[esp+196], esi
	mov	DWORD PTR $T54185[esp+196], ebp
	mov	DWORD PTR $T54185[esp+192], ebx
	mov	BYTE PTR $T54185[esp+176], bl
	jb	SHORT $LN152@writeComme
	mov	ecx, DWORD PTR $T54184[esp+176]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN152@writeComme:

; 503  :       document_ += "\n";

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	eax, edi
	mov	DWORD PTR $T54184[esp+204], ebp
	mov	DWORD PTR $T54184[esp+200], ebx
	mov	BYTE PTR $T54184[esp+184], bl
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN162@writeComme:

; 504  :    }
; 505  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+172]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 152				; 00000098H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T54181[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T54182[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T54183[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T54184[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T54185[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-156]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeCommentAfterValueOnSameLine
PUBLIC	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1
__ehfuncinfo$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File f:\cygwin\home\charles\gusale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T54816 = -68						; size = 28
$T54815 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_root$ = 12						; size = 4
?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledWriter::writeCommentBeforeValue, COMDAT

; 485  : {

	push	-1
	push	__ehhandler$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+80]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _root$[esp+76]

; 486  :    if ( !root.hasComment( commentBefore ) )

	mov	ecx, DWORD PTR [eax+12]
	xor	ebx, ebx
	cmp	ecx, ebx
	je	$LN66@writeComme@2
	cmp	DWORD PTR [ecx], ebx
	je	$LN66@writeComme@2

; 487  :       return;
; 488  :    document_ += normalizeEOL( root.getComment( commentBefore ) );

	xor	ecx, ecx
	lea	esi, DWORD PTR $T54815[esp+80]
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	mov	ecx, eax
	lea	edx, DWORD PTR $T54816[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	mov	esi, DWORD PTR _this$[esp+76]
	push	ebx
	push	eax
	add	esi, 20					; 00000014H
	or	eax, -1
	mov	BYTE PTR __$EHRec$[esp+96], 1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	cmp	DWORD PTR $T54816[esp+104], 16		; 00000010H
	jb	SHORT $LN30@writeComme@2
	mov	eax, DWORD PTR $T54816[esp+84]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN30@writeComme@2:
	mov	DWORD PTR __$EHRec$[esp+88], -1
	cmp	DWORD PTR $T54815[esp+104], 16		; 00000010H
	mov	DWORD PTR $T54816[esp+104], 15		; 0000000fH
	mov	DWORD PTR $T54816[esp+100], ebx
	mov	BYTE PTR $T54816[esp+84], bl
	jb	SHORT $LN56@writeComme@2
	mov	ecx, DWORD PTR $T54815[esp+84]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@writeComme@2:

; 489  :    document_ += "\n";

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	eax, esi
	mov	DWORD PTR $T54815[esp+112], 15		; 0000000fH
	mov	DWORD PTR $T54815[esp+108], ebx
	mov	BYTE PTR $T54815[esp+92], bl
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN66@writeComme@2:

; 490  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	add	esp, 68					; 00000044H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T54815[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T54816[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-64]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeCommentBeforeValue
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
;	COMDAT ?_Init@ios_base@std@@IAEXXZ
_TEXT	SEGMENT
__Lock$55142 = -4					; size = 4
?_Init@ios_base@std@@IAEXXZ PROC			; std::ios_base::_Init, COMDAT
; _this$ = esi

; 503  :         {	// initialize a new ios_base

	sub	esp, 8
	push	ebx
	push	ebp

; 504  :         _Ploc = 0;

	xor	ebp, ebp
	push	edi

; 505  :         _Except = goodbit;
; 506  :         _Fmtfl = skipws | dec;
; 507  :         _Prec = 6;
; 508  :         _Wide = 0;
; 509  :         _Arr = 0;
; 510  :         _Calls = 0;
; 511  :         clear(goodbit);
; 512  :         _Ploc = _NEW_CRT locale;

	push	4
	mov	DWORD PTR [esi+36], ebp
	mov	DWORD PTR [esi+12], ebp
	mov	DWORD PTR [esi+16], 513			; 00000201H
	mov	DWORD PTR [esi+20], 6
	mov	DWORD PTR [esi+24], ebp
	mov	DWORD PTR [esi+28], ebp
	mov	DWORD PTR [esi+32], ebp
	mov	DWORD PTR [esi+8], ebp
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	cmp	edi, ebp
	je	SHORT $LN3@Init@3
	call	?_Init@locale@std@@CAPAV_Locimp@12@XZ	; std::locale::_Init
	mov	DWORD PTR [edi], eax
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	push	ebp
	lea	ecx, DWORD PTR __Lock$55142[esp+24]
	mov	ebx, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, -1
	jae	SHORT $LN25@Init@3
	add	eax, 1
	mov	DWORD PTR [ebx+4], eax
$LN25@Init@3:
	lea	ecx, DWORD PTR __Lock$55142[esp+20]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	DWORD PTR [esi+36], edi

; 513  :         }

	pop	edi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
$LN3@Init@3:
	pop	edi
	mov	DWORD PTR [esi+36], ebp
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
?_Init@ios_base@std@@IAEXXZ ENDP			; std::ios_base::_Init
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$9
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$10
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -36						; size = 8
__Pad$ = -28						; size = 4
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 738  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, DWORD PTR __Ostr$[ebp]

; 739  : 	typedef char _Elem;
; 740  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 741  : 	ios_base::iostate _State = ios_base::goodbit;

	xor	ebx, ebx

; 742  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

	mov	eax, OFFSET ??_C@_02DHFAHMIK@?2u?$AA@
	mov	DWORD PTR __State$[ebp], ebx
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL153@operator@32:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL153@operator@32
	sub	eax, edx
	mov	esi, eax

; 743  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
; 744  : 		? 0 : _Ostr.width() - _Count;

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+edi+24]
	cmp	eax, ebx
	jle	SHORT $LN17@operator@32
	cmp	eax, esi
	jle	SHORT $LN17@operator@32
	sub	eax, esi
	mov	ebx, eax
	mov	DWORD PTR __Pad$[ebp], eax
	jmp	SHORT $LN18@operator@32
$LN17@operator@32:
	mov	DWORD PTR __Pad$[ebp], ebx
$LN18@operator@32:

; 745  : 	const typename _Myos::sentry _Ok(_Ostr);

	lea	edx, DWORD PTR __Ok$[ebp]
	push	edx
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 746  : 
; 747  : 	if (!_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	jne	SHORT $LN14@operator@32

; 748  : 		_State |= ios_base::badbit;

	mov	edx, 4

; 749  : 	else

	jmp	$LN22@operator@32
$LN14@operator@32:

; 750  : 		{	// state okay, insert
; 751  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 752  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+edi+16]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN151@operator@32
$LL10@operator@32:

; 753  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	ebx, ebx
	jle	SHORT $LN8@operator@32

; 754  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 755  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+edi]
	mov	al, BYTE PTR [ecx+48]
	mov	ecx, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN42@operator@32
	mov	edx, DWORD PTR [ecx+52]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN42@operator@32
	add	DWORD PTR [edx], -1
	mov	ecx, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [ecx]
	lea	ebx, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], ebx
	mov	ebx, DWORD PTR __Pad$[ebp]
	mov	BYTE PTR [edx], al
	movzx	eax, al
	jmp	SHORT $LN43@operator@32
$LN42@operator@32:
	mov	edx, DWORD PTR [ecx]
	movzx	eax, al
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN43@operator@32:
	cmp	eax, -1
	jne	$LN9@operator@32

; 756  : 					{	// insertion failed, quit
; 757  : 					_State |= ios_base::badbit;

	or	DWORD PTR __State$[ebp], 4
$LN8@operator@32:

; 758  : 					break;
; 759  : 					}
; 760  : 
; 761  : 		if (_State == ios_base::goodbit
; 762  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN2@operator@32
$LN151@operator@32:
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+edi+40]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	eax, OFFSET ??_C@_02DHFAHMIK@?2u?$AA@
	push	eax
	mov	eax, DWORD PTR [edx+32]
	call	eax
	cmp	eax, esi
	je	$LL152@operator@32

; 763  : 			_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4
$LN2@operator@32:

; 772  : 					}
; 773  : 		_Ostr.width(0);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, edi
	xor	ecx, ecx
	mov	DWORD PTR [eax+24], ecx

; 774  : 		_CATCH_IO_(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], ecx
$LN160@operator@32:
	mov	edx, DWORD PTR __State$[ebp]
$LN22@operator@32:

; 775  : 		}
; 776  : 
; 777  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edi
	test	edx, edx
	je	SHORT $LN126@operator@32
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN118@operator@32
	or	eax, 4
$LN118@operator@32:
	and	eax, 23					; 00000017H
	test	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+8], eax
	je	SHORT $LN126@operator@32
	push	0
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN126@operator@32:

; 778  : 	return (_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 3
	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN136@operator@32
	mov	ecx, DWORD PTR __Ok$[ebp]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN136@operator@32:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR __Ok$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN155@operator@32
	lea	ecx, DWORD PTR [eax+4]
	call	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
$LN155@operator@32:
	mov	eax, edi

; 779  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@operator@32:

; 753  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	sub	ebx, 1
	mov	DWORD PTR __Pad$[ebp], ebx
	jmp	$LL10@operator@32
$LL152@operator@32:

; 764  : 
; 765  : 		if (_State == ios_base::goodbit)
; 766  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	ebx, ebx
	jle	$LN2@operator@32

; 767  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 768  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	mov	al, BYTE PTR [edx+edi+48]
	lea	ecx, DWORD PTR [edx+edi]
	mov	ecx, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN68@operator@32
	mov	edx, DWORD PTR [ecx+52]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN68@operator@32
	add	DWORD PTR [edx], -1
	mov	ecx, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [ecx]
	lea	esi, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], esi
	mov	BYTE PTR [edx], al
	movzx	eax, al
	jmp	SHORT $LN69@operator@32
$LN68@operator@32:
	mov	edx, DWORD PTR [ecx]
	movzx	eax, al
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN69@operator@32:
	cmp	eax, -1
	jne	SHORT $LN3@operator@32

; 769  : 					{	// insertion failed, quit
; 770  : 					_State |= ios_base::badbit;

	or	DWORD PTR __State$[ebp], 4

; 771  : 					break;

	jmp	$LN2@operator@32
$LN3@operator@32:

; 764  : 
; 765  : 		if (_State == ios_base::goodbit)
; 766  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	sub	ebx, 1
	jmp	SHORT $LL152@operator@32
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 774  : 		_CATCH_IO_(_Ostr)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	or	eax, 4
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN93@operator@32
	or	eax, 4
$LN93@operator@32:
	and	eax, 23					; 00000017H
	test	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+8], eax
	je	SHORT $LN101@operator@32
	push	1
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN101@operator@32:
	mov	eax, $LN23@operator@32
	ret	0
$LN23@operator@32:
	mov	edi, DWORD PTR __Ostr$[ebp]
	jmp	$LN160@operator@32
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	eax, DWORD PTR __Ok$[ebp]
	push	eax
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	ret	0
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$9:
	lea	eax, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
PUBLIC	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
; Function compile flags: /Ogtpy
; File f:\cygwin\home\charles\gusale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledWriter::pushValue, COMDAT
; _this$ = eax
; _value$ = ecx

; 438  :    if ( addChildValues_ )

	cmp	BYTE PTR [eax+84], 0
	push	esi
	je	SHORT $LN2@pushValue

; 439  :       childValues_.push_back( value );

	push	ecx
	lea	esi, DWORD PTR [eax+4]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 442  : }

	pop	esi
	ret	0
$LN2@pushValue:

; 440  :    else
; 441  :       document_ += value;

	push	0
	lea	esi, DWORD PTR [eax+20]
	push	ecx
	or	eax, -1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 442  : }

	pop	esi
	ret	0
?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledWriter::pushValue
_TEXT	ENDS
PUBLIC	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue
PUBLIC	?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledWriter::isMultineArray
PUBLIC	?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeArrayValue
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2
__ehfuncinfo$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File f:\cygwin\home\charles\gusale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
_hasChildValue$19160 = -81				; size = 1
_childValue$19165 = -80					; size = 4
tv803 = -76						; size = 4
_size$ = -72						; size = 4
$T57759 = -68						; size = 28
$T57758 = -68						; size = 28
$T57760 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledWriter::writeArrayValue, COMDAT
; _this$ = ecx

; 353  : {

	push	-1
	push	__ehhandler$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+104]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 354  :    unsigned size = value.size();

	mov	esi, DWORD PTR _value$[esp+100]
	mov	eax, esi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	ebp, eax

; 355  :    if ( size == 0 )

	xor	ebx, ebx
	cmp	ebp, ebx
	mov	DWORD PTR _size$[esp+104], ebp
	jne	SHORT $LN13@writeArray

; 356  :       pushValue( "[]" );

	push	2
	push	OFFSET ??_C@_02GPECMEKF@?$FL?$FN?$AA@
	lea	ecx, DWORD PTR $T57758[esp+112]
	mov	DWORD PTR $T57758[esp+136], 15		; 0000000fH
	mov	DWORD PTR $T57758[esp+132], ebx
	mov	BYTE PTR $T57758[esp+116], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	DWORD PTR __$EHRec$[esp+112], ebx
	cmp	BYTE PTR [edi+84], bl
	je	SHORT $LN56@writeArray
	lea	eax, DWORD PTR $T57758[esp+104]
	push	eax
	lea	esi, DWORD PTR [edi+4]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
	jmp	SHORT $LN59@writeArray
$LN56@writeArray:
	push	ebx
	lea	ecx, DWORD PTR $T57758[esp+108]
	push	ecx
	lea	esi, DWORD PTR [edi+20]
	or	eax, -1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN59@writeArray:
	cmp	DWORD PTR $T57758[esp+128], 16		; 00000010H
	jb	$LN376@writeArray
	mov	edx, DWORD PTR $T57758[esp+108]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 357  :    else

	jmp	$LN376@writeArray
$LN13@writeArray:

; 358  :    {
; 359  :       bool isArrayMultiLine = isMultineArray( value );

	push	esi
	mov	ecx, edi
	call	?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledWriter::isMultineArray

; 360  :       if ( isArrayMultiLine )

	test	al, al
	je	$LN11@writeArray

; 361  :       {
; 362  :          writeWithIndent( "[" );

	push	1
	push	OFFSET ??_C@_01OHGJGJJP@?$FL?$AA@
	lea	ecx, DWORD PTR $T57759[esp+112]
	mov	DWORD PTR $T57759[esp+136], 15		; 0000000fH
	mov	DWORD PTR $T57759[esp+132], ebx
	mov	BYTE PTR $T57759[esp+116], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T57759[esp+104]
	push	eax
	mov	eax, edi
	mov	DWORD PTR __$EHRec$[esp+116], 1
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	mov	DWORD PTR __$EHRec$[esp+112], -1
	cmp	DWORD PTR $T57759[esp+128], 16		; 00000010H
	jb	SHORT $LN232@writeArray
	mov	ecx, DWORD PTR $T57759[esp+108]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN232@writeArray:

; 363  :          indent();

	call	?indent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::indent

; 364  :          bool hasChildValue = !childValues_.empty();

	mov	eax, DWORD PTR [edi+8]
	cmp	eax, ebx
	jne	SHORT $LN246@writeArray
	xor	eax, eax
	jmp	SHORT $LN247@writeArray
$LN246@writeArray:
	mov	ecx, DWORD PTR [edi+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$LN247@writeArray:
	cmp	eax, ebx
	setne	BYTE PTR _hasChildValue$19160[esp+104]

; 365  :          unsigned index =0;

	xor	ebp, ebp
	mov	DWORD PTR tv803[esp+104], ebp
	npad	5
$LL10@writeArray:

; 366  :          while ( true )
; 367  :          {
; 368  :             const Value &childValue = value[index];

	push	ebp
	mov	ecx, esi
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	ebx, eax

; 369  :             writeCommentBeforeValue( childValue );

	push	ebx
	push	edi
	mov	DWORD PTR _childValue$19165[esp+112], ebx
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue

; 370  :             if ( hasChildValue )

	cmp	BYTE PTR _hasChildValue$19160[esp+104], 0
	je	SHORT $LN8@writeArray

; 371  :                writeWithIndent( childValues_[index] );

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN386@writeArray
	mov	ecx, DWORD PTR [edi+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	jb	SHORT $LN248@writeArray
$LN386@writeArray:
	call	__invalid_parameter_noinfo
$LN248@writeArray:
	mov	edx, DWORD PTR [edi+8]
	add	edx, DWORD PTR tv803[esp+104]
	mov	eax, edi
	push	edx
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent

; 372  :             else

	jmp	SHORT $LN7@writeArray
$LN8@writeArray:

; 373  :             {
; 374  :                writeIndent();

	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN255@writeArray
	lea	ebx, DWORD PTR [eax-1]
	cmp	ebx, DWORD PTR [edi+40]
	lea	esi, DWORD PTR [edi+20]
	jbe	SHORT $LN264@writeArray
	call	__invalid_parameter_noinfo
$LN264@writeArray:
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN269@writeArray
	mov	eax, DWORD PTR [esi+4]
	jmp	SHORT $LN270@writeArray
$LN269@writeArray:
	lea	eax, DWORD PTR [esi+4]
$LN270@writeArray:
	mov	al, BYTE PTR [eax+ebx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN389@writeArray
	cmp	al, 10					; 0000000aH
	je	SHORT $LN388@writeArray
	mov	bl, 10					; 0000000aH
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN388@writeArray:
	mov	ebx, DWORD PTR _childValue$19165[esp+104]
$LN255@writeArray:
	push	0
	lea	eax, DWORD PTR [edi+48]
	push	eax
	lea	esi, DWORD PTR [edi+20]
	or	eax, -1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	jmp	SHORT $LN271@writeArray
$LN389@writeArray:
	mov	ebx, DWORD PTR _childValue$19165[esp+104]
$LN271@writeArray:

; 375  :                writeValue( childValue );

	push	ebx
	mov	ecx, edi
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue
	mov	esi, DWORD PTR _value$[esp+100]
$LN7@writeArray:

; 376  :             }
; 377  :             if ( ++index == size )

	add	DWORD PTR tv803[esp+104], 28		; 0000001cH
	add	ebp, 1
	cmp	ebp, DWORD PTR _size$[esp+104]
	je	SHORT $LN384@writeArray

; 380  :                break;
; 381  :             }
; 382  :             document_ += ",";

	push	1
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	eax, DWORD PTR [edi+20]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 383  :             writeCommentAfterValueOnSameLine( childValue );

	push	ebx
	push	edi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 384  :          }

	jmp	$LL10@writeArray
$LN384@writeArray:

; 378  :             {
; 379  :                writeCommentAfterValueOnSameLine( childValue );

	push	ebx
	push	edi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 385  :          unindent();

	mov	eax, DWORD PTR [edi+68]
	sub	eax, DWORD PTR [edi+80]
	mov	edx, DWORD PTR [edi+68]
	cmp	eax, edx
	lea	ecx, DWORD PTR [edi+48]
	ja	SHORT $LN288@writeArray
	push	-1
	push	eax
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN287@writeArray
$LN288@writeArray:
	mov	ebx, eax
	push	0
	sub	ebx, edx
	mov	esi, ecx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN287@writeArray:

; 386  :          writeWithIndent( "]" );

	push	1
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	lea	ecx, DWORD PTR $T57760[esp+112]
	mov	DWORD PTR $T57760[esp+136], 15		; 0000000fH
	mov	DWORD PTR $T57760[esp+132], 0
	mov	BYTE PTR $T57760[esp+116], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T57760[esp+104]
	push	ecx
	mov	eax, edi
	mov	DWORD PTR __$EHRec$[esp+116], 2
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	cmp	DWORD PTR $T57760[esp+128], 16		; 00000010H
	jb	$LN376@writeArray
	mov	edx, DWORD PTR $T57760[esp+108]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 387  :       }
; 388  :       else // output on a single line

	jmp	SHORT $LN376@writeArray
$LN11@writeArray:

; 389  :       {
; 390  :          assert( childValues_.size() == size );
; 391  :          document_ += "[ ";

	push	2
	lea	esi, DWORD PTR [edi+20]
	push	OFFSET ??_C@_02PFNDMDBO@?$FL?5?$AA@
	mov	eax, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 392  :          for ( unsigned index =0; index < size; ++index )

	cmp	ebp, ebx
	jbe	SHORT $LN2@writeArray

; 389  :       {
; 390  :          assert( childValues_.size() == size );
; 391  :          document_ += "[ ";

	xor	ebp, ebp
$LL4@writeArray:

; 393  :          {
; 394  :             if ( index > 0 )

	test	ebx, ebx
	jbe	SHORT $LN359@writeArray

; 395  :                document_ += ", ";

	push	2
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	eax, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN359@writeArray:

; 396  :             document_ += childValues_[index];

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN387@writeArray
	mov	ecx, DWORD PTR [edi+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	jb	SHORT $LN365@writeArray
$LN387@writeArray:
	call	__invalid_parameter_noinfo
$LN365@writeArray:
	mov	eax, DWORD PTR [edi+8]
	add	eax, ebp
	push	0
	push	eax
	or	eax, -1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	add	ebx, 1
	add	ebp, 28					; 0000001cH
	cmp	ebx, DWORD PTR _size$[esp+104]
	jb	SHORT $LL4@writeArray
$LN2@writeArray:

; 397  :          }
; 398  :          document_ += " ]";

	push	2
	push	OFFSET ??_C@_02DHOGEDBE@?5?$FN?$AA@
	mov	eax, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN376@writeArray:

; 399  :       }
; 400  :    }
; 401  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 84					; 00000054H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T57758[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T57759[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T57760[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-88]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeArrayValue
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0
__ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ios
xdata$x	ENDS
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
_TEXT	SEGMENT
__Lock$60263 = -16					; size = 4
__$EHRec$ = -12						; size = 12
$T60241 = 8						; size = 4
_this$ = 8						; size = 4
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z PROC ; std::basic_ios<char,std::char_traits<char> >::widen, COMDAT

; 123  : 		{	// convert _Byte to character using imbued locale

	push	-1
	push	__ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax

; 124  : 		const _Ctype& _Ctype_fac = _USE(getloc(), _Ctype);

	mov	eax, DWORD PTR _this$[esp+28]
	lea	edi, DWORD PTR $T60241[esp+28]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[esp+44], 0
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	mov	DWORD PTR __$EHRec$[esp+44], -1
	mov	edi, DWORD PTR $T60241[esp+32]
	add	esp, 4
	test	edi, edi
	mov	ebx, eax
	je	SHORT $LN7@widen
	push	0
	lea	ecx, DWORD PTR __Lock$60263[esp+36]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN9@widen
	cmp	eax, -1
	jae	SHORT $LN9@widen
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN9@widen:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$60263[esp+32]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN7@widen
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN7@widen:

; 125  : 		return (_Ctype_fac.widen(_Byte));

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+24]
	push	32					; 00000020H
	mov	ecx, ebx
	call	edx

; 126  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0:
	lea	ecx, DWORD PTR $T60241[ebp-4]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::widen
; Function compile flags: /Ogtpy
;	COMDAT ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
_TEXT	SEGMENT
__Strbuf$ = 8						; size = 4
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::init, COMDAT
; _this$ = eax

; 131  : 		{	// initialize with stream buffer pointer

	push	esi
	push	edi
	mov	esi, eax

; 132  : 		_Init();	// initialize ios_base

	call	?_Init@ios_base@std@@IAEXXZ		; std::ios_base::_Init

; 133  : 		_Mystrbuf = _Strbuf;

	mov	eax, DWORD PTR __Strbuf$[esp+4]

; 134  : 		_Tiestr = 0;

	xor	edi, edi

; 135  : 		_Fillch = widen(' ');

	push	esi
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], edi
	call	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen

; 136  : 
; 137  : 		if (_Mystrbuf == 0)

	cmp	DWORD PTR [esi+40], edi
	mov	BYTE PTR [esi+48], al
	jne	SHORT $LN32@init

; 138  : 			setstate(badbit);

	mov	eax, DWORD PTR [esi+8]
	or	eax, 4
	and	eax, 23					; 00000017H
	test	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], eax
	je	SHORT $LN32@init
	push	edi
	mov	ecx, esi
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN32@init:

; 139  : 
; 140  : 		if (_Isstd)
; 141  : 			_Addstd(this);	// special handling for standard streams
; 142  : 		else
; 143  : 			_Stdstr = 0;

	mov	DWORD PTR [esi+4], edi

; 144  : 		}

	pop	edi
	pop	esi
	ret	4
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::init
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 0ffffffffH
	DD	00H
__ehfuncinfo$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
_TEXT	SEGMENT
$T60370 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Strbuf$ = 12						; size = 4
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >, COMDAT

; 49   : 	explicit __CLR_OR_THIS_CALL basic_ostream(basic_streambuf<_Elem, _Traits> *_Strbuf,

	push	-1
	push	__ehhandler$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, DWORD PTR _this$[esp+32]
	xor	ebx, ebx
	mov	DWORD PTR $T60370[esp+36], ebx
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+ecx], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@

; 50   : 		bool _Isstd = false)
; 51   : 		{	// construct from a stream buffer pointer
; 52   : 		_Myios::init(_Strbuf, _Isstd);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR [edx+4]
	add	esi, edi
	call	?_Init@ios_base@std@@IAEXXZ		; std::ios_base::_Init
	mov	eax, DWORD PTR __Strbuf$[esp+32]
	push	esi
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], ebx
	call	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
	cmp	DWORD PTR [esi+40], ebx
	mov	BYTE PTR [esi+48], al
	jne	SHORT $LN41@basic_ostr
	mov	eax, DWORD PTR [esi+8]
	or	eax, 4
	and	eax, 23					; 00000017H
	test	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], eax
	je	SHORT $LN41@basic_ostr
	push	ebx
	mov	ecx, esi
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN41@basic_ostr:
	mov	DWORD PTR [esi+4], ebx

; 53   : 		}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\sstream
xdata$x	SEGMENT
__unwindtable$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3
__ehfuncinfo$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
$T60573 = -20						; size = 4
$T60509 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 417  : 		{	// construct empty writable character buffer

	push	-1
	push	__ehhandler$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+28]
	mov	DWORD PTR $T60509[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
	mov	DWORD PTR [esi+76], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
	lea	edi, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[esp+44], 0
	push	esi
	mov	DWORD PTR $T60509[esp+40], 1
	call	??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
	mov	DWORD PTR __$EHRec$[esp+40], 1
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	mov	DWORD PTR [esi+ecx], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	call	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
	mov	DWORD PTR [edi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	DWORD PTR [edi+60], 0
	mov	DWORD PTR [edi+64], 4

; 418  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0:
	mov	eax, DWORD PTR $T60509[ebp]
	and	eax, 1
	je	$LN5@basic_ostr@2
	and	DWORD PTR $T60509[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 76					; 0000004cH
	jmp	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@basic_ostr@2:
	ret	0
__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 4
	jmp	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3:
	mov	ecx, DWORD PTR $T60573[ebp]
	jmp	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$5
__ehfuncinfo$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File f:\cygwin\home\charles\gusale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -244				; size = 4
$T60589 = -240						; size = 28
$T60586 = -240						; size = 28
$T60593 = -212						; size = 4
$T60587 = -212						; size = 8
$T60585 = -204						; size = 28
_oss$18747 = -176					; size = 128
_result$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z PROC ; Json::valueToQuotedString, COMDAT
; ___$ReturnUdt$ = ecx
; _value$ = edx

; 112  : {

	push	-1
	push	__ehhandler$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+248], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+268]
	mov	DWORD PTR fs:0, eax
	mov	edi, edx
	mov	esi, ecx

; 113  :    // Not sure how to handle unicode...
; 114  :    if (strpbrk(value, "\"\\\b\f\n\r\t") == NULL && !containsControlCharacter( value ))

	push	OFFSET ??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@

; 160  :                oss << "\\u" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << static_cast<int>(*c);

	xor	ebp, ebp
	push	edi

; 166  :             }
; 167  :             break;
; 168  :       }
; 169  :    }
; 170  :    result += "\"";

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+276], esi
	mov	DWORD PTR $T60593[esp+276], ebp
	call	_strpbrk
	add	esp, 8
	test	eax, eax
	jne	$LN16@valueToQuo
	cmp	BYTE PTR [edi], al
	mov	ecx, edi
	je	SHORT $LN27@valueToQuo

; 113  :    // Not sure how to handle unicode...
; 114  :    if (strpbrk(value, "\"\\\b\f\n\r\t") == NULL && !containsControlCharacter( value ))

$LL28@valueToQuo:
	movzx	eax, BYTE PTR [ecx]
	sub	al, 1
	mov	dl, 30					; 0000001eH
	cmp	dl, al
	sbb	eax, eax
	add	eax, 1
	add	ecx, 1
	test	al, al
	jne	$LN16@valueToQuo
	cmp	BYTE PTR [ecx], al
	jne	SHORT $LL28@valueToQuo
$LN27@valueToQuo:

; 115  :       return std::string("\"") + value + "\"";

	push	1
	mov	ebx, 15					; 0000000fH
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	lea	ecx, DWORD PTR $T60585[esp+276]
	mov	DWORD PTR $T60585[esp+300], ebx
	mov	DWORD PTR $T60585[esp+296], ebp
	mov	BYTE PTR $T60585[esp+280], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T60585[esp+268]
	push	eax
	lea	esi, DWORD PTR $T60586[esp+272]
	mov	DWORD PTR __$EHRec$[esp+280], ebp
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 4
	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$[esp+268]
	push	eax
	mov	edi, OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	BYTE PTR __$EHRec$[esp+280], 1
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	esi, 16					; 00000010H
	add	esp, 4
	cmp	DWORD PTR $T60586[esp+292], esi
	jb	SHORT $LN87@valueToQuo
	mov	ecx, DWORD PTR $T60586[esp+272]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN87@valueToQuo:
	cmp	DWORD PTR $T60585[esp+292], esi
	mov	DWORD PTR $T60586[esp+292], ebx
	mov	DWORD PTR $T60586[esp+288], ebp
	mov	BYTE PTR $T60586[esp+272], 0
	jb	SHORT $LN113@valueToQuo
	mov	edx, DWORD PTR $T60585[esp+272]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN113@valueToQuo:
	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$[esp+268]
	jmp	$LN17@valueToQuo
$LN16@valueToQuo:

; 116  :    // We have to walk value and escape any special characters.
; 117  :    // Appending to std::string is not efficient, but this should be rare.
; 118  :    // (Note: forward slashes are *not* rare, but I am not escaping them.)
; 119  :    unsigned maxsize = strlen(value)*2 + 3; // allescaped+quotes+NULL

	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL354@valueToQuo:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL354@valueToQuo
	sub	eax, edx
	lea	eax, DWORD PTR [eax+eax+3]

; 120  :    std::string result;

	mov	DWORD PTR _result$[esp+292], 15		; 0000000fH
	mov	DWORD PTR _result$[esp+288], ebp
	mov	BYTE PTR _result$[esp+272], cl

; 121  :    result.reserve(maxsize); // to avoid lots of mallocs

	cmp	eax, 15					; 0000000fH
	mov	DWORD PTR __$EHRec$[esp+276], 2
	je	SHORT $LN165@valueToQuo
	push	1
	push	eax
	lea	ecx, DWORD PTR _result$[esp+276]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN165@valueToQuo
	cmp	DWORD PTR _result$[esp+292], 16		; 00000010H
	mov	eax, DWORD PTR _result$[esp+272]
	mov	DWORD PTR _result$[esp+288], ebp
	jae	SHORT $LN164@valueToQuo
	lea	eax, DWORD PTR _result$[esp+272]
$LN164@valueToQuo:
	mov	BYTE PTR [eax], 0
$LN165@valueToQuo:

; 122  :    result += "\"";

	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	lea	eax, DWORD PTR _result$[esp+276]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 123  :    for (const char* c=value; *c != 0; ++c)

	cmp	BYTE PTR [edi], 0
	je	$LN13@valueToQuo
$LN15@valueToQuo:

; 124  :    {
; 125  :       switch(*c)

	mov	al, BYTE PTR [edi]
	movsx	ecx, al
	add	ecx, -8					; fffffff8H
	cmp	ecx, 84					; 00000054H
	ja	$LN3@valueToQuo
	movzx	ecx, BYTE PTR $LN355@valueToQuo[ecx]
	jmp	DWORD PTR $LN363@valueToQuo[ecx*4]
$LN10@valueToQuo:

; 126  :       {
; 127  :          case '\"':
; 128  :             result += "\\\"";

	push	2
	push	OFFSET ??_C@_02MCKKLHBJ@?2?$CC?$AA@
	lea	eax, DWORD PTR _result$[esp+276]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 129  :             break;

	jmp	$LN14@valueToQuo
$LN9@valueToQuo:

; 130  :          case '\\':
; 131  :             result += "\\\\";

	push	2
	push	OFFSET ??_C@_02HDBGODGB@?2?2?$AA@
	lea	eax, DWORD PTR _result$[esp+276]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 132  :             break;

	jmp	$LN14@valueToQuo
$LN8@valueToQuo:

; 133  :          case '\b':
; 134  :             result += "\\b";

	push	2
	push	OFFSET ??_C@_02DCNDPIBM@?2b?$AA@
	lea	eax, DWORD PTR _result$[esp+276]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 135  :             break;

	jmp	$LN14@valueToQuo
$LN7@valueToQuo:

; 136  :          case '\f':
; 137  :             result += "\\f";

	push	2
	push	OFFSET ??_C@_02FGLPDNBI@?2f?$AA@
	lea	eax, DWORD PTR _result$[esp+276]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 138  :             break;

	jmp	$LN14@valueToQuo
$LN6@valueToQuo:

; 139  :          case '\n':
; 140  :             result += "\\n";

	push	2
	push	OFFSET ??_C@_02JOGGLHBA@?2n?$AA@
	lea	eax, DWORD PTR _result$[esp+276]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 141  :             break;

	jmp	$LN14@valueToQuo
$LN5@valueToQuo:

; 142  :          case '\r':
; 143  :             result += "\\r";

	push	2
	push	OFFSET ??_C@_02HIBBOKEN@?2r?$AA@
	lea	eax, DWORD PTR _result$[esp+276]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 144  :             break;

	jmp	$LN14@valueToQuo
$LN4@valueToQuo:

; 145  :          case '\t':
; 146  :             result += "\\t";

	push	2
	push	OFFSET ??_C@_02COELENML@?2t?$AA@
	lea	eax, DWORD PTR _result$[esp+276]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 147  :             break;

	jmp	$LN14@valueToQuo
$LN3@valueToQuo:

; 148  :          //case '/':
; 149  :             // Even though \/ is considered a legal escape in JSON, a bare
; 150  :             // slash is also legal, so I see no reason to escape it.
; 151  :             // (I hope I am not misunderstanding something.
; 152  :             // blep notes: actually escaping \/ may be useful in javascript to avoid </ 
; 153  :             // sequence.
; 154  :             // Should add a flag to allow this compatibility mode and prevent this 
; 155  :             // sequence from occurring.
; 156  :          default:
; 157  :             if ( isControlCharacter( *c ) )

	mov	dl, al
	sub	dl, 1
	cmp	dl, 30					; 0000001eH
	ja	$LN2@valueToQuo

; 158  :             {
; 159  :                std::ostringstream oss;

	lea	eax, DWORD PTR _oss$18747[esp+268]
	push	eax
	call	??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >

; 160  :                oss << "\\u" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << static_cast<int>(*c);

	lea	ecx, DWORD PTR _oss$18747[esp+268]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+280], 3
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	esi, eax
	add	esp, 4
	cmp	esi, ebp
	jne	SHORT $LN225@valueToQuo
	xor	eax, eax
	jmp	SHORT $LN226@valueToQuo
$LN225@valueToQuo:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
$LN226@valueToQuo:
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -1537				; fffff9ffH
	or	ecx, 2048				; 00000800H
	cmp	esi, ebp
	mov	DWORD PTR [eax+16], ecx
	jne	SHORT $LN233@valueToQuo
	xor	eax, eax
	jmp	SHORT $LN234@valueToQuo
$LN233@valueToQuo:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
$LN234@valueToQuo:
	mov	ebx, 4
	or	DWORD PTR [eax+16], ebx
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T60587[esp+268]
	add	eax, esi
	push	ebx
	push	ecx
	mov	BYTE PTR [eax+48], 48			; 00000030H
	call	?setw@std@@YA?AU?$_Smanip@H@1@H@Z	; std::setw
	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	add	ecx, esi
	push	edx
	push	ecx
	call	eax
	movsx	ecx, BYTE PTR [edi]
	add	esp, 16					; 00000010H
	push	ecx
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 161  :                result += oss.str();

	lea	ecx, DWORD PTR $T60589[esp+268]
	lea	eax, DWORD PTR _oss$18747[esp+268]
	call	?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
	push	ebp
	push	eax
	or	eax, -1
	lea	esi, DWORD PTR _result$[esp+276]
	mov	BYTE PTR __$EHRec$[esp+284], bl
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	cmp	DWORD PTR $T60589[esp+292], 16		; 00000010H
	jb	SHORT $LN267@valueToQuo
	mov	edx, DWORD PTR $T60589[esp+272]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN267@valueToQuo:

; 162  :             }

	lea	ecx, DWORD PTR _oss$18747[esp+344]
	mov	DWORD PTR $T60589[esp+292], 15		; 0000000fH
	mov	DWORD PTR $T60589[esp+288], ebp
	mov	BYTE PTR $T60589[esp+272], 0
	mov	BYTE PTR __$EHRec$[esp+276], 2
	call	??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR _oss$18747[esp+344]
	push	eax
	mov	DWORD PTR _oss$18747[esp+348], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	add	esp, 4

; 163  :             else

	jmp	SHORT $LN362@valueToQuo
$LN2@valueToQuo:

; 164  :             {
; 165  :                result += *c;

	mov	bl, al
	lea	esi, DWORD PTR _result$[esp+268]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	xor	ebp, ebp
$LN362@valueToQuo:
	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$[esp+268]
$LN14@valueToQuo:

; 123  :    for (const char* c=value; *c != 0; ++c)

	add	edi, 1
	cmp	BYTE PTR [edi], 0
	jne	$LN15@valueToQuo
$LN13@valueToQuo:

; 166  :             }
; 167  :             break;
; 168  :       }
; 169  :    }
; 170  :    result += "\"";

	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	lea	eax, DWORD PTR _result$[esp+276]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 171  :    return result;

	push	-1
	push	ebp
	lea	ecx, DWORD PTR _result$[esp+276]
	push	ecx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebp
	mov	ecx, esi
	mov	BYTE PTR [esi+4], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	DWORD PTR _result$[esp+292], 16		; 00000010H
	jb	SHORT $LN338@valueToQuo
	mov	edx, DWORD PTR _result$[esp+272]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN338@valueToQuo:
	mov	eax, esi
$LN17@valueToQuo:

; 172  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+268]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+248]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 248				; 000000f8H
	ret	0
$LN363@valueToQuo:
	DD	$LN8@valueToQuo
	DD	$LN4@valueToQuo
	DD	$LN6@valueToQuo
	DD	$LN7@valueToQuo
	DD	$LN5@valueToQuo
	DD	$LN10@valueToQuo
	DD	$LN9@valueToQuo
	DD	$LN3@valueToQuo
$LN355@valueToQuo:
	DB	0
	DB	1
	DB	2
	DB	7
	DB	3
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$0:
	lea	ecx, DWORD PTR $T60585[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$1:
	lea	ecx, DWORD PTR $T60586[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$3:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$4:
	lea	eax, DWORD PTR _oss$18747[ebp]
	jmp	??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$5:
	lea	ecx, DWORD PTR $T60589[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-252]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ENDP ; Json::valueToQuotedString
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$9
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$10
__ehfuncinfo$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File f:\cygwin\home\charles\gusale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
_it$19136 = -372					; size = 8
$T62044 = -364						; size = 4
_members$19130 = -360					; size = 16
$T61819 = -344						; size = 28
$T61818 = -316						; size = 28
$T61811 = -288						; size = 28
$T61817 = -260						; size = 28
$T61821 = -232						; size = 28
$T61812 = -204						; size = 28
$T61814 = -176						; size = 28
$T61815 = -148						; size = 28
$T61813 = -120						; size = 28
$T61816 = -92						; size = 28
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC	; Json::StyledWriter::writeValue, COMDAT
; _this$ = ecx

; 292  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	push	-1
	push	__ehhandler$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 360				; 00000168H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 293  :    switch ( value.type() )

	mov	ecx, DWORD PTR _value$[ebp]
	movsx	eax, BYTE PTR [ecx+8]
	cmp	eax, 7
	ja	$LN14@writeValue
	jmp	DWORD PTR $LN117@writeValue[eax*4]
$LN13@writeValue:

; 294  :    {
; 295  :    case nullValue:
; 296  :       pushValue( "null" );

	push	OFFSET ??_C@_04MLLLIHIP@null?$AA@
	lea	ecx, DWORD PTR $T61811[esp+392]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR $T61811[esp+388]
	mov	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+396], 0
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	lea	ecx, DWORD PTR $T61811[esp+388]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 346  :       break;
; 347  :    }
; 348  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN12@writeValue:

; 297  :       break;
; 298  :    case intValue:
; 299  :       pushValue( valueToString( value.asInt() ) );

	call	?asInt@Value@Json@@QBEHXZ		; Json::Value::asInt
	mov	ecx, eax
	lea	edi, DWORD PTR $T61812[esp+388]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::valueToString
	mov	ecx, eax
	mov	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+396], 1
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	mov	ecx, edi
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 346  :       break;
; 347  :    }
; 348  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN11@writeValue:

; 300  :       break;
; 301  :    case uintValue:
; 302  :       pushValue( valueToString( value.asUInt() ) );

	call	?asUInt@Value@Json@@QBEIXZ		; Json::Value::asUInt
	mov	ecx, eax
	lea	edi, DWORD PTR $T61813[esp+388]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::valueToString
	mov	ecx, eax
	mov	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+396], 2
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	mov	ecx, edi
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 346  :       break;
; 347  :    }
; 348  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN10@writeValue:

; 303  :       break;
; 304  :    case realValue:
; 305  :       pushValue( valueToString( value.asDouble() ) );

	push	ecx
	call	?asDouble@Value@Json@@QBENXZ		; Json::Value::asDouble
	sub	esp, 8
	lea	esi, DWORD PTR $T61814[esp+396]
	fstp	QWORD PTR [esp]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
	add	esp, 8
	mov	ecx, eax
	mov	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+396], 3
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	mov	ecx, esi
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 346  :       break;
; 347  :    }
; 348  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN9@writeValue:

; 306  :       break;
; 307  :    case stringValue:
; 308  :       pushValue( valueToQuotedString( value.asCString() ) );

	mov	edx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR $T61815[esp+388]
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	mov	ecx, eax
	mov	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+396], 4
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	lea	ecx, DWORD PTR $T61815[esp+388]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 346  :       break;
; 347  :    }
; 348  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN8@writeValue:

; 309  :       break;
; 310  :    case booleanValue:
; 311  :       pushValue( valueToString( value.asBool() ) );

	mov	eax, ecx
	call	?asBool@Value@Json@@QBE_NXZ		; Json::Value::asBool
	lea	esi, DWORD PTR $T61816[esp+388]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
	add	esp, 4
	mov	ecx, eax
	mov	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+396], 5
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	mov	ecx, esi
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 346  :       break;
; 347  :    }
; 348  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN7@writeValue:

; 312  :       break;
; 313  :    case arrayValue:
; 314  :       writeArrayValue( value);

	push	ecx
	mov	ecx, ebx
	call	?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeArrayValue

; 346  :       break;
; 347  :    }
; 348  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@writeValue:

; 315  :       break;
; 316  :    case objectValue:
; 317  :       {
; 318  :          Value::Members members( value.getMemberNames() );

	lea	eax, DWORD PTR _members$19130[esp+388]
	push	eax
	call	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames

; 319  :          if ( members.empty() )

	lea	ecx, DWORD PTR _members$19130[esp+388]
	mov	DWORD PTR __$EHRec$[esp+396], 6
	call	?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
	test	al, al
	je	SHORT $LN5@writeValue

; 320  :             pushValue( "{}" );

	push	OFFSET ??_C@_02MCILKGOH@?$HL?$HN?$AA@
	lea	ecx, DWORD PTR $T61817[esp+392]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR $T61817[esp+388]
	mov	eax, ebx
	mov	BYTE PTR __$EHRec$[esp+396], 7
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	lea	ecx, DWORD PTR $T61817[esp+388]

; 321  :          else

	jmp	$LN116@writeValue
$LN5@writeValue:

; 322  :          {
; 323  :             writeWithIndent( "{" );

	push	OFFSET ??_C@_01HCONENDN@?$HL?$AA@
	lea	ecx, DWORD PTR $T61818[esp+392]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR $T61818[esp+388]
	push	ecx
	mov	eax, ebx
	mov	BYTE PTR __$EHRec$[esp+400], 8
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	lea	ecx, DWORD PTR $T61818[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 6
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 324  :             indent();

	mov	edi, ebx
	call	?indent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::indent

; 325  :             Value::Members::iterator it = members.begin();

	lea	esi, DWORD PTR _it$19136[esp+388]
	lea	edi, DWORD PTR _members$19130[esp+388]
	call	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
$LL3@writeValue:

; 326  :             while ( true )
; 327  :             {
; 328  :                const std::string &name = *it;

	mov	esi, DWORD PTR _it$19136[esp+388]
	test	esi, esi
	jne	SHORT $LN36@writeValue
	call	__invalid_parameter_noinfo
$LN36@writeValue:
	mov	edi, DWORD PTR _it$19136[esp+392]
	cmp	edi, DWORD PTR [esi+8]
	jb	SHORT $LN35@writeValue
	call	__invalid_parameter_noinfo
$LN35@writeValue:

; 329  :                const Value &childValue = value[name];

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $LN45@writeValue
	mov	eax, DWORD PTR [edi+4]
	add	edi, 4
	jmp	SHORT $LN46@writeValue
$LN45@writeValue:
	add	edi, 4
	mov	eax, edi
$LN46@writeValue:
	mov	ecx, DWORD PTR _value$[ebp]
	push	eax
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]
	mov	esi, eax

; 330  :                writeCommentBeforeValue( childValue );

	push	esi
	push	ebx
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue

; 331  :                writeWithIndent( valueToQuotedString( name.c_str() ) );

	mov	edx, DWORD PTR _it$19136[esp+392]
	cmp	DWORD PTR [edx+24], 16			; 00000010H
	jb	SHORT $LN51@writeValue
	mov	edx, DWORD PTR [edi]
	jmp	SHORT $LN52@writeValue
$LN51@writeValue:
	mov	edx, edi
$LN52@writeValue:
	lea	ecx, DWORD PTR $T61819[esp+388]
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	push	eax
	mov	eax, ebx
	mov	BYTE PTR __$EHRec$[esp+400], 9
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	mov	BYTE PTR __$EHRec$[esp+396], 6
	cmp	DWORD PTR $T61819[esp+412], 16		; 00000010H
	jb	SHORT $LN69@writeValue
	mov	eax, DWORD PTR $T61819[esp+392]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN69@writeValue:

; 332  :                document_ += " : ";

	push	3
	lea	edi, DWORD PTR [ebx+20]
	push	OFFSET ??_C@_03MCPBMLDJ@?5?3?5?$AA@
	mov	eax, edi
	mov	DWORD PTR $T61819[esp+420], 15		; 0000000fH
	mov	DWORD PTR $T61819[esp+416], 0
	mov	BYTE PTR $T61819[esp+400], 0
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 333  :                writeValue( childValue );

	push	esi
	mov	ecx, ebx
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue

; 334  :                if ( ++it == members.end() )

	mov	eax, DWORD PTR _members$19130[esp+396]
	cmp	DWORD PTR _members$19130[esp+392], eax
	mov	DWORD PTR $T62044[esp+388], eax
	jbe	SHORT $LN90@writeValue
	call	__invalid_parameter_noinfo
$LN90@writeValue:
	mov	ecx, DWORD PTR _it$19136[esp+388]
	mov	edx, DWORD PTR _it$19136[esp+392]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN99@writeValue
	call	__invalid_parameter_noinfo
$LN99@writeValue:
	add	DWORD PTR _it$19136[esp+392], 28	; 0000001cH
	lea	eax, DWORD PTR _members$19130[esp+388]
	cmp	DWORD PTR _it$19136[esp+388], eax
	je	SHORT $LN104@writeValue
	call	__invalid_parameter_noinfo
$LN104@writeValue:
	mov	ecx, DWORD PTR $T62044[esp+388]
	cmp	DWORD PTR _it$19136[esp+392], ecx
	je	SHORT $LN114@writeValue

; 337  :                   break;
; 338  :                }
; 339  :                document_ += ",";

	push	1
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	eax, edi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 340  :                writeCommentAfterValueOnSameLine( childValue );

	push	esi
	push	ebx
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 341  :             }

	jmp	$LL3@writeValue
$LN114@writeValue:

; 335  :                {
; 336  :                   writeCommentAfterValueOnSameLine( childValue );

	push	esi
	push	ebx
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 342  :             unindent();

	mov	eax, ebx
	call	?unindent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::unindent

; 343  :             writeWithIndent( "}" );

	push	OFFSET ??_C@_01CELHOKLL@?$HN?$AA@
	lea	ecx, DWORD PTR $T61821[esp+392]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	edx, DWORD PTR $T61821[esp+388]
	push	edx
	mov	eax, ebx
	mov	BYTE PTR __$EHRec$[esp+400], 10		; 0000000aH
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	lea	ecx, DWORD PTR $T61821[esp+388]
$LN116@writeValue:
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 344  :          }
; 345  :       }

	lea	esi, DWORD PTR _members$19130[esp+388]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN14@writeValue:

; 346  :       break;
; 347  :    }
; 348  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN117@writeValue:
	DD	$LN13@writeValue
	DD	$LN12@writeValue
	DD	$LN11@writeValue
	DD	$LN10@writeValue
	DD	$LN9@writeValue
	DD	$LN8@writeValue
	DD	$LN7@writeValue
	DD	$LN6@writeValue
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T61811[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T61812[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T61813[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T61814[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T61815[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$5:
	lea	ecx, DWORD PTR $T61816[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$6:
	lea	esi, DWORD PTR _members$19130[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$7:
	lea	ecx, DWORD PTR $T61817[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$8:
	lea	ecx, DWORD PTR $T61818[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$9:
	lea	ecx, DWORD PTR $T61819[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$10:
	lea	ecx, DWORD PTR $T61821[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-372]
	mov	ecx, DWORD PTR [edx-376]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP	; Json::StyledWriter::writeValue
; Function compile flags: /Ogtpy
;	COMDAT ?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
_TEXT	SEGMENT
$T62102 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_root$ = 12						; size = 4
?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z PROC ; Json::StyledWriter::write, COMDAT
; _this$ = ecx

; 278  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx
	xor	ebx, ebx

; 279  :    document_ = "";

	push	ebx
	lea	edi, DWORD PTR [esi+20]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, edi
	mov	DWORD PTR $T62102[esp+28], ebx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 280  :    addChildValues_ = false;
; 281  :    indentString_ = "";

	push	ebx
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR [esi+48]
	mov	BYTE PTR [esi+84], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 282  :    writeCommentBeforeValue( root );

	mov	ebp, DWORD PTR _root$[esp+16]
	push	ebp
	push	esi
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue

; 283  :    writeValue( root );

	push	ebp
	mov	ecx, esi
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue

; 284  :    writeCommentAfterValueOnSameLine( root );

	push	ebp
	push	esi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 285  :    document_ += "\n";

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	eax, edi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 286  :    return document_;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+16]
	push	-1
	push	ebx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	push	edi
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 287  : }

	pop	ecx
	ret	8
?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ENDP ; Json::StyledWriter::write
_TEXT	ENDS
PUBLIC	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z	; Json::FastWriter::writeValue
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$6
__ehfuncinfo$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File f:\cygwin\home\charles\gusale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
__Cat$62857 = -252					; size = 1
_this$ = -252						; size = 4
_members$18950 = -248					; size = 16
$T62290 = -232						; size = 28
$T62283 = -204						; size = 28
$T62285 = -176						; size = 28
$T62286 = -148						; size = 28
$T62284 = -120						; size = 28
$T62287 = -92						; size = 28
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z PROC	; Json::FastWriter::writeValue, COMDAT
; _this$ = ecx

; 209  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	push	-1
	push	__ehhandler$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 296				; 00000128H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+324]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$[esp+324], ebx

; 210  :    switch ( value.type() )

	mov	ecx, DWORD PTR _value$[ebp]
	movsx	eax, BYTE PTR [ecx+8]
	cmp	eax, 7
	ja	$LN217@writeValue@2
	jmp	DWORD PTR $LN225@writeValue@2[eax*4]
$LN16@writeValue@2:

; 211  :    {
; 212  :    case nullValue:
; 213  :       document_ += "null";

	push	4
	push	OFFSET ??_C@_04MLLLIHIP@null?$AA@
	lea	eax, DWORD PTR [ebx+4]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 261  :       break;
; 262  :    }
; 263  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+324]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN15@writeValue@2:

; 214  :       break;
; 215  :    case intValue:
; 216  :       document_ += valueToString( value.asInt() );

	call	?asInt@Value@Json@@QBEHXZ		; Json::Value::asInt
	mov	ecx, eax
	lea	edi, DWORD PTR $T62283[esp+324]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::valueToString
	push	0
	push	eax
	lea	esi, DWORD PTR [ebx+4]
	or	eax, -1
	mov	DWORD PTR __$EHRec$[esp+340], 0
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	ecx, edi
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 261  :       break;
; 262  :    }
; 263  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+324]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN14@writeValue@2:

; 217  :       break;
; 218  :    case uintValue:
; 219  :       document_ += valueToString( value.asUInt() );

	call	?asUInt@Value@Json@@QBEIXZ		; Json::Value::asUInt
	mov	ecx, eax
	lea	edi, DWORD PTR $T62284[esp+324]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::valueToString
	push	0
	push	eax
	lea	esi, DWORD PTR [ebx+4]
	or	eax, -1
	mov	DWORD PTR __$EHRec$[esp+340], 1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	ecx, edi
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 261  :       break;
; 262  :    }
; 263  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+324]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN13@writeValue@2:

; 220  :       break;
; 221  :    case realValue:
; 222  :       document_ += valueToString( value.asDouble() );

	push	ecx
	call	?asDouble@Value@Json@@QBENXZ		; Json::Value::asDouble
	sub	esp, 8
	lea	esi, DWORD PTR $T62285[esp+332]
	fstp	QWORD PTR [esp]
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
	add	esp, 8
	push	0
	push	eax
	lea	esi, DWORD PTR [ebx+4]
	or	eax, -1
	mov	DWORD PTR __$EHRec$[esp+340], 2
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	lea	ecx, DWORD PTR $T62285[esp+324]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 261  :       break;
; 262  :    }
; 263  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+324]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN12@writeValue@2:

; 223  :       break;
; 224  :    case stringValue:
; 225  :       document_ += valueToQuotedString( value.asCString() );

	mov	edx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR $T62286[esp+324]
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	push	0
	push	eax
	lea	esi, DWORD PTR [ebx+4]
	or	eax, -1
	mov	DWORD PTR __$EHRec$[esp+340], 3
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	lea	ecx, DWORD PTR $T62286[esp+324]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 261  :       break;
; 262  :    }
; 263  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+324]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN11@writeValue@2:

; 226  :       break;
; 227  :    case booleanValue:
; 228  :       document_ += valueToString( value.asBool() );

	mov	eax, ecx
	call	?asBool@Value@Json@@QBE_NXZ		; Json::Value::asBool
	lea	esi, DWORD PTR $T62287[esp+324]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
	add	esp, 4
	push	0
	push	eax
	lea	esi, DWORD PTR [ebx+4]
	or	eax, -1
	mov	DWORD PTR __$EHRec$[esp+340], 4
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	lea	ecx, DWORD PTR $T62287[esp+324]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 261  :       break;
; 262  :    }
; 263  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+324]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN10@writeValue@2:

; 229  :       break;
; 230  :    case arrayValue:
; 231  :       {
; 232  :          document_ += "[";

	push	1
	add	ebx, 4
	push	OFFSET ??_C@_01OHGJGJJP@?$FL?$AA@
	mov	eax, ebx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 233  :          int size = value.size();

	mov	eax, DWORD PTR _value$[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	edi, eax

; 234  :          for ( int index =0; index < size; ++index )

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN7@writeValue@2
$LN9@writeValue@2:

; 235  :          {
; 236  :             if ( index > 0 )

	test	esi, esi
	jle	SHORT $LN66@writeValue@2

; 237  :                document_ += ",";

	push	1
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	eax, ebx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN66@writeValue@2:

; 238  :             writeValue( value[index] );

	mov	ecx, DWORD PTR _value$[ebp]
	push	esi
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	ecx, DWORD PTR _this$[esp+324]
	push	eax
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue
	add	esi, 1
	cmp	esi, edi
	jl	SHORT $LN9@writeValue@2
$LN7@writeValue@2:

; 239  :          }
; 240  :          document_ += "]";

	push	1
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	mov	eax, ebx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 261  :       break;
; 262  :    }
; 263  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+324]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN5@writeValue@2:

; 241  :       }
; 242  :       break;
; 243  :    case objectValue:
; 244  :       {
; 245  :          Value::Members members( value.getMemberNames() );

	lea	eax, DWORD PTR _members$18950[esp+324]
	push	eax
	call	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames

; 246  :          document_ += "{";

	push	1
	add	ebx, 4
	push	OFFSET ??_C@_01HCONENDN@?$HL?$AA@
	mov	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+340], 5
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 247  :          for ( Value::Members::iterator it = members.begin(); 

	mov	esi, DWORD PTR _members$18950[esp+328]
	cmp	esi, DWORD PTR _members$18950[esp+332]
	jbe	SHORT $LN89@writeValue@2
	call	__invalid_parameter_noinfo
$LN89@writeValue@2:
	mov	edi, esi
	npad	6

; 248  :                it != members.end(); 
; 249  :                ++it )

$LL100@writeValue@2:
	mov	eax, DWORD PTR _members$18950[esp+332]
	cmp	esi, eax
	jbe	SHORT $LN107@writeValue@2
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR _members$18950[esp+332]
$LN107@writeValue@2:
	cmp	edi, eax
	je	$LN2@writeValue@2

; 250  :          {
; 251  :             const std::string &name = *it;

	jb	SHORT $LN122@writeValue@2
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR _members$18950[esp+332]
$LN122@writeValue@2:

; 252  :             if ( it != members.begin() )

	cmp	esi, eax
	jbe	SHORT $LN131@writeValue@2
	call	__invalid_parameter_noinfo
$LN131@writeValue@2:
	cmp	edi, esi
	je	SHORT $LN144@writeValue@2

; 253  :                document_ += ",";

	push	1
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	eax, ebx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN144@writeValue@2:

; 254  :             document_ += valueToQuotedString( name.c_str() );

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $LN154@writeValue@2
	mov	edx, DWORD PTR [edi+4]
	jmp	SHORT $LN155@writeValue@2
$LN154@writeValue@2:
	lea	edx, DWORD PTR [edi+4]
$LN155@writeValue@2:
	lea	ecx, DWORD PTR $T62290[esp+324]
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	push	0
	push	eax
	or	eax, -1
	mov	esi, ebx
	mov	BYTE PTR __$EHRec$[esp+340], 6
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	BYTE PTR __$EHRec$[esp+332], 5
	cmp	DWORD PTR $T62290[esp+348], 16		; 00000010H
	jb	SHORT $LN176@writeValue@2
	mov	ecx, DWORD PTR $T62290[esp+328]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN176@writeValue@2:

; 255  :             document_ += yamlCompatiblityEnabled_ ? ": " 
; 256  :                                                   : ":";

	mov	edx, DWORD PTR _this$[esp+324]
	cmp	BYTE PTR [edx+32], 0
	mov	DWORD PTR $T62290[esp+348], 15		; 0000000fH
	mov	DWORD PTR $T62290[esp+344], 0
	mov	BYTE PTR $T62290[esp+328], 0
	mov	edx, OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
	jne	SHORT $LN22@writeValue@2
	mov	edx, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
$LN22@writeValue@2:
	mov	eax, edx
	lea	esi, DWORD PTR [eax+1]
$LL222@writeValue@2:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL222@writeValue@2
	sub	eax, esi
	push	eax
	push	edx
	mov	eax, ebx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 257  :             writeValue( value[name] );

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $LN198@writeValue@2
	mov	eax, DWORD PTR [edi+4]
	jmp	SHORT $LN199@writeValue@2
$LN198@writeValue@2:
	lea	eax, DWORD PTR [edi+4]
$LN199@writeValue@2:
	mov	ecx, DWORD PTR _value$[ebp]
	push	eax
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]
	mov	ecx, DWORD PTR _this$[esp+324]
	push	eax
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue
	cmp	edi, DWORD PTR _members$18950[esp+332]
	jb	SHORT $LN98@writeValue@2

; 248  :                it != members.end(); 
; 249  :                ++it )

	call	__invalid_parameter_noinfo
$LN98@writeValue@2:
	mov	esi, DWORD PTR _members$18950[esp+328]
	add	edi, 28					; 0000001cH
	jmp	$LL100@writeValue@2
$LN2@writeValue@2:

; 258  :          }
; 259  :          document_ += "}";

	push	1
	push	OFFSET ??_C@_01CELHOKLL@?$HN?$AA@
	mov	eax, ebx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 260  :       }

	test	esi, esi
	je	SHORT $LN217@writeValue@2
	mov	eax, DWORD PTR __Cat$62857[esp+324]
	mov	edi, DWORD PTR _members$18950[esp+332]
	push	eax
	mov	eax, esi
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN217@writeValue@2:

; 261  :       break;
; 262  :    }
; 263  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+324]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN225@writeValue@2:
	DD	$LN16@writeValue@2
	DD	$LN15@writeValue@2
	DD	$LN14@writeValue@2
	DD	$LN13@writeValue@2
	DD	$LN12@writeValue@2
	DD	$LN11@writeValue@2
	DD	$LN10@writeValue@2
	DD	$LN5@writeValue@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T62283[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T62284[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T62285[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T62286[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T62287[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$5:
	lea	esi, DWORD PTR _members$18950[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$6:
	lea	ecx, DWORD PTR $T62290[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-308]
	mov	ecx, DWORD PTR [edx-312]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ENDP	; Json::FastWriter::writeValue
; Function compile flags: /Ogtpy
;	COMDAT ?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
_TEXT	SEGMENT
$T62879 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_root$ = 12						; size = 4
?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z PROC ; Json::FastWriter::write, COMDAT
; _this$ = ecx

; 199  : {

	push	ecx
	push	esi
	push	edi
	mov	esi, ecx

; 200  :    document_ = "";

	push	0
	lea	edi, DWORD PTR [esi+4]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, edi
	mov	DWORD PTR $T62879[esp+20], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 201  :    writeValue( root );

	mov	eax, DWORD PTR _root$[esp+8]
	push	eax
	mov	ecx, esi
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue

; 202  :    document_ += "\n";

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	eax, edi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 203  :    return document_;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	push	-1
	push	0
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	push	edi
	mov	ecx, esi
	mov	BYTE PTR [esi+4], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	mov	eax, esi
	pop	esi

; 204  : }

	pop	ecx
	ret	8
?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ENDP ; Json::FastWriter::write
; Function compile flags: /Ogtpy
;	COMDAT ?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
_isMultiLine$ = -9					; size = 1
_this$ = -8						; size = 4
tv515 = -4						; size = 4
__Cat$63247 = 8						; size = 1
_value$ = 8						; size = 4
?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z PROC ; Json::StyledWriter::isMultineArray, COMDAT
; _this$ = ecx

; 406  : {

	sub	esp, 12					; 0000000cH

; 407  :    int size = value.size();

	mov	eax, DWORD PTR _value$[esp+8]
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], ebp
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size

; 408  :    bool isMultiLine = size*3 >= rightMargin_ ;
; 409  :    childValues_.clear();

	mov	esi, DWORD PTR [ebp+12]
	mov	ebx, eax
	lea	eax, DWORD PTR [ebx+ebx*2]
	cmp	eax, DWORD PTR [ebp+76]
	setge	BYTE PTR _isMultiLine$[esp+28]
	add	ebp, 4
	cmp	DWORD PTR [ebp+4], esi
	jbe	SHORT $LN25@isMultineA
	call	__invalid_parameter_noinfo
$LN25@isMultineA:
	mov	edi, DWORD PTR [ebp+4]
	cmp	edi, DWORD PTR [ebp+8]
	jbe	SHORT $LN37@isMultineA
	call	__invalid_parameter_noinfo
$LN37@isMultineA:
	cmp	edi, esi
	je	SHORT $LN44@isMultineA
	mov	eax, edi
	mov	edi, DWORD PTR [ebp+8]
	mov	ecx, esi
	call	??$unchecked_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z ; stdext::unchecked_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	mov	ecx, DWORD PTR __Cat$63247[esp+24]
	mov	edi, DWORD PTR [ebp+8]
	push	ecx
	mov	esi, eax
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 4
	mov	DWORD PTR [ebp+8], esi
$LN44@isMultineA:

; 410  :    for ( int index =0; index < size  &&  !isMultiLine; ++index )

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN5@isMultineA
	npad	5
$LL100@isMultineA:
	mov	al, BYTE PTR _isMultiLine$[esp+28]
	test	al, al
	jne	$LN16@isMultineA

; 411  :    {
; 412  :       const Value &childValue = value[index];

	mov	ecx, DWORD PTR _value$[esp+24]
	push	esi
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]

; 413  :       isMultiLine = isMultiLine  ||
; 414  :                      ( (childValue.isArray()  ||  childValue.isObject())  &&  
; 415  :                         childValue.size() > 0 );

	mov	cl, BYTE PTR [eax+8]
	test	cl, cl
	je	SHORT $LN65@isMultineA
	cmp	cl, 6
	je	SHORT $LN65@isMultineA
	cmp	cl, 7
	jne	SHORT $LN11@isMultineA
$LN65@isMultineA:
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	test	eax, eax
	ja	SHORT $LN12@isMultineA
$LN11@isMultineA:
	mov	BYTE PTR _isMultiLine$[esp+28], 0
	jmp	SHORT $LN13@isMultineA
$LN12@isMultineA:
	mov	BYTE PTR _isMultiLine$[esp+28], 1
$LN13@isMultineA:

; 410  :    for ( int index =0; index < size  &&  !isMultiLine; ++index )

	add	esi, 1
	cmp	esi, ebx
	jl	SHORT $LL100@isMultineA
$LN5@isMultineA:

; 416  :    }
; 417  :    if ( !isMultiLine ) // check if line length > max line length

	mov	al, BYTE PTR _isMultiLine$[esp+28]
	test	al, al
	jne	$LN16@isMultineA

; 418  :    {
; 419  :       childValues_.reserve( size );

	push	ebx
	mov	ecx, ebp
	call	?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve

; 420  :       addChildValues_ = true;

	mov	edx, DWORD PTR _this$[esp+28]

; 421  :       int lineLength = 4 + (size-1)*2; // '[ ' + ', '*n + ' ]'
; 422  :       for ( int index =0; index < size  &&  !isMultiLine; ++index )

	xor	esi, esi
	test	ebx, ebx
	mov	BYTE PTR [edx+84], 1
	lea	edi, DWORD PTR [ebx+ebx+2]
	jle	SHORT $LN101@isMultineA

; 418  :    {
; 419  :       childValues_.reserve( size );

	mov	DWORD PTR tv515[esp+28], esi
	npad	3
$LL3@isMultineA:

; 423  :       {
; 424  :          writeValue( value[index] );

	mov	ecx, DWORD PTR _value$[esp+24]
	push	esi
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	ecx, DWORD PTR _this$[esp+28]
	push	eax
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue

; 425  :          lineLength += int( childValues_[index].length() );

	mov	eax, DWORD PTR [ebp+4]
	test	eax, eax
	je	SHORT $LN97@isMultineA
	mov	ecx, DWORD PTR [ebp+8]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jb	SHORT $LN67@isMultineA
$LN97@isMultineA:
	call	__invalid_parameter_noinfo
$LN67@isMultineA:
	mov	eax, DWORD PTR tv515[esp+28]
	mov	ecx, DWORD PTR [ebp+4]
	add	edi, DWORD PTR [eax+ecx+20]
	add	esi, 1
	add	eax, 28					; 0000001cH
	cmp	esi, ebx
	mov	DWORD PTR tv515[esp+28], eax
	jl	SHORT $LL3@isMultineA
$LN101@isMultineA:

; 426  :          isMultiLine = isMultiLine  &&  hasCommentForValue( value[index] );
; 427  :       }
; 428  :       addChildValues_ = false;

	mov	eax, DWORD PTR _this$[esp+28]

; 429  :       isMultiLine = isMultiLine  ||  lineLength >= rightMargin_;

	cmp	edi, DWORD PTR [eax+76]
	mov	BYTE PTR [eax+84], 0
	setge	al
$LN16@isMultineA:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 430  :    }
; 431  :    return isMultiLine;
; 432  : }

	add	esp, 12					; 0000000cH
	ret	4
?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledWriter::isMultineArray
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
END
