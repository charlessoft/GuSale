; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	f:\cygwin\home\Charles\GuSale\gusale\lib\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat


PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	??0?$allocator@PAVValue@Json@@@std@@QAE@XZ	; std::allocator<Json::Value *>::allocator<Json::Value *>
PUBLIC	??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>
PUBLIC	??0?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_map<Json::Value *,std::allocator<Json::Value *> >::_Deque_map<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Value *>::allocator<Json::Value *>
PUBLIC	??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
PUBLIC	??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>
PUBLIC	??0?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
PUBLIC	??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?is@?$ctype@D@std@@QBE_NFD@Z			; std::ctype<char>::is
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
PUBLIC	?_Register@facet@locale@std@@QAEXXZ		; std::locale::facet::_Register
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z	; std::ctype<char>::_Do_widen_s
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z	; std::ctype<char>::_Do_narrow_s
PUBLIC	??_Gfacet@locale@std@@UAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??1facet@locale@std@@UAE@XZ			; std::locale::facet::~facet
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??0?$ctype@D@std@@QAE@PBF_NI@Z			; std::ctype<char>::ctype<char>
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z ; std::ctype<char>::_Getcat
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
PUBLIC	?_Incref@facet@locale@std@@QAEXXZ		; std::locale::facet::_Incref
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
PUBLIC	?_Decref@facet@locale@std@@QAEPAV123@XZ		; std::locale::facet::_Decref
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
PUBLIC	?fail@ios_base@std@@QBE_NXZ			; std::ios_base::fail
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
PUBLIC	??0failure@ios_base@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
PUBLIC	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
PUBLIC	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
PUBLIC	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
PUBLIC	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty
PUBLIC	?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z ; std::_Allocate<Json::Value *>
PUBLIC	?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::allocate
PUBLIC	??$_Construct@PAVValue@Json@@PAV12@@std@@YAXPAPAVValue@Json@@ABQAV12@@Z ; std::_Construct<Json::Value *,Json::Value *>
PUBLIC	?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z ; std::allocator<Json::Value *>::construct
PUBLIC	??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z ; std::_Allocate<Json::Value * *>
PUBLIC	?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::allocate
PUBLIC	?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ ; std::allocator<Json::Value *>::max_size
PUBLIC	?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
PUBLIC	?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@KAXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
PUBLIC	??$_Uninit_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
PUBLIC	??$_Iter_cat@PAPAPAVValue@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAPAVValue@Json@@@Z ; std::_Iter_cat<Json::Value * * *>
PUBLIC	??$_Checked_base@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Json::Value * * *>
PUBLIC	??$_Checked_base@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAPAV12@@Z ; std::_Checked_base<Json::Value * * *>
PUBLIC	??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
PUBLIC	??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
PUBLIC	??$unchecked_fill_n@PAPAPAVValue@Json@@IPAPAV12@@stdext@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z ; stdext::unchecked_fill_n<Json::Value * * *,unsigned int,Json::Value * *>
PUBLIC	??$_Uninit_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >
PUBLIC	??$_Ptr_cat@PAPAPAVValue@Json@@PAPAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAPAVValue@Json@@0@Z ; std::_Ptr_cat<Json::Value * * *,Json::Value * * *>
PUBLIC	??$_Destroy_range@PAPAVValue@Json@@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<Json::Value * *,std::allocator<Json::Value * *> >
PUBLIC	??$_Destroy_range@PAPAVValue@Json@@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z ; std::_Destroy_range<Json::Value * *,std::allocator<Json::Value * *> >
PUBLIC	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
PUBLIC	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
PUBLIC	?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push
PUBLIC	?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?assign@?$char_traits@D@std@@SAPADPADID@Z	; std::char_traits<char>::assign
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	??0ErrorInfo@Reader@Json@@QAE@XZ		; Json::Reader::ErrorInfo::ErrorInfo
PUBLIC	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
PUBLIC	?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@V32@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
PUBLIC	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBU_Container_base@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
PUBLIC	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
PUBLIC	?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front
PUBLIC	?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
PUBLIC	??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo>
PUBLIC	?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::allocate
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z		; Json::Reader::ErrorInfo::ErrorInfo
PUBLIC	??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
PUBLIC	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct
PUBLIC	??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo *>
PUBLIC	?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocate
PUBLIC	?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ ; std::allocator<Json::Reader::ErrorInfo>::max_size
PUBLIC	?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@KAXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
PUBLIC	??$_Uninit_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$_Iter_cat@PAPAVErrorInfo@Reader@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@@Z ; std::_Iter_cat<Json::Reader::ErrorInfo * *>
PUBLIC	??$_Checked_base@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Json::Reader::ErrorInfo * *>
PUBLIC	??$_Checked_base@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@@Z ; std::_Checked_base<Json::Reader::ErrorInfo * *>
PUBLIC	??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
PUBLIC	??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
PUBLIC	??$unchecked_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@stdext@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z ; stdext::unchecked_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
PUBLIC	??$_Uninit_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$_Ptr_cat@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVErrorInfo@Reader@Json@@0@Z ; std::_Ptr_cat<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
PUBLIC	??$_Destroy_range@PAVErrorInfo@Reader@Json@@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$_Destroy_range@PAVErrorInfo@Reader@Json@@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ; std::_Destroy_range<Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
PUBLIC	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
PUBLIC	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
PUBLIC	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
PUBLIC	??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
PUBLIC	??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
PUBLIC	??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator*
PUBLIC	??A?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator[]
PUBLIC	??Z?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-=
PUBLIC	??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
PUBLIC	??F?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator--
PUBLIC	??F?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator--
PUBLIC	??$_Copy_backward_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::forward_iterator_tag>
PUBLIC	??$_Copy_backward_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$copy_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V10@00@Z ; std::copy_backward<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$_Iter_random@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0@Z ; std::_Iter_random<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$_Ptr_cat@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$_Checked_cat@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AU_Range_checked_iterator_tag@0@ABV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_cat<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator-
PUBLIC	??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator-
PUBLIC	??$_Copy_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::forward_iterator_tag>
PUBLIC	??$_Copy_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$copy@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V10@00@Z ; std::copy<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@IPBU_Container_base@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>
PUBLIC	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@IPBU_Container_base@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>
PUBLIC	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>
PUBLIC	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>
PUBLIC	?_Checked_iterator_base@?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z	; Json::Reader::ErrorInfo::operator=
PUBLIC	??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator==
PUBLIC	??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator!=
PUBLIC	??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*
PUBLIC	??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*
PUBLIC	??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator++
PUBLIC	??E?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator++
PUBLIC	??$_Fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0ABVErrorInfo@Reader@Json@@@Z ; std::_Fill<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,Json::Reader::ErrorInfo>
PUBLIC	??$fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0ABVErrorInfo@Reader@Json@@@Z ; std::fill<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,Json::Reader::ErrorInfo>
PUBLIC	?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Insert_n
PUBLIC	??Y?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+=
PUBLIC	??Y?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+=
PUBLIC	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
PUBLIC	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@ABV01@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
PUBLIC	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
PUBLIC	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
PUBLIC	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
PUBLIC	?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
PUBLIC	??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBU_Container_base@1@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>
PUBLIC	??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBU_Container_base@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>
PUBLIC	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
PUBLIC	??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator*
PUBLIC	??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator*
PUBLIC	??Y?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+=
PUBLIC	??Y?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+=
PUBLIC	??Z?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-=
PUBLIC	??0?$_Ranit@PAVValue@Json@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Json::Value *,int,Json::Value * const *,Json::Value * const &>::_Ranit<Json::Value *,int,Json::Value * const *,Json::Value * const &>
PUBLIC	??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>
PUBLIC	??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@ABV01@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>
PUBLIC	??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-
PUBLIC	?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
PUBLIC	?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
PUBLIC	??0_Iterator_base@std@@QAE@XZ			; std::_Iterator_base::_Iterator_base
PUBLIC	??0?$_Ranit@VErrorInfo@Reader@Json@@HPBV123@ABV123@@std@@QAE@XZ ; std::_Ranit<Json::Reader::ErrorInfo,int,Json::Reader::ErrorInfo const *,Json::Reader::ErrorInfo const &>::_Ranit<Json::Reader::ErrorInfo,int,Json::Reader::ErrorInfo const *,Json::Reader::ErrorInfo const &>
PUBLIC	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBU_Container_base@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
PUBLIC	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator*
PUBLIC	??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator++
PUBLIC	??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator==
PUBLIC	??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator!=
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Move_s
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?what@runtime_error@std@@UBEPBDXZ		; std::runtime_error::what
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::deallocate
PUBLIC	?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::deallocate
PUBLIC	??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z ; std::_Destroy<Json::Value * *>
PUBLIC	?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z ; std::allocator<Json::Value * *>::destroy
PUBLIC	??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z ; std::_Destroy<Json::Value *>
PUBLIC	?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ; std::allocator<Json::Value *>::destroy
PUBLIC	?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
PUBLIC	?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
PUBLIC	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
PUBLIC	??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::deallocate
PUBLIC	?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::deallocate
PUBLIC	??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z ; std::_Destroy<Json::Reader::ErrorInfo *>
PUBLIC	?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo *>::destroy
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ; std::_Char_traits_cat<std::char_traits<char> >
PUBLIC	?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Copy_s
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1ErrorInfo@Reader@Json@@QAE@XZ		; Json::Reader::ErrorInfo::~ErrorInfo
PUBLIC	??_GErrorInfo@Reader@Json@@QAEPAXI@Z		; Json::Reader::ErrorInfo::`scalar deleting destructor'
PUBLIC	??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z ; std::_Destroy<Json::Reader::ErrorInfo>
PUBLIC	?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::destroy
PUBLIC	?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
PUBLIC	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
PUBLIC	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
PUBLIC	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??1Reader@Json@@QAE@XZ				; Json::Reader::~Reader
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@	; `string'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	??_C@_01GFHCPBMG@C?$AA@				; `string'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ ; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@	; `string'
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z40
PUBLIC	__CTA3?AVfailure@ios_base@std@@
PUBLIC	__TI3?AVfailure@ios_base@std@@
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@ ; `string'
PUBLIC	??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ ; `string'
PUBLIC	??_C@_03FFDNHNKN@rue?$AA@			; `string'
PUBLIC	??_C@_04KCECFHEP@alse?$AA@			; `string'
PUBLIC	??_C@_03KNPGGKC@ull?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ ; `string'
PUBLIC	??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ ; `string'
PUBLIC	??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ ; `string'
PUBLIC	??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ ; `string'
PUBLIC	??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ ; `string'
PUBLIC	??_C@_01GEODFPGF@?8?$AA@			; `string'
PUBLIC	??_C@_03DLDNIBIK@?$CFlf?$AA@			; `string'
PUBLIC	??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@ ; `string'
PUBLIC	??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@ ; `string'
PUBLIC	??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_02KAOAMBHJ@?$CK?5?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@	; `string'
PUBLIC	??_C@_04JBAOJHKB@See?5?$AA@			; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??0bad_cast@std@@QAE@PBD@Z:PROC			; std::bad_cast::bad_cast
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?facet_Register@facet@locale@std@@CAXPAV123@@Z:PROC ; std::locale::facet::facet_Register
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	__Getctype:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	??_Efacet@locale@std@@UAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_free:PROC
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??1bad_cast@std@@UAE@XZ:PROC			; std::bad_cast::~bad_cast
EXTRN	??0bad_cast@std@@QAE@ABV01@@Z:PROC		; std::bad_cast::bad_cast
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	?_Lock@_Mutex@std@@QAEXXZ:PROC			; std::_Mutex::_Lock
EXTRN	?_Unlock@_Mutex@std@@QAEXXZ:PROC		; std::_Mutex::_Unlock
EXTRN	_sscanf:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	_sprintf:PROC
EXTRN	__invalid_parameter_noinfo:PROC
EXTRN	??0exception@std@@QAE@XZ:PROC			; std::exception::exception
EXTRN	?_Xran@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xran
EXTRN	_memmove_s:PROC
EXTRN	?_Xlen@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xlen
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_memcpy_s:PROC
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@runtime_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
	DD	FLAT:?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@runtime_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JBAOJHKB@See?5?$AA@
CONST	SEGMENT
??_C@_04JBAOJHKB@See?5?$AA@ DB 'See ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
CONST	SEGMENT
??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@ DB ' for detail.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAOAMBHJ@?$CK?5?$AA@
CONST	SEGMENT
??_C@_02KAOAMBHJ@?$CK?5?$AA@ DB '* ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ DB 'Line %d, Column '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: hexadecimal digit expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: four digits expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@
CONST	SEGMENT
??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@ DB 'expecting '
	DB	'another \u token to begin the second half of a unicode surrog'
	DB	'ate pair', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@
CONST	SEGMENT
??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@ DB 'additional si'
	DB	'x characters expected to parse unicode surrogate pair.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT
??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@ DB 'Bad escape '
	DB	'sequence in string', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT
??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ DB 'Empty esc'
	DB	'ape sequence in string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf?$AA@
CONST	SEGMENT
??_C@_03DLDNIBIK@?$CFlf?$AA@ DB '%lf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8?$AA@
CONST	SEGMENT
??_C@_01GEODFPGF@?8?$AA@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
CONST	SEGMENT
??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ DB ''' is not a number.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
CONST	SEGMENT
??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ DB 'Mi'
	DB	'ssing '','' or '']'' in array declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
CONST	SEGMENT
??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ DB 'Missin'
	DB	'g ''}'' or object member name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
CONST	SEGMENT
??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ DB 'Mi'
	DB	'ssing '','' or ''}'' in object declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
CONST	SEGMENT
??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ DB 'Missing '
	DB	''':'' after object member name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KNPGGKC@ull?$AA@
CONST	SEGMENT
??_C@_03KNPGGKC@ull?$AA@ DB 'ull', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KCECFHEP@alse?$AA@
CONST	SEGMENT
??_C@_04KCECFHEP@alse?$AA@ DB 'alse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFDNHNKN@rue?$AA@
CONST	SEGMENT
??_C@_03FFDNHNKN@rue?$AA@ DB 'rue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
CONST	SEGMENT
??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ DB 'Syntax err'
	DB	'or: value, object or array expected.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@
CONST	SEGMENT
??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@ DB 'A valid JS'
	DB	'ON document must be either an array or an object value.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT __TI3?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI3?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA3?AVfailure@ios_base@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z40
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z40
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z40 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ DB 'ios_base::failbit se'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT
??_C@_01GFHCPBMG@C?$AA@ DB 'C', 00H			; `string'
CONST	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
;	COMDAT ??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ
_TEXT	SEGMENT
__Secure$ = -1						; size = 1
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ PROC ; std::_Char_traits_cat<std::char_traits<char> >, COMDAT

; 568  : 	{

	push	ecx

; 569  : 		typename _Char_traits_category<_Traits>::_Secure_char_traits _Secure;
; 570  : 		return (_Secure);

	mov	al, BYTE PTR __Secure$[esp+4]

; 571  : 	}

	pop	ecx
	ret	0
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ENDP ; std::_Char_traits_cat<std::char_traits<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 166  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 167  : 		return (0 < _Count ? _Count : 1);

	or	eax, -1

; 168  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 174  : 		_Mylock._Lock();

	add	ecx, 4
	jmp	?_Lock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Lock
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ios
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = eax

; 73   : 		return (_Tiestr);

	mov	eax, DWORD PTR [eax+44]

; 74   : 		}

	ret	0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 141  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 142  : 		}

	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1604 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1605 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1606 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ
_TEXT	SEGMENT
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT
; _this$ = eax

; 247  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	ecx, DWORD PTR [eax+32]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Gnavail
	mov	edx, DWORD PTR [eax+48]
	mov	eax, DWORD PTR [edx]

; 248  : 		}

	ret	0
$LN3@Gnavail:

; 247  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	xor	eax, eax

; 248  : 		}

	ret	0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 235  : 		--*_IGcount;

	mov	eax, DWORD PTR [ecx+48]
	add	DWORD PTR [eax], -1

; 236  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx

; 237  : 		}

	ret	0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = eax

; 191  : 		return (*_IGnext);

	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [ecx]

; 192  : 		}

	ret	0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 179  : 		_Mylock._Unlock();

	add	ecx, 4
	jmp	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 101  : 		return (sync());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+48]
	jmp	edx
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 124  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 125  : 		{	// construct by copying (do nothing)
; 126  : 		}

	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 120  : 	allocator() _THROW0()

	mov	eax, ecx

; 121  : 		{	// construct default allocator (do nothing)
; 122  : 		}

	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 471  : 		}

	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2055 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx+4]

; 2056 : 		}

	ret	0
$LN3@Myptr:

; 2055 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	lea	eax, DWORD PTR [ecx+4]

; 2056 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2050 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr@2
	mov	eax, DWORD PTR [ecx+4]

; 2051 : 		}

	ret	0
$LN3@Myptr@2:

; 2050 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	lea	eax, DWORD PTR [ecx+4]

; 2051 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ios
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = eax

; 85   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+40]

; 86   : 		}

	ret	0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 1638 : 		return (_Mysize == 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+20], eax
	sete	al

; 1639 : 		}

	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1599 : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+20]

; 1600 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = eax

; 1594 : 		return (_Mysize);

	mov	eax, DWORD PTR [eax+20]

; 1595 : 		}

	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1584 : 		return (_Myptr());

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN5@c_str
	mov	eax, DWORD PTR [ecx+4]

; 1585 : 		}

	ret	0

; 1584 : 		return (_Myptr());

$LN5@c_str:
	lea	eax, DWORD PTR [ecx+4]

; 1585 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = eax
; __Off$ = edi

; 1490 : 		{	// subscript mutable sequence

	push	esi
	mov	esi, eax

; 1491 : 
; 1492 :  #if _HAS_ITERATOR_DEBUGGING
; 1493 : 		// skip debug checks if the container is initizialed with _IGNORE_MYITERLIST
; 1494 : 		if (this->_Myfirstiter != _IGNORE_MYITERLIST)
; 1495 : 			{
; 1496 : 			if (_Mysize < _Off)
; 1497 : 				{
; 1498 : 				_DEBUG_ERROR("string subscript out of range");
; 1499 : 				_SCL_SECURE_OUT_OF_RANGE;
; 1500 : 				}
; 1501 : 			}
; 1502 :  #else
; 1503 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= _Mysize);

	cmp	edi, DWORD PTR [esi+20]
	jbe	SHORT $LN1@operator@16
	call	__invalid_parameter_noinfo
$LN1@operator@16:

; 1504 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1505 : 
; 1506 : 		return (_Myptr()[_Off]);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN6@operator@16
	mov	esi, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+edi]
	pop	esi

; 1507 : 		}

	ret	0

; 1504 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1505 : 
; 1506 : 		return (_Myptr()[_Off]);

$LN6@operator@16:
	lea	eax, DWORD PTR [esi+edi+4]
	pop	esi

; 1507 : 		}

	ret	0
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = eax

; 362  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [eax+16]

; 363  : 		}

	ret	0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = eax

; 299  : 		return (_Mystate);

	mov	eax, DWORD PTR [eax+8]

; 300  : 		}

	ret	0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
__Dest_size$ = 24					; size = 4
?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z PROC	; std::ctype<char>::_Do_narrow_s, COMDAT
; _this$ = ecx

; 1854 : 		{	// narrow elements in [_First, _Last) to chars

	push	ebx

; 1855 : 		_DEBUG_RANGE(_First, _Last);
; 1856 : 		_DEBUG_POINTER(_Dest);
; 1857 : 		_SCL_SECURE_ALWAYS_VALIDATE_RANGE(_Dest_size >= (size_t)(_Last - _First));

	mov	ebx, DWORD PTR __First$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Dest_size$[esp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+12]
	mov	esi, edi
	sub	esi, ebx
	cmp	ebp, esi
	jae	SHORT $LN1@Do_narrow_
	call	__invalid_parameter_noinfo
$LN1@Do_narrow_:

; 1858 : 		_CRT_SECURE_MEMCPY(_Dest, _Dest_size, _First, _Last - _First);

	mov	eax, DWORD PTR __Dest$[esp+12]
	push	esi
	push	ebx
	push	ebp
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 1859 : 		return (_Last);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1860 : 		}

	ret	20					; 00000014H
?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z ENDP	; std::ctype<char>::_Do_narrow_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dflt$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 1847 : 		// assume there is enough space in _Dest
; 1848 : 		return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx]
	push	edi
	mov	edi, eax
	sub	edi, edx
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	push	edi
	mov	edi, DWORD PTR __Dflt$[esp+12]
	push	edi
	push	eax
	mov	eax, DWORD PTR [esi+40]
	push	edx
	call	eax
	pop	edi
	pop	esi

; 1849 : 		}

	ret	16					; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 1839 : 		return (_Ch);

	mov	al, BYTE PTR __Ch$[esp-4]

; 1840 : 		}

	ret	8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Dest_size$ = 20					; size = 4
?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z PROC	; std::ctype<char>::_Do_widen_s, COMDAT
; _this$ = ecx

; 1829 : 		{	// widen chars in [_First, _Last)

	push	ebx

; 1830 : 		_DEBUG_RANGE(_First, _Last);
; 1831 : 		_DEBUG_POINTER(_Dest);
; 1832 : 		_SCL_SECURE_ALWAYS_VALIDATE_RANGE(_Dest_size >= (size_t)(_Last - _First));

	mov	ebx, DWORD PTR __First$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Dest_size$[esp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+12]
	mov	esi, edi
	sub	esi, ebx
	cmp	ebp, esi
	jae	SHORT $LN1@Do_widen_s
	call	__invalid_parameter_noinfo
$LN1@Do_widen_s:

; 1833 : 		_CRT_SECURE_MEMCPY(_Dest, _Dest_size, _First, _Last - _First);

	mov	eax, DWORD PTR __Dest$[esp+12]
	push	esi
	push	ebx
	push	ebp
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 1834 : 		return (_Last);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1835 : 		}

	ret	16					; 00000010H
?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z ENDP	; std::ctype<char>::_Do_widen_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 1823 : 		// assume there is enough space in _Dest
; 1824 : 		return _Do_widen_s(_First, _Last, _Dest, _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx]
	push	edi
	mov	edi, eax
	sub	edi, edx
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	push	edi
	push	eax
	mov	eax, DWORD PTR [esi+28]
	push	edx
	call	eax
	pop	edi
	pop	esi

; 1825 : 		}

	ret	12					; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 1816 : 		return (_Byte);

	mov	al, BYTE PTR __Byte$[esp-4]

; 1817 : 		}

	ret	4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 1807 : 		{	// convert [_First, _Last) in place to upper case

	push	ebx

; 1808 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 1809 : 		for (; _First != _Last; ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN8@do_toupper
	push	edi
	lea	edi, DWORD PTR [ecx+8]
$LL3@do_toupper:

; 1810 : 			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

	movzx	eax, BYTE PTR [esi]
	push	edi
	push	eax
	call	__Toupper
	mov	BYTE PTR [esi], al
	add	esi, 1
	add	esp, 8
	cmp	esi, ebx
	jne	SHORT $LL3@do_toupper
	pop	edi
$LN8@do_toupper:

; 1811 : 		return ((const _Elem *)_First);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1812 : 		}

	ret	8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 1802 : 		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

	movzx	eax, BYTE PTR __Ch$[esp-4]
	add	ecx, 8
	push	ecx
	push	eax
	call	__Toupper
	add	esp, 8

; 1803 : 		}

	ret	4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 1793 : 		{	// convert [_First, _Last) in place to lower case

	push	ebx

; 1794 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 1795 : 		for (; _First != _Last; ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN8@do_tolower
	push	edi
	lea	edi, DWORD PTR [ecx+8]
$LL3@do_tolower:

; 1796 : 			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

	movzx	eax, BYTE PTR [esi]
	push	edi
	push	eax
	call	__Tolower
	mov	BYTE PTR [esi], al
	add	esi, 1
	add	esp, 8
	cmp	esi, ebx
	jne	SHORT $LL3@do_tolower
	pop	edi
$LN8@do_tolower:

; 1797 : 		return ((const _Elem *)_First);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1798 : 		}

	ret	8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 1788 : 		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

	movzx	eax, BYTE PTR __Ch$[esp-4]
	add	ecx, 8
	push	ecx
	push	eax
	call	__Tolower
	add	esp, 8

; 1789 : 		}

	ret	4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 1780 : 		if (0 < _Ctype._Delfl)

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	jle	SHORT $LN6@Tidy

; 1781 : 			free((void *)_Ctype._Table);

	mov	eax, DWORD PTR [ecx+16]
	push	eax
	call	_free
	add	esp, 4

; 1784 : 		}

	ret	0
$LN6@Tidy:

; 1782 : 		else if (_Ctype._Delfl < 0)

	jge	SHORT $LN1@Tidy

; 1783 : 			delete[] (void *)_Ctype._Table;

	mov	ecx, DWORD PTR [ecx+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN1@Tidy:

; 1784 : 		}

	ret	0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = eax
; __Id$ = esi

; 397  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 398  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	mov	ecx, DWORD PTR [eax]
	cmp	esi, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Getfacet
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+esi*4]

; 399  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	eax, eax
	jne	SHORT $LN1@Getfacet
$LN10@Getfacet:
	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN1@Getfacet

; 400  : 			return (_Facptr);	// found facet or not transparent, return pointer
; 401  : 		else
; 402  : 			{	// look in current locale
; 403  : 			locale::_Locimp *_Ptr = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 404  : 			return (_Id < _Ptr->_Facetcount
; 405  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 406  : 				: 0);	// no entry in current locale

	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN8@Getfacet
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+esi*4]

; 407  : 			}
; 408  : 		}

	ret	0
$LN6@Getfacet:

; 397  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 398  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	xor	eax, eax

; 399  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	jmp	SHORT $LN10@Getfacet
$LN8@Getfacet:

; 404  : 			return (_Id < _Ptr->_Facetcount
; 405  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 406  : 				: 0);	// no entry in current locale

	xor	eax, eax
$LN1@Getfacet:

; 407  : 			}
; 408  : 		}

	ret	0
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 171  : 			{	// construct with initial reference count

	mov	eax, ecx
	mov	ecx, DWORD PTR __Initrefs$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
	mov	DWORD PTR [eax+4], ecx

; 172  : 			}

	ret	4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@UAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 165  : 			{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@

; 166  : 			}

	ret	0
??1facet@locale@std@@UAE@XZ ENDP			; std::locale::facet::~facet
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Register@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
?_Register@facet@locale@std@@QAEXXZ PROC		; std::locale::facet::_Register, COMDAT
; _this$ = eax

; 134  : 			facet_Register(this);

	push	eax
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	pop	ecx

; 135  : 			}

	ret	0
?_Register@facet@locale@std@@QAEXXZ ENDP		; std::locale::facet::_Register
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT
__Lock$9016 = -4					; size = 4
?_Decref@facet@locale@std@@QAEPAV123@XZ PROC		; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 124  : 			{	// safely decrement the reference count, return this when dead

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 125  : 			_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$9016[esp+16]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 126  : 				if (0 < _Refs && _Refs < (size_t)(-1))

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN1@Decref
	cmp	eax, -1
	jae	SHORT $LN1@Decref

; 127  : 					--_Refs;

	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN1@Decref:

; 128  : 				return (_Refs == 0 ? this : 0);

	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$9016[esp+12]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	edi
	mov	eax, esi
	pop	esi

; 129  : 			_END_LOCK()
; 130  : 			}

	pop	ecx
	ret	0
?_Decref@facet@locale@std@@QAEPAV123@XZ ENDP		; std::locale::facet::_Decref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
__Lock$9011 = -4					; size = 4
?_Incref@facet@locale@std@@QAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 116  : 			{	// safely increment the reference count

	push	ecx
	push	esi
	mov	esi, ecx

; 117  : 			_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$9011[esp+12]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 118  : 				if (_Refs < (size_t)(-1))

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN1@Incref

; 119  : 					++_Refs;

	add	eax, 1
	mov	DWORD PTR [esi+4], eax
$LN1@Incref:

; 120  : 			_END_LOCK()

	lea	ecx, DWORD PTR __Lock$9011[esp+8]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	esi

; 121  : 			}

	pop	ecx
	ret	0
?_Incref@facet@locale@std@@QAEXXZ ENDP			; std::locale::facet::_Incref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$9005 = -4					; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = esi

; 77   : 			{	// get stamp, with lazy allocation

	push	ecx

; 78   : 			if (_Id == 0)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN6@operator@17

; 79   : 				{	// still zero, allocate stamp
; 80   : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$9005[esp+8]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 81   : 					if (_Id == 0)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN1@operator@17

; 82   : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	add	eax, 1
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR [esi], eax
$LN1@operator@17:

; 83   : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$9005[esp+4]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN6@operator@17:

; 84   : 				}
; 85   : 			return (_Id);

	mov	eax, DWORD PTR [esi]

; 86   : 			}

	pop	ecx
	ret	0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocinfo
_TEXT	ENDS
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T30383 = -20						; size = 16
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; ___$ReturnUdt$ = esi

; 114  : 		{	// return ctype stuff

	sub	esp, 20					; 00000014H

; 115  : 		return (::_Getctype());

	lea	eax, DWORD PTR $T30383[esp+20]
	push	eax
	call	__Getctype
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], edx
	mov	eax, esi

; 116  : 		}

	add	esp, 24					; 00000018H
	ret	0
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@runtime_error@std@@UBEPBDXZ PROC			; std::runtime_error::what, COMDAT
; _this$ = ecx

; 163  : 		return (_Str.c_str());

	cmp	DWORD PTR [ecx+36], 16			; 00000010H
	jb	SHORT $LN7@what
	mov	eax, DWORD PTR [ecx+16]

; 164  : 		}

	ret	0

; 163  : 		return (_Str.c_str());

$LN7@what:
	lea	eax, DWORD PTR [ecx+16]

; 164  : 		}

	ret	0
?what@runtime_error@std@@UBEPBDXZ ENDP			; std::runtime_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 36   : 		return (_Str.c_str());

	cmp	DWORD PTR [ecx+36], 16			; 00000010H
	jb	SHORT $LN7@what@2
	mov	eax, DWORD PTR [ecx+16]

; 37   : 		}

	ret	0

; 36   : 		return (_Str.c_str());

$LN7@what@2:
	lea	eax, DWORD PTR [ecx+16]

; 37   : 		}

	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iterator_base@std@@QAE@XZ PROC			; std::_Iterator_base::_Iterator_base, COMDAT
; _this$ = eax

; 403  : 		{

	mov	DWORD PTR [eax], 0

; 404  : 		}

	ret	0
??0_Iterator_base@std@@QAE@XZ ENDP			; std::_Iterator_base::_Iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 510  : 		return (EOF);

	or	eax, -1

; 511  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT
; __Left$ = eax
; __Right$ = edx

; 505  : 		return (_Left == _Right);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 506  : 		}

	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT
; __Ch$ = eax

; 499  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [eax]

; 500  : 		}

	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT
; __Meta$ = eax

; 494  : 		return ((_Elem)_Meta);

	mov	al, BYTE PTR [eax]

; 495  : 		}

	ret	0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT
; __First$ = edx
; __Count$ = eax
; __Ch$ = ecx

; 488  : //		_DEBUG_POINTER(_First);
; 489  : 		return ((_Elem *)::memset(_First, _Ch, _Count));

	movsx	ecx, cl
	push	eax
	push	ecx
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 490  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Move_s, COMDAT

; 480  : //		_DEBUG_POINTER(_First1);
; 481  : //		_DEBUG_POINTER(_First2);
; 482  : 		_CRT_SECURE_MEMMOVE(_First1, _Size_in_bytes, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size_in_bytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H

; 483  : 		return _First1;

	mov	eax, esi
	pop	esi

; 484  : 		}

	ret	0
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Move_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Copy_s, COMDAT

; 456  : //		_DEBUG_POINTER(_First1);
; 457  : //		_DEBUG_POINTER(_First2);
; 458  : 		_CRT_SECURE_MEMCPY(_First1, _Size_in_bytes, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size_in_bytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 459  : 		return _First1;

	mov	eax, esi
	pop	esi

; 460  : 		}

	ret	0
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Copy_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 441  : //		_DEBUG_POINTER(_First);
; 442  : 		return (::strlen(_First));

	mov	eax, DWORD PTR __First$[esp-4]
	lea	edx, DWORD PTR [eax+1]
$LL3@length:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx

; 443  : 		}

	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 418  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	cl, BYTE PTR [eax]
	mov	edx, DWORD PTR __Left$[esp-4]
	mov	BYTE PTR [edx], cl

; 419  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 65   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 61   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 348  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 349  : 		}

	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 339  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 340  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 617  : 		return _Traits::_Move_s(_First1, _Size, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 618  : 	}

	ret	0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 590  : 		return _Traits::_Copy_s(_First1, _Size, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 591  : 	}

	ret	0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T32011 = -12						; size = 12
$T32015 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 38   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 39   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 42   : 
; 43   : 		// allocate storage for _Count elements of type _Ty
; 44   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 45   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 40   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 1
	jae	SHORT $LN1@Allocate@3

; 41   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T32015[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T32011[esp+16]
	mov	DWORD PTR $T32015[esp+12], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T32011[esp+16]
	push	ecx
	mov	DWORD PTR $T32011[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 609  : 		return move_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 610  : 	}

	ret	0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 582  : 		return copy_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 583  : 	}

	ret	0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
$T32060 = -12						; size = 12
$T32058 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 146  : 		return (_Allocate(_Count, (pointer)0));

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN5@allocate@2
	xor	ecx, ecx
$LN3@allocate@2:
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 147  : 		}

	add	esp, 12					; 0000000cH
	ret	4

; 146  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@2:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 1
	jae	SHORT $LN3@allocate@2
	lea	eax, DWORD PTR $T32058[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T32060[esp+16]
	mov	DWORD PTR $T32058[esp+12], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T32060[esp+16]
	push	ecx
	mov	DWORD PTR $T32060[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@2:
$LN11@allocate@2:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2012 : 		{	// test if _Ptr points inside string

	push	esi

; 2013 : 		_DEBUG_POINTER(_Ptr);
; 2014 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

	mov	esi, DWORD PTR [ecx+24]
	cmp	esi, 16					; 00000010H
	push	edi
	lea	eax, DWORD PTR [ecx+4]
	jb	SHORT $LN8@Inside
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN9@Inside
$LN8@Inside:
	mov	edx, eax
$LN9@Inside:
	mov	edi, DWORD PTR __Ptr$[esp+4]
	cmp	edi, edx
	jb	SHORT $LN2@Inside
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN12@Inside
	mov	eax, DWORD PTR [eax]
$LN12@Inside:
	mov	ecx, DWORD PTR [ecx+20]
	add	ecx, eax
	cmp	ecx, edi
	jbe	SHORT $LN2@Inside
	pop	edi

; 2016 : 		else
; 2017 : 			return (true);

	mov	al, 1
	pop	esi

; 2018 : 		}

	ret	4
$LN2@Inside:
	pop	edi

; 2015 : 			return (false);	// don't ask

	xor	al, al
	pop	esi

; 2018 : 		}

	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z
_TEXT	SEGMENT
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = eax
; __Off$ = esi
; __Count$ = ecx
; __Ch$ = edx

; 1955 : 		if (_Count == 1)

	cmp	ecx, 1
	jne	SHORT $LN2@Chassign

; 1956 : 			_Traits::assign(*(_Myptr() + _Off), _Ch);

	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN7@Chassign
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+esi], dl

; 1959 : 		}

	ret	0

; 1956 : 			_Traits::assign(*(_Myptr() + _Off), _Ch);

$LN7@Chassign:
	add	eax, 4
	mov	BYTE PTR [eax+esi], dl

; 1959 : 		}

	ret	0
$LN2@Chassign:

; 1957 : 		else
; 1958 : 			_Traits::assign(_Myptr() + _Off, _Count, _Ch);

	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN13@Chassign
	mov	eax, DWORD PTR [eax+4]
	push	ecx
	movsx	ecx, dl
	push	ecx
	add	eax, esi
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1959 : 		}

	ret	0

; 1957 : 		else
; 1958 : 			_Traits::assign(_Myptr() + _Off, _Count, _Ch);

$LN13@Chassign:
	push	ecx
	movsx	ecx, dl
	add	eax, 4
	push	ecx
	add	eax, esi
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1959 : 		}

	ret	0
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1993 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	mov	eax, DWORD PTR __Newsize$[esp-4]
	mov	DWORD PTR [ecx+20], eax
	jb	SHORT $LN5@Eos
	mov	ecx, DWORD PTR [ecx+4]
	mov	BYTE PTR [ecx+eax], 0

; 1994 : 		}

	ret	4

; 1993 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$LN5@Eos:
	mov	BYTE PTR [ecx+eax+4], 0

; 1994 : 		}

	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?fail@ios_base@std@@QBE_NXZ PROC			; std::ios_base::fail, COMDAT
; _this$ = eax

; 332  : 		return (((int)rdstate()
; 333  : 			& ((int)badbit | (int)failbit)) != 0);

	mov	eax, DWORD PTR [eax+8]
	and	al, 6
	neg	al
	sbb	eax, eax
	neg	eax

; 334  : 		}

	ret	0
?fail@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::fail
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 322  : 		return (rdstate() == goodbit);

	xor	eax, eax
	cmp	DWORD PTR [ecx+8], eax
	sete	al

; 323  : 		}

	ret	0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T32150 = -20						; size = 16
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = esi

; 1774 : 		{	// initialize from _Lobj

	sub	esp, 20					; 00000014H

; 1775 : 		_Ctype = _Lobj._Getctype();

	lea	eax, DWORD PTR $T32150[esp+20]
	push	eax
	call	__Getctype
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+8], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+12], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+20], edx

; 1776 : 		}

	add	esp, 24					; 00000018H
	ret	0
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = eax

; 1335 : 		}

	mov	DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
	ret	0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = eax

; 1330 : 		{	// default constructor

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 1331 : 		}

	ret	0
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@UAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN6@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_Gfacet@locale@std@@UAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$32183 = -4					; size = 4
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 374  : 		{	// destroy the object

	push	ecx
	push	edi

; 375  : 		if (_Ptr != 0)

	mov	edi, DWORD PTR [ecx]
	test	edi, edi
	je	SHORT $LN4@locale@2

; 376  : 			_DELETE_CRT(_Ptr->_Decref());

	push	0
	lea	ecx, DWORD PTR __Lock$32183[esp+12]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN6@locale@2
	cmp	eax, -1
	jae	SHORT $LN6@locale@2
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN6@locale@2:
	push	esi
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$32183[esp+12]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN9@locale@2
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN9@locale@2:
	pop	esi
$LN4@locale@2:
	pop	edi

; 377  : 		}

	pop	ecx
	ret	0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Lock$32193 = -4					; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = edi
; __Right$ = eax

; 318  : 		{	// construct by copying

	push	ecx
	push	esi
	mov	esi, DWORD PTR [eax]

; 319  : 		_Ptr->_Incref();

	push	0
	lea	ecx, DWORD PTR __Lock$32193[esp+12]
	mov	DWORD PTR [edi], esi
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN3@locale@3
	add	eax, 1
	mov	DWORD PTR [esi+4], eax
$LN3@locale@3:
	lea	ecx, DWORD PTR __Lock$32193[esp+8]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 320  : 		}

	mov	eax, edi
	pop	esi
	pop	ecx
	ret	0
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
tv130 = 8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1202 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebx

; 1203 : 		if (_Mysize < _Off)

	mov	ebx, DWORD PTR __Off$[esp]
	push	esi
	mov	esi, ecx
	cmp	DWORD PTR [esi+20], ebx
	push	edi
	jae	SHORT $LN3@erase

; 1204 : 			_String_base::_Xran();	// _Off off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN3@erase:

; 1205 : 		if (_Mysize - _Off < _Count)

	mov	eax, DWORD PTR [esi+20]
	mov	edi, DWORD PTR __Count$[esp+8]
	sub	eax, ebx
	cmp	eax, edi
	jae	SHORT $LN2@erase

; 1206 : 			_Count = _Mysize - _Off;	// trim _Count

	mov	edi, eax
$LN2@erase:

; 1207 : 		if (0 < _Count)

	test	edi, edi
	jbe	SHORT $LN30@erase

; 1208 : 			{	// move elements down
; 1209 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Myptr() + _Off + _Count,
; 1210 : 				_Mysize - _Off - _Count);

	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, 16					; 00000010H
	push	ebp
	lea	ebp, DWORD PTR [esi+4]
	jb	SHORT $LN8@erase
	mov	edx, DWORD PTR [ebp]
	mov	DWORD PTR tv130[esp+12], edx
	jmp	SHORT $LN9@erase
$LN8@erase:
	mov	DWORD PTR tv130[esp+12], ebp
$LN9@erase:
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN12@erase
	mov	edx, DWORD PTR [ebp]
	jmp	SHORT $LN13@erase
$LN12@erase:
	mov	edx, ebp
$LN13@erase:
	sub	eax, edi
	push	eax
	mov	eax, DWORD PTR tv130[esp+16]
	add	eax, ebx
	add	eax, edi
	push	eax
	sub	ecx, ebx
	push	ecx
	add	edx, ebx
	push	edx
	call	_memmove_s

; 1211 : 			size_type _Newsize = _Mysize - _Count;

	mov	eax, DWORD PTR [esi+20]
	sub	eax, edi
	add	esp, 16					; 00000010H

; 1212 : 			_Eos(_Newsize);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], eax
	jb	SHORT $LN26@erase
	mov	ebp, DWORD PTR [ebp]
$LN26@erase:
	mov	BYTE PTR [eax+ebp], 0
	pop	ebp
$LN30@erase:
	pop	edi

; 1213 : 			}
; 1214 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1215 : 		}

	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2029 : 		if (!_Built)

	cmp	BYTE PTR __Built$[esp-4], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[esp+4]
	mov	esi, ecx
	je	SHORT $LN15@Tidy@3

; 2030 : 			;
; 2031 : 		else if (_BUF_SIZE <= _Myres)

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN15@Tidy@3

; 2032 : 			{	// copy any leftovers to small buffer and deallocate
; 2033 : 			_Elem *_Ptr = _Bx._Ptr;
; 2034 : 			if (0 < _Newsize)

	test	edi, edi
	lea	eax, DWORD PTR [esi+4]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	jbe	SHORT $LN13@Tidy@3

; 2035 : 				_Traits_helper::copy_s<_Traits>(_Bx._Buf, _BUF_SIZE, _Ptr, _Newsize);

	push	edi
	push	ebx
	push	16					; 00000010H
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN13@Tidy@3:

; 2036 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	ebx
$LN15@Tidy@3:

; 2037 : 			}
; 2038 : 		_Myres = _BUF_SIZE - 1;
; 2039 : 		_Eos(_Newsize);

	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	BYTE PTR [esi+edi+4], 0
	pop	edi
	pop	esi

; 2040 : 		}

	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 866  : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 867  : 		_Tidy(true);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN17@basic_stri
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@basic_stri:
	xor	eax, eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], eax
	mov	BYTE PTR [esi+4], al
	pop	esi

; 868  : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = eax

; 551  : 		_Tidy();

	xor	ecx, ecx
	mov	DWORD PTR [eax+24], 15			; 0000000fH
	mov	DWORD PTR [eax+20], ecx
	mov	BYTE PTR [eax+4], cl

; 552  : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
__Lock$33949 = -4					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = edi

; 418  : 		{	// get locale

	push	ecx

; 419  : 		return (*_Ploc);

	mov	ecx, DWORD PTR [eax+36]
	push	esi
	mov	esi, DWORD PTR [ecx]
	push	0
	lea	ecx, DWORD PTR __Lock$33949[esp+12]
	mov	DWORD PTR [edi], esi
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN5@getloc
	add	eax, 1
	mov	DWORD PTR [esi+4], eax
$LN5@getloc:
	lea	ecx, DWORD PTR __Lock$33949[esp+8]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, edi
	pop	esi

; 420  : 		}

	pop	ecx
	ret	0
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 1768 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1769 : 		_Tidy();

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
	jle	SHORT $LN13@ctype
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	_free
	add	esp, 4

; 1770 : 		}

	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	pop	esi
	ret	0
$LN13@ctype:

; 1769 : 		_Tidy();

	jge	SHORT $LN12@ctype
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN12@ctype:

; 1770 : 		}

	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	pop	esi
	ret	0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN8@scalar@12
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@12:
	mov	eax, esi
	pop	esi
	ret	4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??1_Locinfo@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1_Locinfo@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocinfo
xdata$x	ENDS
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT

; 92   :         {

	push	-1
	push	__ehhandler$??1_Locinfo@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+28]

; 93   :         _Locinfo_dtor(this);

	push	esi
	mov	DWORD PTR __$EHRec$[esp+44], 4
	call	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor

; 94   :         }

	mov	ebp, 16					; 00000010H
	add	esp, 4
	cmp	DWORD PTR [esi+112], ebp
	jb	SHORT $LN24@Locinfo
	mov	eax, DWORD PTR [esi+92]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Locinfo:
	xor	ebx, ebx
	mov	edi, 15					; 0000000fH
	mov	DWORD PTR [esi+112], edi
	mov	DWORD PTR [esi+108], ebx
	mov	BYTE PTR [esi+92], bl
	cmp	DWORD PTR [esi+84], ebp
	jb	SHORT $LN50@Locinfo
	mov	eax, DWORD PTR [esi+64]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN50@Locinfo:
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+80], ebx
	mov	BYTE PTR [esi+64], bl
	cmp	DWORD PTR [esi+56], ebp
	jb	SHORT $LN76@Locinfo
	mov	eax, DWORD PTR [esi+36]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN76@Locinfo:
	mov	DWORD PTR [esi+56], edi
	mov	DWORD PTR [esi+52], ebx
	mov	BYTE PTR [esi+36], bl
	cmp	DWORD PTR [esi+28], ebp
	jb	SHORT $LN102@Locinfo
	mov	eax, DWORD PTR [esi+8]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN102@Locinfo:
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+24], ebx
	mov	ecx, esi
	mov	BYTE PTR [esi+8], bl
	mov	DWORD PTR __$EHRec$[esp+40], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 4
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 60					; 0000003cH
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 88					; 00000058H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??1_Locinfo@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\stdexcept
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx

; 158  : 		{	// destroy the object

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 159  : 		}

	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN19@runtime_er
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@runtime_er:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 31   : 		{	// destroy the object

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@

; 32   : 		}

	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN19@logic_erro
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@logic_erro:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
$T36131 = -40						; size = 12
__Newres$ = -28						; size = 4
$T36116 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1962 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 1963 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	esi, eax
	or	esi, 15					; 0000000fH

; 1964 : 		if (max_size() < _Newres)

	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN6@Copy

; 1965 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	esi, eax

; 1966 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $LN4@Copy
$LN6@Copy:

; 1967 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	ebx, DWORD PTR [edi+24]
	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	edx, ecx
	jae	SHORT $LN4@Copy
	mov	eax, -2					; fffffffeH
	sub	eax, ecx
	cmp	ebx, eax
	ja	SHORT $LN4@Copy

; 1968 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	lea	esi, DWORD PTR [ecx+ebx]
$LN4@Copy:

; 1969 : 		_Elem *_Ptr = 0;
; 1970 : 
; 1971 : 		_TRY_BEGIN

	xor	ebx, ebx

; 1972 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	lea	ecx, DWORD PTR [esi+1]
	cmp	ecx, ebx
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	ja	SHORT $LN37@Copy
	xor	ecx, ecx
$LN35@Copy:
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax

; 1980 : 			_CATCH_END
; 1981 : 		_CATCH_END

	jmp	SHORT $LN16@Copy

; 1972 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

$LN37@Copy:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 1
	jae	SHORT $LN35@Copy
	lea	ecx, DWORD PTR $T36116[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T36131[ebp]
	mov	DWORD PTR $T36116[ebp], ebx
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T36131[ebp]
	push	edx
	mov	DWORD PTR $T36131[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN116@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0:

; 1973 : 		_CATCH_ALL
; 1974 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1975 : 			_TRY_BEGIN
; 1976 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	add	eax, 1
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1980 : 			_CATCH_END
; 1981 : 		_CATCH_END

	mov	eax, $LN112@Copy
	ret	0
$LN112@Copy:
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __Newres$[ebp]
$LN16@Copy:

; 1982 : 
; 1983 : 		if (0 < _Oldlen)

	mov	ebx, DWORD PTR __Oldlen$[ebp]
	test	ebx, ebx
	jbe	SHORT $LN78@Copy

; 1984 : 			_Traits_helper::copy_s<_Traits>(_Ptr, _Newres + 1, _Myptr(), _Oldlen);	// copy existing elements

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $LN70@Copy
	mov	eax, DWORD PTR [edi+4]
	jmp	SHORT $LN71@Copy
$LN70@Copy:
	lea	eax, DWORD PTR [edi+4]
$LN71@Copy:
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ebx
	push	eax
	lea	eax, DWORD PTR [esi+1]
	push	eax
	push	ecx
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN78@Copy:

; 1985 : 		_Tidy(true);

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $LN94@Copy
	mov	edx, DWORD PTR [edi+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN94@Copy:

; 1986 : 		_Bx._Ptr = _Ptr;
; 1987 : 		_Myres = _Newres;
; 1988 : 		_Eos(_Oldlen);

	cmp	esi, 16					; 00000010H
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edi+4]
	mov	BYTE PTR [eax], 0
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [edi+24], esi
	mov	DWORD PTR [edi+20], ebx
	jb	SHORT $LN108@Copy
	mov	eax, ecx
$LN108@Copy:
	mov	BYTE PTR [eax+ebx], 0

; 1989 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1:

; 1977 : 			_CATCH_ALL
; 1978 : 			_Tidy(true);	// failed again, discard storage and reraise

	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN58@Copy
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN58@Copy:

; 1979 : 			_RERAISE;

	push	0
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	push	0
	mov	BYTE PTR [esi+4], 0
	call	__CxxThrowException@8
$LN117@Copy:
$LN115@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtpy
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1998 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebx

; 1999 : 			if (max_size() < _Newsize)

	mov	ebx, DWORD PTR __Newsize$[esp]
	cmp	ebx, -2					; fffffffeH
	push	esi
	mov	esi, ecx
	jbe	SHORT $LN6@Grow

; 2000 : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN6@Grow:

; 2001 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	jae	SHORT $LN5@Grow

; 2002 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2008 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2009 : 		}

	ret	8
$LN5@Grow:

; 2003 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	cmp	BYTE PTR __Trim$[esp+4], 0
	je	SHORT $LN3@Grow
	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN3@Grow
	push	edi

; 2004 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2005 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	edi, DWORD PTR [esi+20]
	cmp	ebx, edi
	jae	SHORT $LN9@Grow
	mov	edi, ebx
$LN9@Grow:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN33@Grow
	test	edi, edi
	lea	eax, DWORD PTR [esi+4]
	push	ebp
	mov	ebp, DWORD PTR [eax]
	jbe	SHORT $LN31@Grow
	push	edi
	push	ebp
	push	16					; 00000010H
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN31@Grow:
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	ebp
$LN33@Grow:
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH

; 2008 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	mov	BYTE PTR [esi+edi+4], 0
	cmp	ecx, ebx
	pop	edi
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2009 : 		}

	ret	8
$LN3@Grow:

; 2006 : 		else if (_Newsize == 0)

	test	ebx, ebx
	jne	SHORT $LN49@Grow

; 2007 : 			_Eos(0);	// new size is zero, just null terminate

	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], ebx
	jb	SHORT $LN47@Grow
	mov	esi, DWORD PTR [esi+4]

; 2008 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	mov	BYTE PTR [esi], bl
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2009 : 		}

	ret	8

; 2007 : 			_Eos(0);	// new size is zero, just null terminate

$LN47@Grow:
	add	esi, 4
	mov	BYTE PTR [esi], 0
$LN49@Grow:

; 2008 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2009 : 		}

	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1000 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebx

; 1001 : 		if (_Right.size() < _Roff)

	mov	ebx, DWORD PTR __Right$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Roff$[esp+4]
	cmp	DWORD PTR [ebx+20], ebp
	push	esi
	push	edi
	mov	esi, ecx
	jae	SHORT $LN5@assign

; 1002 : 			_String_base::_Xran();	// _Roff off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN5@assign:

; 1003 : 		size_type _Num = _Right.size() - _Roff;

	mov	edi, DWORD PTR [ebx+20]

; 1004 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[esp+12]
	sub	edi, ebp
	cmp	eax, edi
	jae	SHORT $LN4@assign

; 1005 : 			_Num = _Count;	// trim _Num to size

	mov	edi, eax
$LN4@assign:

; 1006 : 
; 1007 : 		if (this == &_Right)

	cmp	esi, ebx
	jne	SHORT $LN3@assign

; 1008 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	push	-1
	add	edi, ebp
	push	edi
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	push	ebp
	push	0
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1013 : 			}
; 1014 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1015 : 		}

	ret	12					; 0000000cH
$LN3@assign:

; 1009 : 		else if (_Grow(_Num))

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN17@assign
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN17@assign:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN16@assign
	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN87@assign:
	jbe	SHORT $LN86@assign

; 1010 : 			{	// make room and assign new stuff
; 1011 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

	cmp	DWORD PTR [ebx+24], 16			; 00000010H
	jb	SHORT $LN64@assign
	mov	edx, DWORD PTR [ebx+4]
	jmp	SHORT $LN65@assign

; 1009 : 		else if (_Grow(_Num))

$LN16@assign:
	test	edi, edi
	jne	SHORT $LN87@assign
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN58@assign
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1013 : 			}
; 1014 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1015 : 		}

	ret	12					; 0000000cH

; 1009 : 		else if (_Grow(_Num))

$LN58@assign:
	lea	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1013 : 			}
; 1014 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1015 : 		}

	ret	12					; 0000000cH

; 1010 : 			{	// make room and assign new stuff
; 1011 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

$LN64@assign:
	lea	edx, DWORD PTR [ebx+4]
$LN65@assign:
	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, 16					; 00000010H
	lea	ebx, DWORD PTR [esi+4]
	jb	SHORT $LN68@assign
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN69@assign
$LN68@assign:
	mov	eax, ebx
$LN69@assign:
	push	edi
	add	edx, ebp
	push	edx
	push	ecx
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 1012 : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN82@assign
	mov	ebx, DWORD PTR [ebx]
$LN82@assign:
	mov	BYTE PTR [ebx+edi], 0
$LN86@assign:
	pop	edi

; 1013 : 			}
; 1014 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1015 : 		}

	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx
; __Right$ = eax

; 995  : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 996  : 		}

	ret	0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = esi
; __Count$ = ebx

; 953  : 			if (npos - _Mysize <= _Count)

	or	eax, -1
	sub	eax, DWORD PTR [esi+20]
	cmp	eax, ebx
	ja	SHORT $LN2@append

; 954  : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN2@append:

; 955  : 
; 956  : 		size_type _Num;
; 957  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	ebx, ebx
	jbe	$LN79@append
	push	ebp
	mov	ebp, DWORD PTR [esi+20]
	add	ebp, ebx
	cmp	ebp, -2					; fffffffeH
	jbe	SHORT $LN10@append
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN10@append:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebp
	jae	SHORT $LN9@append
	mov	ecx, DWORD PTR [esi+20]
	push	ecx
	push	ebp
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	ebp, ebp
$LN82@append:
	jbe	SHORT $LN80@append

; 958  : 			{	// make room and append new stuff using assign
; 959  : 			_Chassign(_Mysize, _Count, _Ch);

	cmp	ebx, 1
	mov	ecx, DWORD PTR [esi+20]
	push	edi
	lea	edi, DWORD PTR [esi+4]
	jne	SHORT $LN56@append
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN61@append
	mov	eax, DWORD PTR [edi]
	mov	dl, BYTE PTR __Ch$[esp+4]
	mov	BYTE PTR [eax+ecx], dl
	jmp	SHORT $LN69@append

; 955  : 
; 956  : 		size_type _Num;
; 957  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN9@append:
	test	ebp, ebp
	jne	SHORT $LN82@append
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], ebp
	jb	SHORT $LN51@append
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax], 0
	pop	ebp

; 961  : 			}
; 962  : 		return (*this);

	mov	eax, esi

; 963  : 		}

	ret	4

; 955  : 
; 956  : 		size_type _Num;
; 957  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN51@append:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax], 0
	pop	ebp

; 961  : 			}
; 962  : 		return (*this);

	mov	eax, esi

; 963  : 		}

	ret	4

; 958  : 			{	// make room and append new stuff using assign
; 959  : 			_Chassign(_Mysize, _Count, _Ch);

$LN61@append:
	mov	dl, BYTE PTR __Ch$[esp+4]
	mov	eax, edi
	mov	BYTE PTR [eax+ecx], dl
	jmp	SHORT $LN69@append
$LN56@append:
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN67@append
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN68@append
$LN67@append:
	mov	eax, edi
$LN68@append:
	movsx	edx, BYTE PTR __Ch$[esp+4]
	push	ebx
	push	edx
	add	eax, ecx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN69@append:

; 960  : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], ebp
	jb	SHORT $LN75@append
	mov	edi, DWORD PTR [edi]
$LN75@append:
	mov	BYTE PTR [edi+ebp], 0
	pop	edi
$LN80@append:
	pop	ebp
$LN79@append:

; 961  : 			}
; 962  : 		return (*this);

	mov	eax, esi

; 963  : 		}

	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx
; __Newcap$ = eax

; 1627 : 		{	// determine new minimum length of allocated storage

	push	esi
	mov	esi, ecx
	push	edi

; 1628 : 		if (_Mysize <= _Newcap && _Myres != _Newcap)

	mov	edi, DWORD PTR [esi+20]
	cmp	edi, eax
	ja	SHORT $LN11@reserve
	cmp	DWORD PTR [esi+24], eax
	je	SHORT $LN11@reserve

; 1629 : 			{	// change reservation
; 1630 : 			size_type _Size = _Mysize;
; 1631 : 			if (_Grow(_Newcap, true))

	push	1
	push	eax
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN11@reserve

; 1632 : 				_Eos(_Size);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN9@reserve
	mov	esi, DWORD PTR [esi+4]
	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi

; 1633 : 			}
; 1634 : 		}

	ret	0

; 1632 : 				_Eos(_Size);

$LN9@reserve:
	add	esi, 4
	mov	BYTE PTR [esi+edi], 0
$LN11@reserve:
	pop	edi
	pop	esi

; 1633 : 			}
; 1634 : 		}

	ret	0
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = esi
; __Ch$ = ebx

; 902  : 		return (append((size_type)1, _Ch));

	or	eax, -1
	sub	eax, DWORD PTR [esi+20]
	cmp	eax, 1
	ja	SHORT $LN4@operator@23
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN4@operator@23:
	push	edi
	mov	edi, DWORD PTR [esi+20]
	add	edi, 1
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN12@operator@23
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN12@operator@23:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN11@operator@23
	mov	ecx, DWORD PTR [esi+20]
	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN82@operator@23:
	jbe	SHORT $LN81@operator@23
	mov	edx, 16					; 00000010H
	cmp	DWORD PTR [esi+24], edx
	push	ebp
	mov	ebp, DWORD PTR [esi+20]
	lea	eax, DWORD PTR [esi+4]
	jb	SHORT $LN63@operator@23
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN64@operator@23
$LN11@operator@23:
	test	edi, edi
	jne	SHORT $LN82@operator@23
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN53@operator@23
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax], 0
	mov	eax, esi
	pop	edi

; 903  : 		}

	ret	0

; 902  : 		return (append((size_type)1, _Ch));

$LN53@operator@23:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax], 0
	mov	eax, esi
	pop	edi

; 903  : 		}

	ret	0

; 902  : 		return (append((size_type)1, _Ch));

$LN63@operator@23:
	mov	ecx, eax
$LN64@operator@23:
	mov	BYTE PTR [ecx+ebp], bl
	cmp	DWORD PTR [esi+24], edx
	mov	DWORD PTR [esi+20], edi
	pop	ebp
	jb	SHORT $LN77@operator@23
	mov	eax, DWORD PTR [eax]
$LN77@operator@23:
	mov	BYTE PTR [eax+edi], 0
$LN81@operator@23:
	mov	eax, esi
	pop	edi

; 903  : 		}

	ret	0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx
; __Right$ = eax

; 877  : 		return (assign(_Right));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 878  : 		}

	ret	0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 594  : 		{	// construct by copying _Right

	push	esi

; 595  : 		_Tidy();

	xor	eax, eax
	mov	esi, ecx

; 596  : 		assign(_Right, 0, npos);

	push	-1
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	push	eax
	mov	BYTE PTR [esi+4], al
	mov	eax, DWORD PTR __Right$[esp+8]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 597  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx

; 212  : 			{	// destroy the object

	push	esi
	mov	esi, ecx

; 213  : 			}

	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN21@failure
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@failure:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
	jle	SHORT $LN16@scalar@15
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	_free
	jmp	SHORT $LN17@scalar@15
$LN16@scalar@15:
	jge	SHORT $LN6@scalar@15
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
$LN17@scalar@15:
	add	esp, 4
$LN6@scalar@15:
	test	BYTE PTR ___flags$[esp], 1
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN15@scalar@15
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@scalar@15:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	mov	edi, DWORD PTR ___that$[esp+24]
	push	edi
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+36], eax
	push	-1
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	push	eax
	add	edi, 12					; 0000000cH
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	DWORD PTR [ecx+20], eax
	push	edi
	mov	BYTE PTR [ecx+4], al
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0runtime_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	mov	edi, DWORD PTR ___that$[esp+24]
	push	edi
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+36], eax
	push	-1
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	push	eax
	add	edi, 12					; 0000000cH
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	DWORD PTR [ecx+20], eax
	push	edi
	mov	BYTE PTR [ecx+4], al
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
__ehhandler$??0runtime_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
; Function compile flags: /Ogtpy
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN22@scalar@16
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN22@scalar@16:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	ecx, esi
	mov	BYTE PTR [esi+16], al
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN32@scalar@16
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@scalar@16:
	mov	eax, esi
	pop	esi
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\stdexcept
xdata$x	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Message$ = 12						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT

; 154  : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+16]
	mov	ecx, esi
	call	??0exception@std@@QAE@XZ		; std::exception::exception
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+28], eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	push	-1
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	push	eax
	mov	BYTE PTR [ecx+4], al
	mov	eax, DWORD PTR __Message$[esp+24]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 155  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
__ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 110  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 111  : 		}

	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN21@length_err
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@length_err:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN22@scalar@17
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN22@scalar@17:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	ecx, esi
	mov	BYTE PTR [esi+16], al
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN32@scalar@17
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@scalar@17:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\stdexcept
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 27   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	??0exception@std@@QAE@XZ		; std::exception::exception
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+32], eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	push	-1
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	push	eax
	mov	BYTE PTR [ecx+4], al
	mov	eax, DWORD PTR __Message$[esp+28]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 28   : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = esi
; __Count$ = eax

; 912  : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Right$[esp+4]
	push	edi

; 913  : 		if (_Right.size() < _Roff)

	mov	edi, DWORD PTR __Roff$[esp+8]
	cmp	DWORD PTR [ebp+20], edi
	mov	ebx, eax
	jae	SHORT $LN5@append@2

; 914  : 			_String_base::_Xran();	// _Roff off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN5@append@2:

; 915  : 		size_type _Num = _Right.size() - _Roff;

	mov	eax, DWORD PTR [ebp+20]
	sub	eax, edi

; 916  : 		if (_Num < _Count)

	cmp	eax, ebx
	jae	SHORT $LN4@append@2

; 917  : 			_Count = _Num;	// trim _Count to size

	mov	ebx, eax
$LN4@append@2:

; 918  : 		if (npos - _Mysize <= _Count || _Mysize + _Count < _Mysize)

	mov	eax, DWORD PTR [esi+20]
	or	ecx, -1
	sub	ecx, eax
	cmp	ecx, ebx
	jbe	SHORT $LN2@append@2
	lea	edx, DWORD PTR [eax+ebx]
	cmp	edx, eax
	jae	SHORT $LN3@append@2
$LN2@append@2:

; 919  : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN3@append@2:

; 920  : 
; 921  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	ebx, ebx
	jbe	$LN87@append@2
	mov	edi, DWORD PTR [esi+20]
	add	edi, ebx
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN17@append@2
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN17@append@2:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN16@append@2
	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN88@append@2:
	jbe	SHORT $LN87@append@2

; 922  : 			{	// make room and append new stuff
; 923  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize,
; 924  : 				_Right._Myptr() + _Roff, _Count);

	cmp	DWORD PTR [ebp+24], 16			; 00000010H
	jb	SHORT $LN64@append@2
	mov	ebp, DWORD PTR [ebp+4]
	jmp	SHORT $LN65@append@2

; 920  : 
; 921  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN16@append@2:
	test	edi, edi
	jne	SHORT $LN88@append@2
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN58@append@2
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	pop	ebp
	mov	BYTE PTR [eax], 0

; 926  : 			}
; 927  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 928  : 		}

	ret	8

; 920  : 
; 921  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN58@append@2:
	pop	edi
	lea	eax, DWORD PTR [esi+4]
	pop	ebp
	mov	BYTE PTR [eax], 0

; 926  : 			}
; 927  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 928  : 		}

	ret	8

; 922  : 			{	// make room and append new stuff
; 923  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize,
; 924  : 				_Right._Myptr() + _Roff, _Count);

$LN64@append@2:
	add	ebp, 4
$LN65@append@2:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN68@append@2
	mov	edx, DWORD PTR [esi+4]
	jmp	SHORT $LN69@append@2
$LN68@append@2:
	lea	edx, DWORD PTR [esi+4]
$LN69@append@2:
	mov	ecx, DWORD PTR [esi+20]
	push	ebx
	mov	ebx, DWORD PTR __Roff$[esp+12]
	add	ebp, ebx
	sub	eax, ecx
	push	ebp
	push	eax
	add	ecx, edx
	push	ecx
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 925  : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN82@append@2
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	ebp

; 926  : 			}
; 927  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 928  : 		}

	ret	8

; 925  : 			_Eos(_Num);

$LN82@append@2:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+edi], 0
$LN87@append@2:
	pop	edi
	pop	ebp

; 926  : 			}
; 927  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 928  : 		}

	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 1614 : 		{	// determine new length, padding with _Ch elements as needed

	push	ebx
	mov	ebx, eax

; 1615 : 		if (_Newsize <= _Mysize)

	mov	eax, DWORD PTR [ecx+20]
	cmp	ebx, eax
	ja	SHORT $LN2@resize

; 1616 : 			erase(_Newsize);

	push	-1
	push	ebx
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	ebx

; 1619 : 		}

	ret	0
$LN2@resize:
	push	esi

; 1617 : 		else
; 1618 : 			append(_Newsize - _Mysize, _Ch);

	push	0
	sub	ebx, eax
	mov	esi, ecx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi
	pop	ebx

; 1619 : 		}

	ret	0
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1018 : 		{	// assign [_Ptr, _Ptr + _Num)

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1019 : 		if (_Inside(_Ptr))

	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, 16					; 00000010H
	lea	ebx, DWORD PTR [esi+4]
	jb	SHORT $LN12@assign@3
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN13@assign@3
$LN12@assign@3:
	mov	eax, ebx
$LN13@assign@3:
	mov	ebp, DWORD PTR __Ptr$[esp+8]
	cmp	ebp, eax
	jb	SHORT $LN2@assign@3
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN16@assign@3
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN17@assign@3
$LN16@assign@3:
	mov	eax, ebx
$LN17@assign@3:
	mov	edx, DWORD PTR [esi+20]
	add	edx, eax
	cmp	edx, ebp
	jbe	SHORT $LN2@assign@3

; 1020 : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN20@assign@3
	mov	ebx, DWORD PTR [ebx]
$LN20@assign@3:
	mov	eax, DWORD PTR __Num$[esp+8]
	push	eax
	sub	ebp, ebx
	push	ebp
	push	esi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebp
	pop	ebx

; 1028 : 		}

	ret	8
$LN2@assign@3:
	push	edi

; 1021 : 
; 1022 : 		if (_Grow(_Num))

	mov	edi, DWORD PTR __Num$[esp+12]
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN27@assign@3
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN27@assign@3:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN26@assign@3
	mov	ecx, DWORD PTR [esi+20]
	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN93@assign@3:
	jbe	SHORT $LN90@assign@3

; 1023 : 			{	// make room and assign new stuff
; 1024 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Num);

	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN74@assign@3
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN75@assign@3

; 1021 : 
; 1022 : 		if (_Grow(_Num))

$LN26@assign@3:
	test	edi, edi
	jne	SHORT $LN93@assign@3
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN68@assign@3
	mov	ebx, DWORD PTR [ebx]
$LN68@assign@3:
	pop	edi

; 1026 : 			}
; 1027 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	mov	BYTE PTR [ebx], 0
	pop	ebx

; 1028 : 		}

	ret	8

; 1023 : 			{	// make room and assign new stuff
; 1024 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Num);

$LN74@assign@3:
	mov	eax, ebx
$LN75@assign@3:
	push	edi
	push	ebp
	push	ecx
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 1025 : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN88@assign@3
	mov	ebx, DWORD PTR [ebx]
$LN88@assign@3:
	mov	BYTE PTR [ebx+edi], 0
$LN90@assign@3:
	pop	edi

; 1026 : 			}
; 1027 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1028 : 		}

	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = esi
; __Right$ = eax

; 907  : 		return (append(_Right, 0, npos));

	push	0
	push	eax
	or	eax, -1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 908  : 		}

	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 1609 : 		{	// determine new length, padding with null elements as needed

	push	ebx
	mov	ebx, eax

; 1610 : 		resize(_Newsize, _Elem());

	mov	eax, DWORD PTR [ecx+20]
	cmp	ebx, eax
	ja	SHORT $LN4@resize@2
	push	-1
	push	ebx
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	ebx

; 1611 : 		}

	ret	0

; 1610 : 		resize(_Newsize, _Elem());

$LN4@resize@2:
	push	esi
	push	0
	sub	ebx, eax
	mov	esi, ecx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi
	pop	ebx

; 1611 : 		}

	ret	0
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = esi
; __Right$ = eax

; 892  : 		return (append(_Right));

	push	0
	push	eax
	or	eax, -1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 893  : 		}

	ret	0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0runtime_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN24@scalar@22
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@scalar@22:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	ecx, esi
	mov	BYTE PTR [esi+16], al
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN34@scalar@22
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@scalar@22:
	mov	eax, esi
	pop	esi
	ret	4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
??0failure@ios_base@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::ios_base::failure::failure, COMDAT
; _this$ = esi
; __Message$ = eax

; 208  : 			{	// construct with message

	push	eax
	push	esi
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	mov	DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@

; 209  : 			}

	mov	eax, esi
	ret	0
??0failure@ios_base@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::ios_base::failure::failure
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN24@scalar@23
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@scalar@23:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	ecx, esi
	mov	BYTE PTR [esi+16], al
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN34@scalar@23
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@scalar@23:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 106  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 107  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = eax

; 931  : 		{	// append [_Ptr, _Ptr + _Count)

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Count$[esp+4]
	push	esi
	mov	esi, eax

; 932  : 		if (_Inside(_Ptr))

	mov	edx, DWORD PTR [esi+24]
	cmp	edx, 16					; 00000010H
	push	edi
	lea	ebx, DWORD PTR [esi+4]
	jb	SHORT $LN14@append@3
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN15@append@3
$LN14@append@3:
	mov	eax, ebx
$LN15@append@3:
	cmp	ecx, eax
	jb	SHORT $LN4@append@3
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN18@append@3
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN19@append@3
$LN18@append@3:
	mov	eax, ebx
$LN19@append@3:
	mov	edi, DWORD PTR [esi+20]
	add	edi, eax
	cmp	edi, ecx
	jbe	SHORT $LN4@append@3

; 933  : 			return (append(*this, _Ptr - _Myptr(), _Count));	// substring

	cmp	edx, 16					; 00000010H
	jb	SHORT $LN22@append@3
	mov	ebx, DWORD PTR [ebx]
$LN22@append@3:
	sub	ecx, ebx
	push	ecx
	push	esi
	mov	eax, ebp
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 944  : 		}

	ret	8
$LN4@append@3:

; 934  : 		if (npos - _Mysize <= _Count || _Mysize + _Count < _Mysize)

	mov	eax, DWORD PTR [esi+20]
	or	ecx, -1
	sub	ecx, eax
	cmp	ecx, ebp
	jbe	SHORT $LN2@append@3
	lea	edx, DWORD PTR [eax+ebp]
	cmp	edx, eax
	jae	SHORT $LN3@append@3
$LN2@append@3:

; 935  : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN3@append@3:

; 936  : 
; 937  : 		size_type _Num;
; 938  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	ebp, ebp
	jbe	SHORT $LN92@append@3
	mov	edi, DWORD PTR [esi+20]
	add	edi, ebp
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN29@append@3
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN29@append@3:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN28@append@3
	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN95@append@3:
	jbe	SHORT $LN92@append@3

; 939  : 			{	// make room and append new stuff
; 940  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize, _Ptr, _Count);

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN76@append@3
	mov	edx, DWORD PTR [ebx]
	jmp	SHORT $LN77@append@3

; 936  : 
; 937  : 		size_type _Num;
; 938  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN28@append@3:
	test	edi, edi
	jne	SHORT $LN95@append@3
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN70@append@3
	mov	ebx, DWORD PTR [ebx]
$LN70@append@3:
	pop	edi

; 942  : 			}
; 943  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	mov	BYTE PTR [ebx], 0
	pop	ebx

; 944  : 		}

	ret	8

; 939  : 			{	// make room and append new stuff
; 940  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize, _Ptr, _Count);

$LN76@append@3:
	mov	edx, ebx
$LN77@append@3:
	mov	ecx, DWORD PTR [esi+20]
	push	ebp
	mov	ebp, DWORD PTR __Ptr$[esp+16]
	sub	eax, ecx
	push	ebp
	push	eax
	add	ecx, edx
	push	ecx
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 941  : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN90@append@3
	mov	ebx, DWORD PTR [ebx]
$LN90@append@3:
	mov	BYTE PTR [ebx+edi], 0
$LN92@append@3:
	pop	edi

; 942  : 			}
; 943  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 944  : 		}

	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1031 : 		{	// assign [_Ptr, <null>)

	push	esi

; 1032 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, esi
	push	edi
	lea	edi, DWORD PTR [eax+1]
	npad	5
$LL5@assign@4:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL5@assign@4
	sub	eax, edi
	push	eax
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 1033 : 		}

	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; __Ptr$ = edx

; 948  : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	eax, edx
	push	esi
	lea	esi, DWORD PTR [eax+1]
$LL5@append@4:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL5@append@4
	sub	eax, esi
	push	eax
	mov	eax, DWORD PTR _this$[esp+4]
	push	edx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 949  : 		}

	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; __Ptr$ = edx

; 897  : 		return (append(_Ptr));

	mov	eax, edx
	push	esi
	lea	esi, DWORD PTR [eax+1]
$LL7@operator@27:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL7@operator@27
	sub	eax, esi
	push	eax
	mov	eax, DWORD PTR _this$[esp+4]
	push	edx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 898  : 		}

	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 881  : 		{	// assign [_Ptr, <null>)

	push	esi

; 882  : 		return (assign(_Ptr));

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, esi
	push	edi
	lea	edi, DWORD PTR [eax+1]
	npad	5
$LL7@operator@28:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL7@operator@28
	sub	eax, edi
	push	eax
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 883  : 		}

	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 632  : 		_Tidy();
; 633  : 		assign(_Ptr);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	push	esi
	mov	esi, ecx
	mov	eax, edx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	1
$LL37@basic_stri@3:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL37@basic_stri@3
	sub	eax, edi
	push	eax
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi

; 634  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$?clear@ios_base@std@@QAEXH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$2
__ehfuncinfo$?clear@ios_base@std@@QAEXH_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?clear@ios_base@std@@QAEXH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T46538 = -152						; size = 28
$T46536 = -152						; size = 28
$T46537 = -124						; size = 40
$T46535 = -124						; size = 40
$T46539 = -84						; size = 40
$T46540 = -44						; size = 28
__$EHRec$ = -12						; size = 12
__Reraise$ = 8						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 273  :         {	// set state, possibly reraise exception

	push	-1
	push	__ehhandler$?clear@ios_base@std@@QAEXH_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+160]
	mov	DWORD PTR fs:0, eax

; 274  :         _Mystate = (iostate)(_State & _Statmask);
; 275  :         if ((_Mystate & _Except) == 0)
; 276  :             ;
; 277  :         else if (_Reraise)

	cmp	BYTE PTR __Reraise$[esp+156], 0
	je	SHORT $LN6@clear@2

; 278  :             _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN64@clear@2:
$LN6@clear@2:

; 279  :         else if (_Mystate & _Except & badbit)

	mov	eax, DWORD PTR [ecx+12]
	and	eax, DWORD PTR [ecx+8]
	test	al, 4
	je	SHORT $LN4@clear@2

; 280  :             _THROW_NCEE(failure, "ios_base::badbit set");

	push	20					; 00000014H
	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	lea	ecx, DWORD PTR $T46536[esp+168]
	mov	DWORD PTR $T46536[esp+192], 15		; 0000000fH
	mov	DWORD PTR $T46536[esp+188], 0
	mov	BYTE PTR $T46536[esp+172], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T46536[esp+160]
	push	eax
	lea	ecx, DWORD PTR $T46535[esp+164]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+176], 0
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI3?AVfailure@ios_base@std@@
	lea	edx, DWORD PTR $T46535[esp+164]
	push	edx
	mov	DWORD PTR $T46535[esp+168], OFFSET ??_7failure@ios_base@std@@6B@
	call	__CxxThrowException@8
$LN65@clear@2:
$LN4@clear@2:

; 281  :         else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN2@clear@2

; 282  :             _THROW_NCEE(failure, "ios_base::failbit set");

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
	lea	ecx, DWORD PTR $T46538[esp+164]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T46538[esp+160]
	push	eax
	lea	ecx, DWORD PTR $T46537[esp+164]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+176], 1
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI3?AVfailure@ios_base@std@@
	lea	edx, DWORD PTR $T46537[esp+164]
	push	edx
	mov	DWORD PTR $T46537[esp+168], OFFSET ??_7failure@ios_base@std@@6B@
	call	__CxxThrowException@8
$LN66@clear@2:
$LN2@clear@2:

; 283  :         else
; 284  :             _THROW_NCEE(failure, "ios_base::eofbit set");

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
	lea	ecx, DWORD PTR $T46540[esp+164]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T46540[esp+160]
	push	eax
	lea	ecx, DWORD PTR $T46539[esp+164]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+176], 2
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI3?AVfailure@ios_base@std@@
	lea	edx, DWORD PTR $T46539[esp+164]
	push	edx
	mov	DWORD PTR $T46539[esp+168], OFFSET ??_7failure@ios_base@std@@6B@
	call	__CxxThrowException@8
$LN67@clear@2:
$LN63@clear@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$0:
	lea	ecx, DWORD PTR $T46536[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$1:
	lea	ecx, DWORD PTR $T46538[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$2:
	lea	ecx, DWORD PTR $T46540[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?clear@ios_base@std@@QAEXH_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-144]
	mov	ecx, DWORD PTR [edx-148]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?clear@ios_base@std@@QAEXH_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
	DD	04H
	DD	00H
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocinfo
xdata$x	ENDS
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT

; 75   :         {

	push	-1
	push	__ehhandler$??0_Locinfo@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	xor	ebx, ebx
	push	ebx
	mov	ecx, esi
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[esp+32], ebx
	mov	eax, 15					; 0000000fH
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+24], ebx
	mov	BYTE PTR [esi+8], bl
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+52], ebx
	mov	BYTE PTR [esi+36], bl
	mov	DWORD PTR [esi+84], eax
	mov	DWORD PTR [esi+80], ebx
	mov	BYTE PTR [esi+64], bl
	mov	DWORD PTR [esi+112], eax
	mov	DWORD PTR [esi+108], ebx
	mov	BYTE PTR [esi+92], bl

; 76   :         if (_Pch == 0)
; 77   :             _THROW_NCEE(runtime_error, "bad locale name");
; 78   :         _Locinfo_ctor(this, _Pch);

	push	OFFSET ??_C@_01GFHCPBMG@C?$AA@
	push	esi
	mov	BYTE PTR __$EHRec$[esp+40], 4
	call	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
	add	esp, 8

; 79   :         }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 4
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 60					; 0000003cH
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 88					; 00000058H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z$0
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\string
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT
$T52737 = -44						; size = 4
$T52734 = -40						; size = 28
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = esi
; __Right$ = edi

; 54   : 	{	// return string + NTCS

	push	-1
	push	__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+56]
	mov	DWORD PTR fs:0, eax

; 55   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

	mov	eax, DWORD PTR __Left$[esp+52]
	xor	ebx, ebx
	push	-1
	push	ebx
	push	eax
	lea	ecx, DWORD PTR $T52734[esp+68]
	mov	DWORD PTR $T52737[esp+68], ebx
	mov	DWORD PTR $T52734[esp+92], 15		; 0000000fH
	mov	DWORD PTR $T52734[esp+88], ebx
	mov	BYTE PTR $T52734[esp+72], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, edi
	mov	DWORD PTR __$EHRec$[esp+64], ebx
	lea	ebp, DWORD PTR [eax+1]
$LL102@operator@29:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	cmp	cl, bl
	jne	SHORT $LL102@operator@29
	sub	eax, ebp
	push	eax
	push	edi
	lea	eax, DWORD PTR $T52734[esp+64]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	push	-1
	push	ebx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	push	eax
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	DWORD PTR $T52734[esp+80], 16		; 00000010H
	jb	SHORT $LN103@operator@29
	mov	ecx, DWORD PTR $T52734[esp+60]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN103@operator@29:
	mov	eax, esi

; 56   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	ebp
	pop	ebx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z$0:
	lea	ecx, DWORD PTR $T52734[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-40]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z$0
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\string
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT
$T53142 = -44						; size = 4
$T53139 = -40						; size = 28
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = edi

; 34   : 	{	// return NTCS + string

	push	-1
	push	__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+56]
	mov	DWORD PTR fs:0, eax
	xor	ebx, ebx

; 35   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

	mov	eax, OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	DWORD PTR $T53142[esp+56], ebx
	mov	DWORD PTR $T53139[esp+80], 15		; 0000000fH
	mov	DWORD PTR $T53139[esp+76], ebx
	mov	BYTE PTR $T53139[esp+60], bl
	lea	esi, DWORD PTR [eax+1]
$LL104@operator@30:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	cmp	cl, bl
	jne	SHORT $LL104@operator@30
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	lea	ecx, DWORD PTR $T53139[esp+64]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR __Right$[esp+52]
	push	ebx
	push	eax
	or	eax, -1
	lea	esi, DWORD PTR $T53139[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	push	-1
	push	ebx
	mov	DWORD PTR [edi+24], 15			; 0000000fH
	mov	DWORD PTR [edi+20], ebx
	push	eax
	mov	ecx, edi
	mov	BYTE PTR [edi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	DWORD PTR $T53139[esp+80], 16		; 00000010H
	jb	SHORT $LN105@operator@30
	mov	ecx, DWORD PTR $T53139[esp+60]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN105@operator@30:
	mov	eax, edi

; 36   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z$0:
	lea	ecx, DWORD PTR $T53139[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-40]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__Reraise$ = 8						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx
; __State$ = eax

; 43   : 		ios_base::clear((iostate)(_Mystrbuf == 0
; 44   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN3@clear@4
	or	eax, 4
$LN3@clear@4:
	and	eax, 23					; 00000017H
	test	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+8], eax
	je	SHORT $LN11@clear@4
	jmp	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN11@clear@4:

; 45   : 		}

	ret	4
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 53   : 		{	// merge _State into state, possible reraise exception

	push	ecx

; 54   : 		if (_State != goodbit)
; 55   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	mov	eax, DWORD PTR [ecx+8]
	or	eax, DWORD PTR __State$[esp]
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN11@setstate
	or	eax, 4
$LN11@setstate:
	and	eax, 23					; 00000017H
	test	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+8], eax
	je	SHORT $LN19@setstate
	mov	eax, DWORD PTR __Reraise$[esp]
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN19@setstate:
	pop	ecx

; 56   : 		}

	ret	8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = esi

; 548  : 		ios_base::iostate _State = ios_base::goodbit;
; 549  : 		if (!ios_base::fail() && _Myios::rdbuf()->pubsync() == -1)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	lea	eax, DWORD PTR [ecx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN1@flush
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1@flush

; 550  : 			_State |= ios_base::badbit;	// sync failed

	mov	edi, 4
$LN1@flush:

; 551  : 		_Myios::setstate(_State);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN38@flush
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN19@flush
	or	eax, 4
$LN19@flush:
	and	eax, 23					; 00000017H
	test	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+8], eax
	je	SHORT $LN38@flush
	push	0
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN38@flush:

; 552  : 		return (*this);

	mov	eax, esi

; 553  : 		}

	pop	edi
	ret	0
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$??0?$ctype@D@std@@QAE@PBF_NI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ctype@D@std@@QAE@PBF_NI@Z$0
__ehfuncinfo$??0?$ctype@D@std@@QAE@PBF_NI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$ctype@D@std@@QAE@PBF_NI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@PBF_NI@Z
_TEXT	SEGMENT
_this$GSCopy$ = -156					; size = 4
$T53781 = -152						; size = 16
__Lobj$10364 = -136					; size = 116
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$ctype@D@std@@QAE@PBF_NI@Z PROC			; std::ctype<char>::ctype<char>, COMDAT
; _this$ = esi

; 1739 : 		{	// construct with specified table and delete flag for table

	push	-1
	push	__ehhandler$??0?$ctype@D@std@@QAE@PBF_NI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+160], eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+164]
	mov	DWORD PTR fs:0, eax
	xor	eax, eax
	mov	DWORD PTR _this$GSCopy$[esp+164], esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR __$EHRec$[esp+172], eax

; 1740 : 		_BEGIN_LOCINFO(_Lobj)

	lea	eax, DWORD PTR __Lobj$10364[esp+164]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo

; 1741 : 			_Init(_Lobj);

	lea	ecx, DWORD PTR $T53781[esp+164]
	push	ecx
	call	__Getctype
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+12], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+16], edx
	mov	eax, DWORD PTR [eax+12]
	add	esp, 4

; 1742 : 		_END_LOCINFO()

	lea	ecx, DWORD PTR __Lobj$10364[esp+164]
	push	ecx
	mov	DWORD PTR [esi+20], eax
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo

; 1743 : 		if (_Table != 0)
; 1744 : 			{	// replace existing char to mask table
; 1745 : 			_Tidy();
; 1746 : 			_Ctype._Table = _Table;
; 1747 : 			_Ctype._Delfl = _Deletetable ? -1 : 0;
; 1748 : 			}
; 1749 : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+164]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+160]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 160				; 000000a0H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ctype@D@std@@QAE@PBF_NI@Z$0:
	mov	eax, DWORD PTR _this$GSCopy$[ebp]
	jmp	??1ctype_base@std@@UAE@XZ		; std::ctype_base::~ctype_base
__ehhandler$??0?$ctype@D@std@@QAE@PBF_NI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-148]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 0
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$ctype@D@std@@QAE@PBF_NI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$ctype@D@std@@QAE@PBF_NI@Z ENDP			; std::ctype<char>::ctype<char>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT
$T57357 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z PROC	; std::ctype<char>::_Getcat, COMDAT
; __Ppf$ = edi

; 1758 : 		{	// construct from specified locale

	push	-1
	push	__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax

; 1759 : 		if (_Ppf != 0 && *_Ppf == 0)

	test	edi, edi
	je	SHORT $LN8@Getcat@3
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN8@Getcat@3

; 1760 : 			*_Ppf = _NEW_CRT ctype<_Elem>;

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T57357[esp+28], eax
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	je	SHORT $LN4@Getcat@3
	mov	esi, eax
	call	??0?$ctype@D@std@@QAE@PBF_NI@Z		; std::ctype<char>::ctype<char>
	jmp	SHORT $LN5@Getcat@3
$LN4@Getcat@3:
	xor	eax, eax
$LN5@Getcat@3:
	mov	DWORD PTR [edi], eax
$LN8@Getcat@3:

; 1761 : 		return (_X_CTYPE);

	mov	eax, 2

; 1762 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z$0:
	mov	eax, DWORD PTR $T57357[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z ENDP	; std::ctype<char>::_Getcat
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$21988 = -36					; size = 4
__Lock$60201 = -32					; size = 4
__Lock$21987 = -28					; size = 4
$T60193 = -24						; size = 12
__$EHRec$ = -12						; size = 12
__Lock$60222 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 466  : 	{	// get facet reference from locale

	push	-1
	push	__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, eax

; 467  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$21987[esp+52]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[esp+56], 0

; 468  : 		const locale::facet *_Psave =
; 469  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 470  : 
; 471  : 		size_t _Id = _Facet::id;

	cmp	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, 0 ; std::ctype<char>::id
	mov	edi, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
	mov	DWORD PTR __Psave$21988[esp+48], edi
	jne	SHORT $LN11@use_facet@3
	push	0
	lea	ecx, DWORD PTR __Lock$60201[esp+52]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	cmp	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, 0 ; std::ctype<char>::id
	jne	SHORT $LN10@use_facet@3
	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	add	eax, 1
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, eax ; std::ctype<char>::id
$LN10@use_facet@3:
	lea	ecx, DWORD PTR __Lock$60201[esp+48]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN11@use_facet@3:

; 472  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	eax, DWORD PTR __Loc$[esp+44]
	mov	esi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
	mov	eax, DWORD PTR [eax]
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN20@use_facet@3
	mov	ecx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+esi*4]
	test	ecx, ecx
	jne	SHORT $LN16@use_facet@3
$LN30@use_facet@3:
	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN16@use_facet@3
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN31@use_facet@3
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN15@use_facet@3
$LN20@use_facet@3:
	xor	ecx, ecx
	jmp	SHORT $LN30@use_facet@3
$LN16@use_facet@3:
	mov	esi, ecx
$LN15@use_facet@3:

; 473  : 
; 474  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN28@use_facet@3
$LN31@use_facet@3:

; 475  : 			;	// got facet from locale
; 476  : 		else if (_Psave != 0)

	test	edi, edi
	je	SHORT $LN4@use_facet@3

; 477  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, edi
	jmp	SHORT $LN28@use_facet@3
$LN4@use_facet@3:

; 478  : 		else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

	lea	edi, DWORD PTR __Psave$21988[esp+48]
	call	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z ; std::ctype<char>::_Getcat
	cmp	eax, -1
	jne	SHORT $LN2@use_facet@3

; 479  : 
; 480  :  #if _HAS_EXCEPTIONS
; 481  : 		_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T60193[esp+52]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	eax, DWORD PTR $T60193[esp+52]
	push	eax
	call	__CxxThrowException@8
$LN34@use_facet@3:
$LN2@use_facet@3:

; 482  : 
; 483  : 	#else /* _HAS_EXCEPTIONS */
; 484  : 			abort();	// lazy disallowed
; 485  : 	#endif /* _HAS_EXCEPTIONS */
; 486  : 
; 487  : 		else
; 488  : 			{	// queue up lazy facet for destruction
; 489  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$21988[esp+48]

; 490  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 491  : 
; 492  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 493  : 			_Pfmod->_Incref();

	push	0
	lea	ecx, DWORD PTR __Lock$60222[esp+48]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN24@use_facet@3
	add	eax, 1
	mov	DWORD PTR [esi+4], eax
$LN24@use_facet@3:
	lea	ecx, DWORD PTR __Lock$60222[esp+44]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 494  : 			_Pfmod->_Register();

	push	esi
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	add	esp, 4
$LN28@use_facet@3:

; 495  : 			}
; 496  : 
; 497  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$21987[esp+48]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 498  : 	_END_LOCK()
; 499  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 36					; 00000024H
	ret	0
$LN33@use_facet@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$21987[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-32]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
END
